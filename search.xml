<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Homebrew 使用总结]]></title>
    <url>%2F2018%2F03%2F31%2Fmac%2Fhow-to-used-homebrew%2F</url>
    <content type="text"><![CDATA[Homebrew 是什么？ Homebrew是Mac OSX上的软件包管理工具，能在Mac中方便的安装软件或者卸载软件，相当于linux下的apt-get、yum神器；Homebrew可以在Mac上安装一些OS X没有的UNIX工具，Homebrew将这些工具统统安装到了 /usr/local/Cellar 目录中，并在 /usr/local/bin 中创建符号链接 安装Homebrew 的安装只需要一条命令 1ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" Homebrew安装成功后，会自动创建目录 /usr/local/Cellar 来存放Homebrew安装的程序。 常用命令更新 Homebrew 自己1brew update 更新包（formula 你想安装的软件）123456## 查看哪些包可以更新brew outdated## 更新包brew upgrade # 更新所有的包brew upgrade $FORMULA # 更新指定的包 清理 旧版本与缓存文件新版本安装了，那旧版本一般就不需要了。 123brew cleanup # 清理所有包的清理旧版本和缓存文件brew cleanup $FORMULA # 清理指定包的旧版本和缓存文件brew cleanup -n # 查看可清理的旧版本包和缓存文件，不执行清理操作 Homebrew 只会清除比当前安装的包更老的版本，所以不用担心有些包没更新但被删了。 锁定不想更新的包brew update 一次可以更新所有的包看起来是非常方便，但使用这个命令可能会把一些我们不希望更新的包给更新了。比如，数据库，尤其是 PostgreSQL 跨 minor 版本升级都要迁移数据库的。 人们对神说那我们该怎办呢？于是就有了 brew pin 12brew pin $FORMULA # 锁定某个包brew unpin $FORMULA # 取消锁定 查看包的信息brew info 可以查看包的相关信息，最有用的应该是包依赖和相应的命令。比如 Nginx 会提醒你怎么加 launchctl ，PostgreSQL 会告诉你如何迁移数据库。这些信息会在包安装完成后自动显示，如果忘了的话可以用这个命令很方便地查看。 12brew info $FORMULA # 显示某个包的信息brew info # 显示安装了包数量，文件数量，和总占用空间 1234567891011121314151617# cui @ Cui-MacBook-Pro in ~ [21:20:39]$ brew info gitgit: stable 2.16.3 (bottled), HEADDistributed revision control systemhttps://git-scm.com/usr/local/Cellar/git/2.16.2 (1,496 files, 34.5MB) * Poured from bottle on 2018-03-03 at 23:32:35From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/git.rb==&gt; DependenciesOptional: pcre2 ✘, gettext ✔, openssl ✘, curl ✘, perl ✔==&gt; Options......# cui @ Cui-MacBook-Pro in ~ [21:23:43]$ brew info20 kegs, 29,559 files, 254.2MB 显示包的依赖关系12## brew deps 可以显示包的依赖关系，然后判断哪些包是可以安全删除的。brew deps --installed --tree # 查看已安装的包的依赖，树形显示 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768$ brew deps --installed --treeautojumpbash-completiongdbmgettextgitlibidn2├── gettext└── libunistringlibunistringlibyamlmavenopensslperlpython├── gdbm├── openssl├── readline├── sqlite│ └── readline└── xzreadlineruby├── libyaml├── openssl└── readlinesqlite└── readlinetreevim├── perl├── ruby│ ├── libyaml│ ├── openssl│ └── readline└── python ├── gdbm ├── openssl ├── readline ├── sqlite │ └── readline └── xzwget├── libidn2│ ├── gettext│ └── libunistring└── opensslxzzsh-syntax-highlighting 遇到问题1 执行 Homebrew 命令报错：2018-03-31 更新 Mac 系统到 10.13.4，使用 brew 命令出现 12xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunError: Failure while executing: git config --local --replace-all homebrew.analyticsmessage true 解决办法是一条命令 12## 安装 xcode工具包（并不是安装完整的 xcode）xcode-select --install 2. 执行 brew update 命令 卡在命令行 解决办法是挂代理 （云墙） 换 brew 源 （动手搜索，网上有教程）]]></content>
      <tags>
        <tag>Mac</tag>
        <tag>Homebrew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Cloud 免费云服务]]></title>
    <url>%2F2018%2F03%2F01%2Flinux%2FGoogle-Cloud-Ubuntu-Free%2F</url>
    <content type="text"><![CDATA[谷歌云 Google Cloud 免费一年服务 因自己是程序猿一只，编程需要，要用 google 搜索 正好了解到 Google Cloud 大法好 申请免费谷歌云服务器要想利用谷歌云搭建XX服务有两个前提条件： 拥有其中一张信用卡：Visa、MasterCard、JCB；（我的是工商银行信用卡） 有一个可以临时「自由访问」的网络。 打开谷歌云：https://cloud.google.com 登录你的谷歌账户然后点击免费试用。 地区请选择美国，账号选择个人，填写「名称和地址」，不知如何填写的，在浏览器打开：http://t.cn/Rt85282。会随机生成一个美国公民的身份，然后按照提示填写。**不要用下图的信息**。 填写「付款方式」，填写你的信用卡号，会扣1美元境外 POS费用，不用怕大概10分钟内就会自己退，到期之后不会自己扣费，持卡人姓名填写上面生成的名字即可。 点击开始免费试用，再进入「我的控制台」，创建一个项目，项目名称随便 点击左上角按钮，然后点击「结算」查看谷歌赠送给的 $300 是否到位了。刚注册会显示剩余的赠金：$300，剩余天数：365。 然后点击：计算 -&gt; Compute Engine -&gt; VM 实例 -&gt; 创建实例。 按照下图中标注的信息填写，其他默认即可。 点击创建，等待创建完成。创建完成之后，「外部 IP」就是服务器的地址。（可以测试一下实例的速度如何，当然也可以不测试，基本是没问题的。测试地址：http://t.cn/Ry2GtDf，只要均在 100 毫秒之内，说明就没问题，如果超出就删除这个实例，重新建一个实例试试。 ） 配置谷歌云服务器配置服务器。务必仔细操作。点击下图 SSH 连接 在命令行输入： 12345# 1. 切换 root 用户sudo -i# 2. 魔改内核wget -N --no-check-certificate https://raw.githubusercontent.com/FunctionClub/YankeeBBR/master/bbr.sh &amp;&amp; bash bbr.sh install 输入命令后回车，耐心等待，直到出现下图中的窗口， 输入 y，回车。可以等待重启，或者直接关闭该窗口，重新打开。 12345678910# 3. 切换 root 用户sudo -i# 4. bash bbr.sh start# 5. wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh &amp;&amp; chmod +x shadowsocksR.sh# 6. ./shadowsocksR.sh 出现下图所示内容，则证明上面的工作成功。 设置密码和端口。在上面所示窗口中输入密码，随便，自己记住就可以，回车；然后会提示输入端口，也是随便，只要在 1-65535 之间就行，我设置的是 8998。 设置完密码和端口，会提示输入编码方式、混淆方式等，这里直接默认就好，一路回车。在最后一步回车之后，大约需要等待 5、6 分钟，这个过程是在配置服务器，耐心等待就好，千万不要关闭窗口。 直到出现以下画面 配置防火墙规则，搜索 防火墙规则 设置协议端口：把端口号设置成刚才我们自己规定的端口号，我的是 8998。修改时输入：tcp:8998; udp:8998，注意，分号“；”后面紧跟一个空格。只设置图中圈红的两个，这两个必须设置，不要漏掉，其余默认。 终于搭建结束了。。。。。。 搭建完就可以在你的设备上使用了，全平台支持，只需要下载对应的客户端。Mac、Windows、Android 的客户端可以在 GitHub 上搜索 shadowsocks 自行查找。iOS 的客户端需要 App Store 登录国外 ID，然后搜索 Shadowrocket 或者 Wingy。这些客户端如何使用自行搜索，我不知道怎么使用，你懂。 这个速度看某 tube 视频网站的 4k 视频无压力。]]></content>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Google Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java垃圾回收机制（一）]]></title>
    <url>%2F2017%2F06%2F15%2F9-JVM%2FJavaGC-1%2F</url>
    <content type="text"><![CDATA[什么是 Java 堆内存堆是在 JVM 启动时创建的，主要用来维护运行时数据，如运行过程中创建的对象和数组都是基于这块内存空间。Java 堆是非常重要的元素，如果我们动态创建的对象没有得到及时回收，持续堆积，最后会导致堆空间被占满，内存溢出。因此，Java 提供了一种垃圾回收机制，在后台创建一个守护进程。该进程会在内存紧张的时候自动跳出来，把堆空间的垃圾全部进行回收，从而保证程序的正常运行。 那什么是垃圾呢？所谓“垃圾”，就是指所有不再存活的对象。常见的判断是否存活有两种方法：引用计数法和可达性分析。 引用计数法为每一个创建的对象分配一个引用计数器，用来存储该对象被引用的个数。当该个数为零，意味着没有人再使用这个对象，可以认为“对象死亡”。但是，这种方案存在严重的问题，就是无法检测“循环引用”：当两个对象互相引用，即时它俩都不被外界任何东西引用，它俩的计数都不为零，因此永远不会被回收。而实际上对于开发者而言，这两个对象已经完全没有用处了。因此，Java 里没有采用这样的方案来判定对象的“存活性”。 可达性分析这种方案是目前主流语言里采用的对象存活性判断方案。基本思路是把所有引用的对象想象成一棵树，从树的根结点 GC Roots 出发，持续遍历找出所有连接的树枝对象，这些对象则被称为“可达”对象，或称“存活”对象。其余的对象则被视为“死亡”的“不可达”对象，或称“垃圾”。参考下图，object5,object6和object7便是不可达对象，视为“死亡状态”，应该被垃圾回收器回收。 GC Roots 究竟指谁呢？我们可以猜测，GC Roots 本身一定是可达的，这样从它们出发遍历到的对象才能保证一定可达。那么，Java 里有哪些对象是一定可达呢？主要有以下四种： 虚拟机栈（帧栈中的本地变量表）中引用的对象。 方法区中静态属性引用的对象。 方法区中常量引用的对象。 本地方法栈中JNI引用的对象。 不少读者可能对这些 GC Roots 似懂非懂，这涉及到 JVM 本身的内存结构等等，未来的文章会再做深入讲解。这里只要知道有这么几种类型的 GC Roots，每次垃圾回收器会从这些根结点开始遍历寻找所有可达节点。 有哪些方式来回收这些垃圾呢？上面已经知道，所有GC Roots不可达的对象都称为垃圾，参考下图，黑色的表示垃圾，灰色表示存活对象，绿色表示空白空间。 那么，我们如何来回收这些垃圾呢？ 标记－清理第一步，所谓“标记”就是利用可达性遍历堆内存，把“存活”对象和“垃圾”对象进行标记，得到的结果如上图；第二步，既然“垃圾”已经标记好了，那我们再遍历一遍，把所有“垃圾”对象所占的空间直接清空即可。结果如下： 这便是标记－清理方案，简单方便，但是容易产生内存碎片。 标记－整理既然上面的方法会产生内存碎片，那好，我在清理的时候，把所有存活对象扎堆到同一个地方，让它们待在一起，这样就没有内存碎片了。结果如下： 这两种方案适合存活对象多，垃圾少的情况，它只需要清理掉少量的垃圾，然后挪动下存活对象就可以了。复制这种方法比较粗暴，直接把堆内存分成两部分，一段时间内只允许在其中一块内存上进行分配，当这块内存被分配完后，则执行垃圾回收，把所有存活对象全部复制到另一块内存上，当前内存则直接全部清空。参考下图： 起初时只使用上面部分的内存，直到内存使用完毕，才进行垃圾回收，把所有存活对象搬到下半部分，并把上半部分进行清空。这种做法不容易产生碎片，也简单粗暴；但是，它意味着你在一段时间内只能使用一部分的内存，超过这部分内存的话就意味着堆内存里频繁的复制清空。这种方案适合存活对象少，垃圾多的情况，这样在复制时就不需要复制多少对象过去，多数垃圾直接被清空处理。 Java 的分代回收机制上面我们看到有至少三种方法来回收内存，那么 Java 里是如何选择利用这三种回收算法呢？是只用一种还是三种都用呢？ Java 的堆结构在选择回收算法前，我们先来看一下 Java 堆的结构。一块 Java 堆空间一般分成三部分，这三部分用来存储三类数据： 刚刚创建的对象。在代码运行时会持续不断地创造新的对象，这些新创建的对象会被统一放在一起。因为有很多局部变量等在新创建后很快会变成不可达的对象，快速死去，因此这块区域的特点是存活对象少，垃圾多。形象点描述这块区域为：新生代； 存活了一段时间的对象。这些对象早早就被创建了，而且一直活了下来。我们把这些存活时间较长的对象放在一起，它们的特点是存活对象多，垃圾少。形象点描述这块区域为：老年代； 永久存在的对象。比如一些静态文件，这些对象的特点是不需要垃圾回收，永远存活。形象点描述这块区域为：永久代。（不过在 Java 8 里已经把永久代删除了，把这块内存空间给了元空间，后续文章再讲解。）也就是说，常规的 Java 堆至少包括了 新生代 和 老年代 两块内存区域，而且这两块区域有很明显的特征： 新生代：存活对象少、垃圾多 老年代：存活对象多、垃圾少 结合新生代／老年代的存活对象特点和之前提过的几种垃圾回收算法，可以得到如下的回收方案： 新生代－复制回收机制对于新生代区域，由于每次 GC 都会有大量新对象死去，只有少量存活。因此采用复制回收算法，GC 时把少量的存活对象复制过去即可。那么如何设计这个复制算法比较好呢？有以下几种方式： 思路1. 把内存均分成 1:1 两等份如下图拆分内存。 每次只使用一半的内存，当这一半满了后，就进行垃圾回收，把存活的对象直接复制到另一半内存，并清空当前一半的内存。这种分法的缺陷是相当于只有一半的可用内存，对于新生代而言，新对象持续不断地被创建，如果只有一半可用内存，那显然要持续不断地进行垃圾回收工作，反而影响到了正常程序的运行，得不偿失。 思路2. 把内存按 9:1 分既然上面的分法导致可用内存只剩一半，那么我做些调整，把 1:1变成9:1， 最开始在 9 的内存区使用，当 9 快要满时，执行复制回收，把 9 内仍然存活的对象复制到 1 区，并清空 9区。这样看起来是比上面的方法好了，但是它存在比较严重的问题。当我们把 9 区存活对象复制到 1 区时，由于内存空间比例相差比较大，所以很有可能 1 区放不满，此时就不得不把对象移到 老年区。而这就意味着，可能会有一部分 并不老 的 9 区对象由于 1 区放不下了而被放到了 老年区，可想而知，这破坏了 老年区 的规则。或者说，一定程度上的 老年区 并不一定全是 老年对象。那应该如何才能把真正比较 老 的对象挪到 老年区 呢？ 思路3. 把内存按 8:1:1 分既然 9:1 有可能把年轻对象放到 老年区，那就换成 8:1:1，依次取名为 Eden、Survivor A、Survivor B区，其中Eden意为伊甸园，形容有很多新生对象在里面创建；Survivor区则为幸存者，即经历 GC 后仍然存活下来的对象。工作原理如下： 首先，Eden区最大，对外提供堆内存。当 Eden 区快要满了，则进行 Minor GC，把存活对象放入Survivor A区，清空 Eden 区； Eden区被清空后，继续对外提供堆内存； 当Eden区再次被填满，此时对Eden区和Survivor A区同时进行 Minor GC，把存活对象放入Survivor B区，同时清空Eden 区和Survivor A区； Eden区继续对外提供堆内存，并重复上述过程，即在Eden区填满后，把Eden区和某个Survivor区的存活对象放到另一个Survivor区； 当某个Survivor区被填满，且仍有对象未被复制完毕时，或者某些对象在反复Survive 15 次左右时，则把这部分剩余对象放到Old区； 当 Old 区也被填满时，进行 Major GC，对 Old 区进行垃圾回收。 [注意，在真实的 JVM 环境里，可以通过参数 SurvivorRatio 手动配置Eden区和单个Survivor区的比例，默认为8。]那么，所谓的 Old 区垃圾回收，或称Major GC，应该如何执行呢？ 老年代－标记整理回收机制根据上面我们知道，老年代一般存放的是存活时间较久的对象，所以每一次 GC 时，存活对象比较较大，也就是说每次只有少部分对象被回收。因此，根据不同回收机制的特点，这里选择存活对象多，垃圾少的标记整理回收机制，仅仅通过少量地移动对象就能清理垃圾，而且不存在内存碎片化。至此，我们已经了解了 Java 堆内存的分代原理，并了解了不同代根据各自特点采用了不同的回收机制，即新生代采用回收机制，老年代采用标记整理机制。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Supervisor linux 进程管理利器]]></title>
    <url>%2F2017%2F06%2F14%2Flinux%2FSupervisor-linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%88%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[为何使用 Supervisor由于公司项目需求，需要将服务器内核升级为高版本。而定制版阿里云服务器不允许用户自行更改内核，于是只好格式化原服务器，选择 Ubuntu 系统 重新安装各种软件。 2017年年初，公司阿里云服务器版本是阿里云定制版本： 安装完毕，查看内核（方法有三）如下： 123456789oot@iZ23u31elifZ:~# uname -aLinux iZ23u31elifZ 4.4.0-79-generic #100-Ubuntu SMP Wed May 17 19:58:14 UTC 2017 x86_64 x86_64 x86_64 GNU/Linuxroot@iZ23u31elifZ:~# cat /proc/versionLinux version 4.4.0-79-generic (buildd@lcy01-30) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) #100-Ubuntu SMP Wed May 17 19:58:14 UTC 2017root@iZ23u31elifZ:~# uname -r4.4.0-79-genericroot@iZ23u31elifZ:~# 满足内核要求。 但是满足内核要求后，之前写好且运行正常的进程监控 shell 脚本在 Ubuntu 下不再正常工作了。 经过一天的研究，决定放弃 shell 脚本，采用廖雪峰老师推荐的 Supervisor 进程监控软件。文章链接地址 supervisor安装Debian / Ubuntu可以直接通过apt安装： 1# apt-get install supervisor 脚本编写然后，给我们自己开发的应用程序编写一个配置文件，让supervisor来管理它。每个进程的配置文件都可以单独分拆，放在/etc/supervisor/conf.d/目录下，可以.ini作为扩展名（或者以.conf），例如，tomcat.ini 定义了一个gunicorn的进程： Tomcat 自启动脚本12345678910root@iZ23u31elifZ:/etc/supervisor/conf.d# more tomcat_auto.ini[program:tomcat]command=/usr/local/tomcat/bin/catalina.sh runstdout_logfile=/usr/local/tomcat/logs/catalina.outautostart=trueautorestart=truestartsecs=5priority=1stopasgroup=truekillasgroup=true 其中，进程tomcat定义在[program:tomcat]中，command是命令，stdout_logfile是进程日志输出路径。重启supervisor，让配置文件生效，然后运行命令supervisorctl启动进程： Java 项目项目自启动Java 启动脚本1234567891011root@iZ23u31elifZ:/home/DPP-LOCAL/DPP-LOCAL-AlertCenter# more StartDPPLOCALAlertCenter#!/bin/shexport JAVA_HOME=/usr/local/jdk_64export CLASSPATH=$CLASSPATH:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:./lib/classes12.jar:./lib/dom4j-1.6.1.jar:./lib/log4j-1[1].2.15.jar:./lib/mysql-connector-java-5.1.15-bin.jar:./lib/sqljdbc4.jarexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$JAVA_HOME/jre/lib/amd64:$JAVA_HOME/jre/lib/amd64/native_threads:$JAVA_HOME/jre/lib/amd64/client:$JAVA_HOME/jre/lib/amd64/server:./cd /home/DPP-LOCAL/DPP-LOCAL-AlertCenter$JAVA_HOME/bin/java DPPLOCALAlertCenter.Main supervisor 自启脚本123456789[program:DPPAlertCenter]command=sh /home/DPP-LOCAL/DPP-LOCAL-AlertCenter/StartDPPLOCALAlertCenterstdout_logfile=/home/DPP-LOCAL/DPP-LOCAL-AlertCenter/logs/DPPLOCAL_AlertCenter_autostart=trueautorestart=truestartsecs=5priority=2stopasgroup=truekillasgroup=true 启动 Supervisor手动启动，暴力关闭1234567# ps -ef |grep super# root 6059 1 0 11:45 ? 00:00:00 /usr/bin/python /usr/bin/supervisord -c /etc/supervisor/supervisord.confroot 6238 3465 0 11:53 pts/3 00:00:00 grep --color=auto super# kill 6059# supervisord -c /etc/supervisor/supervisord.conf 进程名-启动脚本进程名配置：即每个配置文件的 program 对应的值 1[program:DPPAlertCenter] 12345启动进程：# supervisorctl start [进程名]停止进程：# supervisorctl stop [进程名] Supervisor 图形界面设置核心配置： 1234567891011121314151617181920212223242526272829root@iZ23u31elifZ:/etc/supervisor# lsconf.d supervisord.confroot@iZ23u31elifZ:/etc/supervisor# more supervisord.conf; supervisor config file[unix_http_server]file=/var/run/supervisor.sock ; (the path to the socket file)chmod=0700 ; sockef file mode (default 0700)[supervisord]logfile=/var/log/supervisor/supervisord.log ; (main log file;default $CWD/supervisord.log)pidfile=/var/run/supervisord.pid ; (supervisord pidfile;default supervisord.pid)childlogdir=/var/log/supervisor ; (&apos;AUTO&apos; child log dir, default $TEMP); the below section must remain in the config file for RPC; (supervisorctl/web interface) to work, additional interfaces may be; added by defining them in separate rpcinterface: sections[rpcinterface:supervisor]supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface[supervisorctl]serverurl=unix:///var/run/supervisor.sock ; use a unix:// URL for a unix socket; The [include] section can just contain the &quot;files&quot; setting. This; setting can list multiple files (separated by whitespace or; newlines). It can also contain wildcards. The filenames are; interpreted as relative to this file. Included files *cannot*; include files themselves.[inet_http_server] ; 采用HTPP连接supervisord server，默认关闭port=0.0.0.0:9008 ; 指定可以连接supervisord server的ip地址及其所使用的端口号，*:port针对任何ip开放连接权限username=best ; 指定supervisorctl连接时需要使用的用户名，默认不需用户名password=best8***[include]files = /etc/supervisor/conf.d/*.ini ; *.ini 代表所有某目录下所有的 ini配置文件，后缀名可以为`.conf或者.ini` 注意看最后有中文注释的地方，配置端口，用户名和密码 123port=0.0.0.0:9008 ; 指定可以连接supervisord server的ip地址及其所使用的端口号，*:port针对任何ip开放连接权限username=best ; 指定supervisorctl连接时需要使用的用户名，默认不需用户名password=best8*** 然后浏览器打开相应地址就能看到监控界面啦！跟 ActiveMQ 监控界面类似，不过 Supervisor 要简单许多！如下图 其他选项具体请参考 supervisor文档 Enjoy！！！]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Supervisor</tag>
        <tag>进程管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多说评论关闭]]></title>
    <url>%2F2017%2F06%2F12%2F%E5%A4%9A%E8%AF%B4%E8%AF%84%E8%AE%BA%E5%85%B3%E9%97%AD%2F</url>
    <content type="text"><![CDATA[评论不见了今早登录博客，发现博客的评论全不在了。不要着急，慢慢排查。 查看主题配置难道是是我之前更新文章时，不小心改动啥配置，于是查找HEXO 主题配置 _config.yml 配置是1duoshuo: &quot;cuijing&quot; 已确认开启了哇！？！？ 查看网络情况难道是住处网络问题，于是查看用手机分享 WiFi 给 Mac使用，发现还是看不到评论。 把 云强 VPN 挂起来 再试，依然依然 看不到评论。 难道不是网络问题，是官网配置过期了吗？ 查看多说官网输入多说评论俨然几个红色提醒：多说已于2017年6月1日关闭 结果现在官网已经登录不了，数据已经不能恢复了，虽然数据很少，但也有点心塞。 不管怎样，也曾有它几年的陪伴，在此祝多说插件一路走好！！！]]></content>
      <tags>
        <tag>多说</tag>
        <tag>hexo</tag>
        <tag>评论系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 虚拟机 类加载器总结]]></title>
    <url>%2F2017%2F03%2F18%2F9-JVM%2FJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、类的加载过程JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize) 链接又分为三个步骤，如 下图所示： 装载：查找并加载类的二进制数据； 链接： 验证：确保被加载类的正确性； 准备：为类的静态变量分配内存，并将其初始化为默认值； 解析：把类中的符号引用转换为直接引用； 初始化：为类的静态变量赋予正确的初始值； 那为什么我要有验证这一步骤呢？首先如果由编译器生成的class文件，它肯定是符合JVM字节码格式的，但是万一有高手自己写一个class文件，让JVM加载并运行，用于恶意用途，就不妙了，因此这个class文件要先过验证这一关，不符合的话不会让它继续执行的，也是为了安全考虑吧。 准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 2. 类的初始化类什么时候才被初始化： 创建类的实例，也就是new一个对象 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（Class.forName(“com.lyj.load”)） 初始化一个类的子类（会首先初始化子类的父类） JVM启动时标明的启动类，即文件名和类名相同的那个类 只有这6中情况才会导致类的类的初始化。 类的初始化步骤： 如果这个类还没有被加载和链接，那先进行加载和链接 假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 3、类的加载类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。 类的加载的最终产品是位于堆区中的Class对象 Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 加载类的方式有以下几种： 从本地系统直接加载 通过网络下载.class文件 从zip，jar等归档文件中加载.class文件 从专有数据库中提取.class文件 将Java源文件动态编译为.class文件（服务器） 4、加载器JVM的类加载是通过ClassLoader及其子类来完成的，类的层次关系和加载顺序可以由下图来描述： 1、Bootstrap ClassLoader负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类 2、Extension ClassLoader负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包 3、App ClassLoader负责记载classpath中指定的jar包及目录中class 4、Custom ClassLoader属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader 加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 复合模式]]></title>
    <url>%2F2016%2F05%2F20%2F10-Design-Pattern%2F14-Compound%2F</url>
    <content type="text"><![CDATA[复合模式 Compound Pattern在形式上，复合模式确实是多个模式的组合，但满足了这一条并不一定是复合模式，注意它的定义：将多个模式结合起来形成一个“框架”，以解决一般性问题，一提到“框架”，可能最容易联想到的就是MVC吧，不过MVC确实是一个经典的复合模式。 MVC与复合模式Model，View，Controller各自的职责： 这里不得不强调一下控制逻辑与应用逻辑（算法逻辑）的区别：所谓控制逻辑，就是判断在当前情景下应该调用什么对象的什么方法而应用逻辑指的是具体对象的具体方法的内部实现（某个复杂的算法，或者一系列的具体处理）（非要细说的话，View里面其实也包含了一点控制逻辑（根据用户动作判断应该调用哪一个Controller），当然，一般情况我们都把这点逻辑忽略不计的） MVC的最大优点就是把表现层View与模型Model分离，实现了设计上的松耦合（应对变化）以及代码的复用（View可以随便换，只需要改改新View里面那一丁点儿控制逻辑就好了） 前面说过了MVC是一种复合模式，那它到底复合了哪些模式，一起看看： 观察者模式： 模型实现观察者模式，当 Model 的状态改变时，相关对象将持续更。使用观察者模式可以让模型完全独立于视图和控制器，同一个模型可以使用不同的视图，甚至可以同时使用多个视图。 V和C都是M的观察者（Model的状态更新要及时通知V更新视图，或者通知C做相应逻辑处理） 策略模式： 控制器和视图实现策略模式，控制器是视图的行为，视图根据用户的行为不同 委托 不同的控制器处理用户请求，所以说Controller是View的“策略”，所以View包含的控制逻辑就是“选择策略”，也就是选择控制器Controller。 使用策略模式可让视图和模型解耦，因为控制器负责和模型交换来传递用户的请求信息，对于工作是怎么完成的，视图是可以完全不知情的。 组合模式： View的自身实现应用了组合模式（调用顶层容器的repaint方法，容器内的所有组件都会重绘） 手机显示框内，或者 web 界面，每个显示组件如果不是组合节点（窗口），就是叶节点（按钮），当控制器告诉视图更新时，只需告诉视图最顶层的组件，组合模式会处理其余的事。 MVC应用了多个模式，并能够较好的解决设计上的一般性问题，所以被称为复合模式]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Compound</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 代理模式]]></title>
    <url>%2F2016%2F05%2F18%2F10-Design-Pattern%2F13-Proxy%2F</url>
    <content type="text"><![CDATA[代理模式 Proxy Pattern为另一个对象提供替身或者占位符以控制这个对象的访问。 通常代理类内含有一个被代理类的引用。 类图 代理分类远程代理通过 RMI 和 JNDI 进行远程方法调用，在不同 JVM 中进行交互。 虚拟代理通常利用代理对象来创建和销毁占用较多资源的被代理对象。用来延迟大资源对象的创建。 动态代理 Dynamic Proxy java.lang.reflect.ProxyProxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类 InvocationHandler是代理实例的调用处理程序实现的接口，每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。 动态Proxy是这样的一种类:它是在运行生成的类，在生成时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你可以把该class的实例当作这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 在使用动态代理类时，我们必须实现InvocationHandler接口步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1、定义抽象角色 [共同的接口] :动态代理的使用，体会反射是动态语言的关键interface Subject &#123; void action();&#125;//2、定义真实角色 :被代理类 class RealSubject implements Subject &#123; public void action() &#123; System.out.println( "我是被代理类，记得要执行我！" ); &#125;&#125;//3、定义代理角色 :定义代理类class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 作用：①给被代理的对象实例化②返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; //当通过代理类的对象发起对被重写的方法的调用时，都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method方法的返回值时returnVal Object returnVal = method.invoke(obj, args); return returnVal; &#125;&#125;//测试类public class TestProxy &#123; public static void main(String[] args) &#123; //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvacationHandler接口的代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(real); Subject sub = (Subject)obj; //此时sub就是代理类的对象 sub.action(); //转到对InvacationHandler接口的实现类的invoke()方法的调用 &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 状态模式]]></title>
    <url>%2F2016%2F05%2F16%2F10-Design-Pattern%2F12-State%2F</url>
    <content type="text"><![CDATA[状态模式 State Pattern定义状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 可以将状态封装成一个独立的类 类图]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>State</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 组合模式]]></title>
    <url>%2F2016%2F05%2F14%2F10-Design-Pattern%2F11-Composite%2F</url>
    <content type="text"><![CDATA[组合模式 Composite Pattern定义组合模式允许你将对象组合成树形结构来表现 “整体/部分” 层次结构。组合能让客户以一致方式处理个别对象以及对象组合。 类图 例图 代码123456789101112131415161718192021222324252627282930313233import java.util.*;public abstract class MenuComponent &#123; public void add(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; public void remove(MenuComponent menuComponent) &#123; throw new UnsupportedOperationException(); &#125; public MenuComponent getChild(int i) &#123; throw new UnsupportedOperationException(); &#125; public String getName() &#123; throw new UnsupportedOperationException(); &#125; public String getDescription() &#123; throw new UnsupportedOperationException(); &#125; public double getPrice() &#123; throw new UnsupportedOperationException(); &#125; public boolean isVegetarian() &#123; throw new UnsupportedOperationException(); &#125; public abstract Iterator createIterator(); public void print() &#123; throw new UnsupportedOperationException(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.ArrayList;public class Menu extends MenuComponent &#123; ArrayList menuComponents = new ArrayList(); String name; String description; public Menu(String name, String description) &#123; this.name = name; this.description = description; &#125; public void add(MenuComponent menuComponent) &#123; menuComponents.add(menuComponent); &#125; public void remove(MenuComponent menuComponent) &#123; menuComponents.remove(menuComponent); &#125; public MenuComponent getChild(int i) &#123; return (MenuComponent)menuComponents.get(i); &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public Iterator createIterator() &#123; return new CompositeIterator(menuComponents.iterator()); &#125; public void print() &#123; System.out.print("\n" + getName()); System.out.println(", " + getDescription()); System.out.println("---------------------"); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext()) &#123; MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.util.Iterator;import java.util.ArrayList;public class MenuItem extends MenuComponent &#123; String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) &#123; this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; &#125; public String getName() &#123; return name; &#125; public String getDescription() &#123; return description; &#125; public double getPrice() &#123; return price; &#125; public boolean isVegetarian() &#123; return vegetarian; &#125; // 空 Iterator public Iterator createIterator() &#123; return new NullIterator(); &#125; public void print() &#123; System.out.print(" " + getName()); if (isVegetarian()) &#123; System.out.print("(v)"); &#125; System.out.println(", " + getPrice()); System.out.println(" -- " + getDescription()); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142import java.util.*; public class CompositeIterator implements Iterator &#123; // Stack继承于Vector，意味着Vector拥有的属性和功能 Stack stack = new Stack(); public CompositeIterator(Iterator iterator) &#123; stack.push(iterator); &#125; public Object next() &#123; if (hasNext()) &#123; /* peek()取出栈顶元素，不执行删除 */ Iterator iterator = (Iterator) stack.peek(); MenuComponent component = (MenuComponent) iterator.next(); if (component instanceof Menu) &#123; stack.push(component.createIterator()); &#125; return component; &#125; else &#123; return null; &#125; &#125; public boolean hasNext() &#123; if (stack.empty()) &#123; return false; &#125; else &#123; Iterator iterator = (Iterator) stack.peek(); if (!iterator.hasNext()) &#123; /* pop() 取出栈顶元素，且执行删除 */ stack.pop(); return hasNext(); &#125; else &#123; return true; &#125; &#125; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 12345678910111213141516171819202122232425262728import java.util.Iterator; public class Waitress &#123; MenuComponent allMenus; public Waitress(MenuComponent allMenus) &#123; this.allMenus = allMenus; &#125; public void printMenu() &#123; allMenus.print(); &#125; public void printVegetarianMenu() &#123; Iterator iterator = allMenus.createIterator(); System.out.println("\nVEGETARIAN MENU\n----"); while (iterator.hasNext()) &#123; MenuComponent menuComponent = (MenuComponent)iterator.next(); try &#123; if (menuComponent.isVegetarian()) &#123; menuComponent.print(); &#125; &#125; catch (UnsupportedOperationException e) &#123;&#125; &#125; &#125;&#125; 12345678910111213141516import java.util.Iterator; public class NullIterator implements Iterator &#123; public Object next() &#123; return null; &#125; public boolean hasNext() &#123; return false; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113import java.util.*;public class MenuTestDrive &#123; public static void main(String args[]) &#123; MenuComponent pancakeHouseMenu = new Menu("PANCAKE HOUSE MENU", "Breakfast"); MenuComponent dinerMenu = new Menu("DINER MENU", "Lunch"); MenuComponent cafeMenu = new Menu("CAFE MENU", "Dinner"); MenuComponent dessertMenu = new Menu("DESSERT MENU", "Dessert of course!"); MenuComponent allMenus = new Menu("ALL MENUS", "All menus combined"); allMenus.add(pancakeHouseMenu); allMenus.add(dinerMenu); allMenus.add(cafeMenu); pancakeHouseMenu.add(new MenuItem( "K&amp;B's Pancake Breakfast", "Pancakes with scrambled eggs, and toast", true, 2.99)); pancakeHouseMenu.add(new MenuItem( "Regular Pancake Breakfast", "Pancakes with fried eggs, sausage", false, 2.99)); pancakeHouseMenu.add(new MenuItem( "Blueberry Pancakes", "Pancakes made with fresh blueberries, and blueberry syrup", true, 3.49)); pancakeHouseMenu.add(new MenuItem( "Waffles", "Waffles, with your choice of blueberries or strawberries", true, 3.59)); dinerMenu.add(new MenuItem( "Vegetarian BLT", "(Fakin') Bacon with lettuce &amp; tomato on whole wheat", true, 2.99)); dinerMenu.add(new MenuItem( "BLT", "Bacon with lettuce &amp; tomato on whole wheat", false, 2.99)); dinerMenu.add(new MenuItem( "Soup of the day", "A bowl of the soup of the day, with a side of potato salad", false, 3.29)); dinerMenu.add(new MenuItem( "Hotdog", "A hot dog, with saurkraut, relish, onions, topped with cheese", false, 3.05)); dinerMenu.add(new MenuItem( "Steamed Veggies and Brown Rice", "A medly of steamed vegetables over brown rice", true, 3.99)); dinerMenu.add(new MenuItem( "Pasta", "Spaghetti with Marinara Sauce, and a slice of sourdough bread", true, 3.89)); dinerMenu.add(dessertMenu); dessertMenu.add(new MenuItem( "Apple Pie", "Apple pie with a flakey crust, topped with vanilla icecream", true, 1.59)); dessertMenu.add(new MenuItem( "Cheesecake", "Creamy New York cheesecake, with a chocolate graham crust", true, 1.99)); dessertMenu.add(new MenuItem( "Sorbet", "A scoop of raspberry and a scoop of lime", true, 1.89)); cafeMenu.add(new MenuItem( "Veggie Burger and Air Fries", "Veggie burger on a whole wheat bun, lettuce, tomato, and fries", true, 3.99)); cafeMenu.add(new MenuItem( "Soup of the day", "A cup of the soup of the day, with a side salad", false, 3.69)); cafeMenu.add(new MenuItem( "Burrito", "A large burrito, with whole pinto beans, salsa, guacamole", true, 4.29)); Waitress waitress = new Waitress(allMenus); waitress.printVegetarianMenu(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Composite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 迭代器模式]]></title>
    <url>%2F2016%2F05%2F12%2F10-Design-Pattern%2F10-Iteratior%2F</url>
    <content type="text"><![CDATA[迭代器模式 Iterator Pattern设计原则 九：单一责任原则，一个类应该只有一个引起变化的原因。将一个责任只委派给一个类。类的每个责任都有一个潜在的改变区域，超过一个责任意味着超过一个改变区域， 定义迭代器模式：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。 用迭代器来封装集合对象的遍历细节，使调用者能够通过统一的接口来实现对集合的遍历，迭代器也给集合对象提供了一定的保护，想要遍历集合，直接调用迭代器的方法就好了，我们不知道也不必知道集合内部的数据管理方式。 类图 例图 代码迭代器接口 123456789101112131415package IteratorPattern; /** * 定义迭代器 */public interface Iterator &#123; /** * @return 集合内是否存在下一个元素 */ public abstract boolean hasNext(); /** * @return 返回集合内的下一个元素 */ public abstract Object next();&#125; 还需要实现一些具体的迭代器来实现遍历细节：Array迭代器： 1234567891011121314151617181920212223242526272829package IteratorPattern; /** * 实现数组迭代器 */public class ArrayIterator implements Iterator&#123; MyObject[] arr; //自定义对象数组 int index = 0; //当前索引 public ArrayIterator(MyObject[] arr)&#123; this.arr = arr; &#125; @Override public boolean hasNext() &#123; if(index &lt; arr.length &amp;&amp; arr[index] != null) return true; return false; &#125; @Override public Object next() &#123; MyObject mo = arr[index]; index++; return mo; &#125;&#125; P.S.注意Array迭代器的hasNext方法的具体实现List迭代器： 123456789101112131415161718192021222324252627282930package IteratorPattern;import java.util.List; /** * 实现List迭代器 */public class ListIterator implements Iterator&#123; List&lt;MyObject&gt; list; //集合对象 int index = 0; //当前索引 public ListIterator(List&lt;MyObject&gt; list)&#123; this.list = list; &#125; @Override public boolean hasNext() &#123; if(index &lt; list.size()) return true; return false; &#125; @Override public Object next() &#123; MyObject mo = list.get(index); index++; return mo; &#125;&#125; 有了这些具体迭代器，我们只需要一个循环就可以搞定了： 123456789/** * 打印集合所有内容 * @param iter 集合的迭代器 */private static void printObjs(Iterator iter)&#123; while(iter.hasNext())&#123; System.out.println(iter.next().toString()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Iterator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 模板方法模式]]></title>
    <url>%2F2016%2F05%2F02%2F10-Design-Pattern%2F9-Template%2F</url>
    <content type="text"><![CDATA[模板方法模式 Template Method Pattern设计原则 八：好莱坞原则，别调用（打电话给）我们，我们会调用（打电话给）你 即高层组件对低层组件的调用方式。 定义模板方法模式在一个方法中定义一个算法的骨架，而将一些步奏延迟到子类中去。模板方法模式使得子类可在不改变算法结构的前提下，重新定义算法中的某些步奏。 类图 例图 实现代码此处的 hook() 方法，钩子方法是一种被声明在抽象类中的方法，但只有默认的实现或者空的。钩子的存在，让子类有能力对算法的不同点进行挂钩，是否挂钩由子类自行决定。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Template Method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 外观模式]]></title>
    <url>%2F2016%2F04%2F12%2F10-Design-Pattern%2F8-Facade%2F</url>
    <content type="text"><![CDATA[外观模式 Facade Pattern设计原则 七：最少知识原则，只和密友交谈。 维护此原则的方针，就任何对象而言，在该对象的方法内，我们只调用属于以下范围的方法： 该对象本身 被当做方法的参数而传进来的对象 此方法所创建和实例化的对象 对象的任何组件 将朋友圈子保持最小。以上告诉我们，如果某对象是调用其他方法的返回结果，不要调用该对象的方法。 定义外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 类图]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Facade</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 适配器模式]]></title>
    <url>%2F2016%2F04%2F08%2F10-Design-Pattern%2F7-Adapter%2F</url>
    <content type="text"><![CDATA[适配器模式 Adapter Pattern定义适配器模式将一个类的接口转换为客户期望的另一个接口。适配器让原本接口不兼容的类合作无间。 Java 适配器模式的应用，将枚举Enumeration 适配到迭代器 Iterator 类图由类图可以看到，适配器实现目标接口，并且组合一个被适配者， 实例代码1234public interface Duck &#123; public void quack(); public void fly();&#125; 1234public interface Turkey &#123; public void gobble(); public void fly();&#125; 123456789public class MallardDuck implements Duck &#123; public void quack() &#123; System.out.println("Quack"); &#125; public void fly() &#123; System.out.println("I'm flying"); &#125;&#125; 1234567891011121314151617public class TurkeyAdapter implements Duck &#123; Turkey turkey; public TurkeyAdapter(Turkey turkey) &#123; this.turkey = turkey; &#125; public void quack() &#123; turkey.gobble(); &#125; public void fly() &#123; for(int i=0; i &lt; 5; i++) &#123; turkey.fly(); &#125; &#125;&#125; 12345678910111213141516171819202122232425package headfirst.adapter.ducks;public class DuckTestDrive &#123; public static void main(String[] args) &#123; MallardDuck duck = new MallardDuck(); WildTurkey turkey = new WildTurkey(); Duck turkeyAdapter = new TurkeyAdapter(turkey); System.out.println("The Turkey says..."); turkey.gobble(); turkey.fly(); System.out.println("\nThe Duck says..."); testDuck(duck); System.out.println("\nThe TurkeyAdapter says..."); testDuck(turkeyAdapter); &#125; static void testDuck(Duck duck) &#123; duck.quack(); duck.fly(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 命令模式]]></title>
    <url>%2F2016%2F03%2F04%2F10-Design-Pattern%2F6-Command%2F</url>
    <content type="text"><![CDATA[命令模式 Command Pattern定义命令模式将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。 现实世界中任何一个稍微复杂的子系统都应当有一套命令，比如餐馆的运行机制：顾客A来到餐馆点一碗面（发出请求） -&gt; 柜台服务员记录下来（创建命令） -&gt; 服务员把小票扔给厨房 -&gt; 厨师C很快做好了一碗面（请求被执行）顾客不知道将由谁来做这碗面，柜台服务员也不知道，厨师不知道是谁点了这碗面，只知道做完面就可以休息了 是不是与命令模式很相像？ 不妨用代码来实现上面的机制 首先，我们需要一个命令接口，毕竟命令才是命令模式的核心，没有命令，一切都是空想 12345678package CommandPattern; /** * 定义Command接口 */public interface Command &#123; public abstract void execute(); //只需要定义一个统一的执行方法&#125; 有了命令还需要执行者，否则只有将军没有小兵，餐馆的执行者当然是厨师： 1234567891011121314package CommandPattern; /** * 定义Chef基类 */public abstract class Chef &#123; //在此定义厨师的公共属性 /** * 定义烹饪方法 */ public abstract void cook(); //在此定义其它有用的方法&#125; 我们还需要实现具体的厨师，术业有专攻：做面的厨师： 123456789101112package CommandPattern; /** * 定义专业做面的厨师 */public class NoodlesChef extends Chef&#123; @Override public void cook() &#123; System.out.println(&quot;做好了一碗美味的拉面&quot;); &#125;&#125; 做饼的厨师： 123456789101112package CommandPattern; /** * 定义专业做饼的厨师 */public class PieChef extends Chef&#123; @Override public void cook() &#123; System.out.println(&quot;做好了一块香喷喷的大饼&quot;); &#125;&#125; 有了小兵，有了将军，我们还需要一套完整的命令： 123456789101112131415161718package CommandPattern; /** * 实现具体NoodlesCommand */public class NoodlesCommand implements Command&#123; private NoodlesChef chef;//专业做面的厨师 public NoodlesCommand()&#123; chef = new NoodlesChef(); &#125; @Override public void execute() &#123; chef.cook(); //调用其它需要的方法 &#125;&#125; 123456789101112131415161718package CommandPattern; /** * 实现具体PieCommand */public class PieCommand implements Command&#123; private PieChef chef;//专业做饼的厨师 public PieCommand()&#123; chef = new PieChef(); &#125; @Override public void execute() &#123; chef.cook(); //调用其它需要的方法 &#125;&#125; 准备工作做好了，餐馆可以开张了三.效果示例需要一个Test类： 1234567891011121314151617181920212223242526272829package CommandPattern; /** * 实现测试类 */public class Test &#123; public static void main(String[] args) &#123; System.out.println(&quot;Command Pattern餐馆开张。。&quot;); System.out.println(&quot;第一位客户X先生&quot;); System.out.println(&quot;X先生：你好，我需要一碗面，我饿极了&quot;); NoodlesCommand nCmd = new NoodlesCommand(); System.out.println(&quot;柜台服务员：好的，我已经记下了，马上就好&quot;); System.out.println(&quot;柜台服务员：厨房~~,接单&quot;); nCmd.execute(); System.out.println(&quot;X先生：真快啊！&quot;); System.out.println(); System.out.println(&quot;第二位客户XX先生&quot;); System.out.println(&quot;XX先生：你好，我需要一块饼，20分钟后来取&quot;); PieCommand pCmd = new PieCommand(); System.out.println(&quot;柜台服务员：好的，我已经记下了&quot;); System.out.println(&quot;15分钟后&quot;); System.out.println(&quot;柜台服务员：厨房~~,接单&quot;); pCmd.execute(); System.out.println(&quot;XX先生：真准时啊！&quot;); &#125;&#125; 结果示例：]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 单例模式]]></title>
    <url>%2F2016%2F02%2F12%2F10-Design-Pattern%2F5-Singleton%2F</url>
    <content type="text"><![CDATA[单例模式 Singleton Pattern 私有化 构造器 私有化 静态变量 公有化 对象获取函数返回一个实例 定义单例模式确保一个类只有一个实例，并提供一个全局访问点。 懒汉单例模式12345678910111213141516171819202122232425262728293031323334/** * 最经典的懒汉单件模式 */public class Singleton &#123; private volatile static Singleton instance;//定义静态实例变量 /** * 定义私有构造方法，防止从外部new实例 */ private Singleton()&#123; //初始化操作 &#125; /** * 提供全局访问点 * 双重检查加锁 * @return 该类的实例 */ public static Singleton getInstance()&#123; if(instance == null)&#123; synchronized (Singleton.class)&#123; if(instance == null) instance = new Singleton(); &#125; &#125; return instance; &#125; /** * 其它有用的属性和行为 * 毕竟应用了单件模式的类仍然具有原本的功能 */&#125; 123456789volatile ：原子性。它作用是解决是因为//1：分配对象的内存空间//2：初始化对象//3：设置instance指向刚分配的内存地址2 初始化对象 与 3 设置 instance 指向分配的内存地址可能会发生顺序交换，导致问题volatile关键字会告诉编译器，不要对该对象进行编译优化 饿汗单例模式123456789101112131415161718192021222324252627/** * 饿汉单件模式 */public class Singleton &#123; private static Singleton instance = new Singleton();//定义静态实例变量 /** * 定义私有构造方法，防止从外部new实例 */ private Singleton()&#123; //初始化操作 &#125; /** * 提供全局访问点 * @return 该类的实例 */ public static Singleton getInstance()&#123; return instance; &#125; /** * 其它有用的属性和行为 * 毕竟应用了单件模式的类仍然具有原本的功能 */&#125; 多个class loader环境下的单件模式如果存在多个类加载器，多个类加载器可能同时加载我们的单件类，从而产生多个实例对于这种情况，我们可以显式指定使用哪一个class loader来加载单件类，这样就有效避免了上述问题]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Singleton</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 工厂方法模式]]></title>
    <url>%2F2016%2F01%2F15%2F10-Design-Pattern%2F4-Factory%2F</url>
    <content type="text"><![CDATA[工厂模式 Factory Pattern设计原则 六：依赖倒置原则 (Dependency Inversion Principe) 要依赖抽象，不要依赖具体类。不要让高层组件依赖低层组件，要让“二者”依赖抽象。 变量不可以持有具体类的引用（如果使用 new 就会有具体类的引用，可以使用工厂模式帮助我们避开此问题） 不要让类派生自具体类（可以派生自接口或抽象类） 不要实现基类中已经实现的方法。（若覆盖基类已实现的方法，那此基类就不是真正适合被继承的抽象。基类中已实现的方法应该由所有子类共享。） 简单工厂模式 Simple Factory Pattern 也就是常用的在Factory类中定义静态方法负责new对象的方式。 严格地说，这种被称为“简单工厂模式”的方式根本不能称之为“模式”，虽然静态工厂方法并不是真正的“设计模式”，但这种方式的应用也很广泛，也能带来一些好处，所以我们不能因为它不是“设计模式”就抛弃它。 工厂模式 Factory Pattern定义了一个创建对象的接口，但由子类来决定要实例化的类是哪一个。工厂方法让类把实例化推迟到了子类。 类图 例图 抽象工厂模式 Abstract Factory Pattern提供一个接口，用创建相关或依赖对象的家族，而不需要明确指定具体类。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Factory</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 装饰者模式]]></title>
    <url>%2F2016%2F01%2F15%2F10-Design-Pattern%2F3-Decorator%2F</url>
    <content type="text"><![CDATA[装饰者模式 Decorator Pattern设计原则 五：开放-关闭原则，类应该对拓展开放，对修改关闭。 定义装饰者模式装饰者模式：动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 Java 装饰者者模式的应用，Java I/O 流的 装饰者和被装饰对象有相同的超类型。 你可以用一个或多个装饰者包装一个对象。 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合， 可以用装饰过的对象代替它。 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。（重要） 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰 对象。 类图 例图 装饰者类解析 1234567891011package headfirst.decorator.starbuzz;public abstract class Beverage &#123; String description = "Unknown Beverage"; public String getDescription() &#123; return description; &#125; public abstract double cost();&#125; 12345package headfirst.decorator.starbuzz;public abstract class CondimentDecorator extends Beverage &#123; public abstract String getDescription();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package headfirst.decorator.starbuzz;public class DarkRoast extends Beverage &#123; public DarkRoast() &#123; description = "Dark Roast Coffee"; &#125; public double cost() &#123; return .99; &#125;&#125;package headfirst.decorator.starbuzz;public class Decaf extends Beverage &#123; public Decaf() &#123; description = "Decaf Coffee"; &#125; public double cost() &#123; return 1.05; &#125;&#125;package headfirst.decorator.starbuzz;public class Espresso extends Beverage &#123; public Espresso() &#123; description = "Espresso"; &#125; public double cost() &#123; return 1.99; &#125;&#125;package headfirst.decorator.starbuzz;public class HouseBlend extends Beverage &#123; public HouseBlend() &#123; description = "House Blend Coffee"; &#125; public double cost() &#123; return .89; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package headfirst.decorator.starbuzz;public class Milk extends CondimentDecorator &#123; Beverage beverage; public Milk(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + ", Milk"; &#125; public double cost() &#123; return .10 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz;public class Mocha extends CondimentDecorator &#123; Beverage beverage; public Mocha(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + ", Mocha"; &#125; public double cost() &#123; return .20 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz;public class Soy extends CondimentDecorator &#123; Beverage beverage; public Soy(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + ", Soy"; &#125; public double cost() &#123; return .15 + beverage.cost(); &#125;&#125;package headfirst.decorator.starbuzz; public class Whip extends CondimentDecorator &#123; Beverage beverage; public Whip(Beverage beverage) &#123; this.beverage = beverage; &#125; public String getDescription() &#123; return beverage.getDescription() + ", Whip"; &#125; public double cost() &#123; return .10 + beverage.cost(); &#125;&#125; 123456789101112131415161718192021222324package headfirst.decorator.starbuzz;public class StarbuzzCoffee &#123; public static void main(String args[]) &#123; Beverage beverage = new Espresso(); System.out.println(beverage.getDescription() + " $" + beverage.cost()); Beverage beverage2 = new DarkRoast(); beverage2 = new Mocha(beverage2); beverage2 = new Mocha(beverage2); beverage2 = new Whip(beverage2); System.out.println(beverage2.getDescription() + " $" + beverage2.cost()); Beverage beverage3 = new HouseBlend(); beverage3 = new Soy(beverage3); beverage3 = new Mocha(beverage3); beverage3 = new Whip(beverage3); System.out.println(beverage3.getDescription() + " $" + beverage3.cost()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Decorator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 观察者模式]]></title>
    <url>%2F2016%2F01%2F10%2F10-Design-Pattern%2F2-Observer%2F</url>
    <content type="text"><![CDATA[观察者模式 Observer Pattern出版者＋订阅者 = 观察者模式 出版者（主题：subject）订阅者（观察者：observer） 设计原则 四：为了交互对象之间的松耦合设计而努力。 定义观察者模式观察者模式定义了对象之间的一对多依赖，这样一来，当对象改变状态时，它的所有依赖者都会收到通知并自动更新。 Java有多种观察者模式的实现，包括了通用的java.util. Observable。 类图 123456789101112131415package headfirst.observer.weather;public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125;public interface Observer &#123; public void update(float temp, float humidity, float pressure);&#125;public interface DisplayElement &#123; public void display();&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package headfirst.observer.weather;import java.util.*;public class WeatherData implements Subject &#123; private ArrayList observers; private float temperature; private float humidity; private float pressure; public WeatherData() &#123; observers = new ArrayList(); &#125; public void registerObserver(Observer o) &#123; observers.add(o); &#125; public void removeObserver(Observer o) &#123; int i = observers.indexOf(o); if (i &gt;= 0) &#123; observers.remove(i); &#125; &#125; public void notifyObservers() &#123; for (int i = 0; i &lt; observers.size(); i++) &#123; Observer observer = (Observer)observers.get(i); observer.update(temperature, humidity, pressure); &#125; &#125; public void measurementsChanged() &#123; notifyObservers(); &#125; public void setMeasurements(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; measurementsChanged(); &#125; // other WeatherData methods here public float getTemperature() &#123; return temperature; &#125; public float getHumidity() &#123; return humidity; &#125; public float getPressure() &#123; return pressure; &#125;&#125; 1234567891011121314151617181920212223package headfirst.observer.weather; public class CurrentConditionsDisplay implements Observer, DisplayElement &#123; private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temperature, float humidity, float pressure) &#123; this.temperature = temperature; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println(&quot;Current conditions: &quot; + temperature + &quot;F degrees and &quot; + humidity + &quot;% humidity&quot;); &#125;&#125; 1234567891011121314151617181920212223242526272829303132package headfirst.observer.weather;import java.util.*;public class ForecastDisplay implements Observer, DisplayElement &#123; private float currentPressure = 29.92f; private float lastPressure; private WeatherData weatherData; public ForecastDisplay(WeatherData weatherData) &#123; this.weatherData = weatherData; weatherData.registerObserver(this); &#125; public void update(float temp, float humidity, float pressure) &#123; lastPressure = currentPressure; currentPressure = pressure; display(); &#125; public void display() &#123; System.out.print(&quot;Forecast: &quot;); if (currentPressure &gt; lastPressure) &#123; System.out.println(&quot;Improving weather on the way!&quot;); &#125; else if (currentPressure == lastPressure) &#123; System.out.println(&quot;More of the same&quot;); &#125; else if (currentPressure &lt; lastPressure) &#123; System.out.println(&quot;Watch out for cooler, rainy weather&quot;); &#125; &#125;&#125; 测试 12345678910111213141516171819package headfirst.observer.weather;import java.util.*;public class WeatherStation &#123; public static void main(String[] args) &#123; WeatherData weatherData = new WeatherData(); CurrentConditionsDisplay currentDisplay = new CurrentConditionsDisplay(weatherData); StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData); ForecastDisplay forecastDisplay = new ForecastDisplay(weatherData); weatherData.setMeasurements(80, 65, 30.4f); weatherData.setMeasurements(82, 70, 29.2f); weatherData.setMeasurements(78, 90, 29.2f); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Observer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之 策略模式]]></title>
    <url>%2F2016%2F01%2F08%2F10-Design-Pattern%2F1-Strategy%2F</url>
    <content type="text"><![CDATA[策略模式 Strategy Pattern设计原则 一：找出应用中可能需要变化之处， 把它们独立出来， 不要和那些不需要变化的代码混在一起。 设计原则 二：针对接口编程，而不是针对实现编程。 针对接口编程真正的意思是针对超类型（supertype） 编程。利用多态， 程序可以针对超类型编程， 执行时会根据实际状况执行到真正的行为， 不会被绑死在超类型的行为上。 超类型： 通常是一个抽象类或者是一个接口 设计原则 三：（当我们需要扩展类的行为时）多用组合，少用继承。 使用组合建立系统具有很大的弹性， 不仅可将算法族封装成类，更可以在运行时动态地改变行为， 只要组合的行为对象， 符合正确的接口标准即可。 策略模式定义：策略模式定义了算法族， 分别封装起来， 让它们之间可以互相替换， 此模式让算法的变化独立于使用算法的客户。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Design Pattern</tag>
        <tag>Strategy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 TreeSet]]></title>
    <url>%2F2015%2F10%2F18%2F8-Collection-Map%2F17-TreeSet%2F</url>
    <content type="text"><![CDATA[TreeSet简介TreeSet 是一个有序的集合，它的作用是提供有序的Set集合。它继承于AbstractSet抽象类，实现了NavigableSet, Cloneable, java.io.Serializable接口。TreeSet 继承于AbstractSet，所以它是一个Set集合，具有Set的属性和方法。TreeSet 实现了NavigableSet接口，意味着它支持一系列的导航方法。比如查找与指定目标最匹配项。TreeSet 实现了Cloneable接口，意味着它能被克隆。TreeSet 实现了java.io.Serializable接口，意味着它支持序列化。 TreeSet是基于TreeMap实现的。TreeSet中的元素支持2种排序方式：自然排序 或者 根据创建TreeSet 时提供的 Comparator 进行排序。这取决于使用的构造方法。TreeSet为基本操作（add、remove 和 contains）提供受保证的 log(n) 时间开销。另外，TreeSet是非同步的。 它的iterator 方法返回的迭代器是fail-fast的。 TreeSet的构造函数1234567891011// 默认构造函数。使用该构造函数，TreeSet中的元素按照自然排序进行排列。TreeSet()// 创建的TreeSet包含collectionTreeSet(Collection&lt;? extends E&gt; collection)// 指定TreeSet的比较器TreeSet(Comparator&lt;? super E&gt; comparator)// 创建的TreeSet包含setTreeSet(SortedSet&lt;E&gt; set) TreeSet的API1234567891011121314151617181920212223242526boolean add(E object)boolean addAll(Collection&lt;? extends E&gt; collection)void clear()Object clone()boolean contains(Object object)E first()boolean isEmpty()E last()E pollFirst()E pollLast()E lower(E e)E floor(E e)E ceiling(E e)E higher(E e)boolean remove(Object object)int size()Comparator&lt;? super E&gt; comparator()Iterator&lt;E&gt; iterator()Iterator&lt;E&gt; descendingIterator()SortedSet&lt;E&gt; headSet(E end)NavigableSet&lt;E&gt; descendingSet()NavigableSet&lt;E&gt; headSet(E end, boolean endInclusive)SortedSet&lt;E&gt; subSet(E start, E end)NavigableSet&lt;E&gt; subSet(E start, boolean startInclusive, E end, boolean endInclusive)NavigableSet&lt;E&gt; tailSet(E start, boolean startInclusive)SortedSet&lt;E&gt; tailSet(E start) 说明： TreeSet是有序的Set集合，因此支持add、remove、get等方法。 和NavigableSet一样，TreeSet的导航方法大致可以区分为两类，一类时提供元素项的导航方法，返回某个元素；另一类时提供集合的导航方法，返回某个集合。 lower、floor、higher和 ceiling 分别返回小于、小于等于、大于等于、大于给定元素的元素，如果不存在这样的元素，则返回 null。 TreeSet数据结构TreeSet的继承关系 1234567java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.TreeSet&lt;E&gt;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123;&#125; TreeSet与Collection关系图： 从图中可以看出： TreeSet继承于AbstractSet，并且实现了NavigableSet接口。 TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是通过TreeMap实现的。TreeSet中含有一个”NavigableMap类型的成员变量”m，而m实际上是”TreeMap的实例”。 TreeSet源码解析(基于JDK1.6.0_45)为了更了解TreeSet的原理，下面对TreeSet源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239package java.util;public class TreeSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt;, Cloneable, java.io.Serializable&#123; // NavigableMap对象 private transient NavigableMap&lt;E,Object&gt; m; // TreeSet是通过TreeMap实现的， // PRESENT是键-值对中的值。 private static final Object PRESENT = new Object(); // 不带参数的构造函数。创建一个空的TreeMap public TreeSet() &#123; this(new TreeMap&lt;E,Object&gt;()); &#125; // 将TreeMap赋值给 "NavigableMap对象m" TreeSet(NavigableMap&lt;E,Object&gt; m) &#123; this.m = m; &#125; // 带比较器的构造函数。 public TreeSet(Comparator&lt;? super E&gt; comparator) &#123; this(new TreeMap&lt;E,Object&gt;(comparator)); &#125; // 创建TreeSet，并将集合c中的全部元素都添加到TreeSet中 public TreeSet(Collection&lt;? extends E&gt; c) &#123; this(); // 将集合c中的元素全部添加到TreeSet中 addAll(c); &#125; // 创建TreeSet，并将s中的全部元素都添加到TreeSet中 public TreeSet(SortedSet&lt;E&gt; s) &#123; this(s.comparator()); addAll(s); &#125; // 返回TreeSet的顺序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return m.navigableKeySet().iterator(); &#125; // 返回TreeSet的逆序排列的迭代器。 // 因为TreeSet时TreeMap实现的，所以这里实际上时返回TreeMap的“键集”对应的迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return m.descendingKeySet().iterator(); &#125; // 返回TreeSet的大小 public int size() &#123; return m.size(); &#125; // 返回TreeSet是否为空 public boolean isEmpty() &#123; return m.isEmpty(); &#125; // 返回TreeSet是否包含对象(o) public boolean contains(Object o) &#123; return m.containsKey(o); &#125; // 添加e到TreeSet中 public boolean add(E e) &#123; return m.put(e, PRESENT)==null; &#125; // 删除TreeSet中的对象o public boolean remove(Object o) &#123; return m.remove(o)==PRESENT; &#125; // 清空TreeSet public void clear() &#123; m.clear(); &#125; // 将集合c中的全部元素添加到TreeSet中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // Use linear-time version if applicable if (m.size()==0 &amp;&amp; c.size() &gt; 0 &amp;&amp; c instanceof SortedSet &amp;&amp; m instanceof TreeMap) &#123; SortedSet&lt;? extends E&gt; set = (SortedSet&lt;? extends E&gt;) c; TreeMap&lt;E,Object&gt; map = (TreeMap&lt;E, Object&gt;) m; Comparator&lt;? super E&gt; cc = (Comparator&lt;? super E&gt;) set.comparator(); Comparator&lt;? super E&gt; mc = map.comparator(); if (cc==mc || (cc != null &amp;&amp; cc.equals(mc))) &#123; map.addAllForTreeSet(set, PRESENT); return true; &#125; &#125; return super.addAll(c); &#125; // 返回子Set，实际上是通过TreeMap的subMap()实现的。 public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; // 返回Set的头部，范围是：从头部到toElement。 // inclusive是是否包含toElement的标志 public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; // 返回Set的尾部，范围是：从fromElement到结尾。 // inclusive是是否包含fromElement的标志 public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; // 返回子Set。范围是：从fromElement(包括)到toElement(不包括)。 public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; // 返回Set的头部，范围是：从头部到toElement(不包括)。 public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; // 返回Set的尾部，范围是：从fromElement到结尾(不包括)。 public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; // 返回Set的比较器 public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; // 返回Set的第一个元素 public E first() &#123; return m.firstKey(); &#125; // 返回Set的最后一个元素 public E first() &#123; public E last() &#123; return m.lastKey(); &#125; // 返回Set中小于e的最大元素 public E lower(E e) &#123; return m.lowerKey(e); &#125; // 返回Set中小于/等于e的最大元素 public E floor(E e) &#123; return m.floorKey(e); &#125; // 返回Set中大于/等于e的最小元素 public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; // 返回Set中大于e的最小元素 public E higher(E e) &#123; return m.higherKey(e); &#125; // 获取第一个元素，并将该元素从TreeMap中删除。 public E pollFirst() &#123; Map.Entry&lt;E,?&gt; e = m.pollFirstEntry(); return (e == null)? null : e.getKey(); &#125; // 获取最后一个元素，并将该元素从TreeMap中删除。 public E pollLast() &#123; Map.Entry&lt;E,?&gt; e = m.pollLastEntry(); return (e == null)? null : e.getKey(); &#125; // 克隆一个TreeSet，并返回Object对象 public Object clone() &#123; TreeSet&lt;E&gt; clone = null; try &#123; clone = (TreeSet&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; clone.m = new TreeMap&lt;E,Object&gt;(m); return clone; &#125; // java.io.Serializable的写入函数 // 将TreeSet的“比较器、容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); // 写入比较器 s.writeObject(m.comparator()); // 写入容量 s.writeInt(m.size()); // 写入“TreeSet中的每一个元素” for (Iterator i=m.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeSet的“比较器、容量、所有的元素值”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden stuff s.defaultReadObject(); // 从输入流中读取TreeSet的“比较器” Comparator&lt;? super E&gt; c = (Comparator&lt;? super E&gt;) s.readObject(); TreeMap&lt;E,Object&gt; tm; if (c==null) tm = new TreeMap&lt;E,Object&gt;(); else tm = new TreeMap&lt;E,Object&gt;(c); m = tm; // 从输入流中读取TreeSet的“容量” int size = s.readInt(); // 从输入流中读取TreeSet的“全部元素” tm.readTreeSet(size, s, PRESENT); &#125; // TreeSet的序列版本号 private static final long serialVersionUID = -2479143000061671589L;&#125; 总结： TreeSet实际上是TreeMap实现的。当我们构造TreeSet时；若使用不带参数的构造函数，则TreeSet的使用自然比较器；若用户需要使用自定义的比较器，则需要使用带比较器的参数。 TreeSet是非线程安全的。 TreeSet实现java.io.Serializable的方式。当写入到输出流时，依次写入“比较器、容量、全部元素”；当读出输入流时，再依次读取。 TreeSet遍历方式Iterator顺序遍历123for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; iter.next();&#125; Iterator倒序遍历1234// 假设set是TreeSet对象for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) &#123; iter.next();&#125; for-each遍历HashSet1234// 假设set是TreeSet对象，并且set中元素是String类型String[] arr = (String[])set.toArray(new String[0]);for (String str:arr) System.out.printf("for each : %s\n", str); TreeSet不支持快速随机遍历，只能通过迭代器进行遍历！ TreeSet遍历测试程序如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.*;/** * @desc TreeSet的遍历程序 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetIteratorTest &#123; public static void main(String[] args) &#123; TreeSet set = new TreeSet(); set.add("aaa"); set.add("aaa"); set.add("bbb"); set.add("eee"); set.add("ddd"); set.add("ccc"); // 顺序遍历TreeSet ascIteratorThroughIterator(set) ; // 逆序遍历TreeSet descIteratorThroughIterator(set); // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 foreachTreeSet(set); &#125; // 顺序遍历TreeSet public static void ascIteratorThroughIterator(TreeSet set) &#123; System.out.print("\n ---- Ascend Iterator ----\n"); for(Iterator iter = set.iterator(); iter.hasNext(); ) &#123; System.out.printf("asc : %s\n", iter.next()); &#125; &#125; // 逆序遍历TreeSet public static void descIteratorThroughIterator(TreeSet set) &#123; System.out.printf("\n ---- Descend Iterator ----\n"); for(Iterator iter = set.descendingIterator(); iter.hasNext(); ) System.out.printf("desc : %s\n", (String)iter.next()); &#125; // 通过for-each遍历TreeSet。不推荐！此方法需要先将Set转换为数组 private static void foreachTreeSet(TreeSet set) &#123; System.out.printf("\n ---- For-each ----\n"); String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf("for each : %s\n", str); &#125;&#125; 运行结果： 1234567891011121314151617181920 ---- Ascend Iterator ----asc : aaaasc : bbbasc : cccasc : dddasc : eee ---- Descend Iterator ----desc : eeedesc : ddddesc : cccdesc : bbbdesc : aaa ---- For-each ----for each : aaafor each : bbbfor each : cccfor each : dddfor each : eee TreeSet示例下面通过实例学习如何使用TreeSet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586import java.util.*;/** * @desc TreeSet的API测试 * * @author skywang * @email kuiwu-wang@163.com */public class TreeSetTest &#123; public static void main(String[] args) &#123; testTreeSetAPIs(); &#125; // 测试TreeSet的api public static void testTreeSetAPIs() &#123; String val; // 新建TreeSet TreeSet tSet = new TreeSet(); // 将元素添加到TreeSet中 tSet.add("aaa"); // Set中不允许重复元素，所以只会保存一个“aaa” tSet.add("aaa"); tSet.add("bbb"); tSet.add("eee"); tSet.add("ddd"); tSet.add("ccc"); System.out.println("TreeSet:"+tSet); // 打印TreeSet的实际大小 System.out.printf("size : %d\n", tSet.size()); // 导航方法 // floor(小于、等于) System.out.printf("floor bbb: %s\n", tSet.floor("bbb")); // lower(小于) System.out.printf("lower bbb: %s\n", tSet.lower("bbb")); // ceiling(大于、等于) System.out.printf("ceiling bbb: %s\n", tSet.ceiling("bbb")); System.out.printf("ceiling eee: %s\n", tSet.ceiling("eee")); // ceiling(大于) System.out.printf("higher bbb: %s\n", tSet.higher("bbb")); // subSet() System.out.printf("subSet(aaa, true, ccc, true): %s\n", tSet.subSet("aaa", true, "ccc", true)); System.out.printf("subSet(aaa, true, ccc, false): %s\n", tSet.subSet("aaa", true, "ccc", false)); System.out.printf("subSet(aaa, false, ccc, true): %s\n", tSet.subSet("aaa", false, "ccc", true)); System.out.printf("subSet(aaa, false, ccc, false): %s\n", tSet.subSet("aaa", false, "ccc", false)); // headSet() System.out.printf("headSet(ccc, true): %s\n", tSet.headSet("ccc", true)); System.out.printf("headSet(ccc, false): %s\n", tSet.headSet("ccc", false)); // tailSet() System.out.printf("tailSet(ccc, true): %s\n", tSet.tailSet("ccc", true)); System.out.printf("tailSet(ccc, false): %s\n", tSet.tailSet("ccc", false)); // 删除“ccc” tSet.remove("ccc"); // 将Set转换为数组 String[] arr = (String[])tSet.toArray(new String[0]); for (String str:arr) System.out.printf("for each : %s\n", str); // 打印TreeSet System.out.printf("TreeSet:%s\n", tSet); // 遍历TreeSet for(Iterator iter = tSet.iterator(); iter.hasNext(); ) &#123; System.out.printf("iter : %s\n", iter.next()); &#125; // 删除并返回第一个元素 val = (String)tSet.pollFirst(); System.out.printf("pollFirst=%s, set=%s\n", val, tSet); // 删除并返回最后一个元素 val = (String)tSet.pollLast(); System.out.printf("pollLast=%s, set=%s\n", val, tSet); // 清空HashSet tSet.clear(); // 输出HashSet是否为空 System.out.printf("%s\n", tSet.isEmpty()?"set is empty":"set is not empty"); &#125;&#125; 运行结果： 123456789101112131415161718192021222324252627TreeSet:[aaa, bbb, ccc, ddd, eee]size : 5floor bbb: bbblower bbb: aaaceiling bbb: bbbceiling eee: eeehigher bbb: cccsubSet(aaa, true, ccc, true): [aaa, bbb, ccc]subSet(aaa, true, ccc, false): [aaa, bbb]subSet(aaa, false, ccc, true): [bbb, ccc]subSet(aaa, false, ccc, false): [bbb]headSet(ccc, true): [aaa, bbb, ccc]headSet(ccc, false): [aaa, bbb]tailSet(ccc, true): [ccc, ddd, eee]tailSet(ccc, false): [ddd, eee]for each : aaafor each : bbbfor each : dddfor each : eeeTreeSet:[aaa, bbb, ddd, eee]iter : aaaiter : bbbiter : ddditer : eeepollFirst=aaa, set=[bbb, ddd, eee]pollLast=eee, set=[bbb, ddd]set is empty]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Set</tag>
        <tag>TreeSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Iterator 和 Enumeration 比较]]></title>
    <url>%2F2015%2F10%2F18%2F8-Collection-Map%2F18-Iterator-and-Enumeration%2F</url>
    <content type="text"><![CDATA[Iterator和Enumeration区别在Java集合中，我们通常都通过 “Iterator(迭代器)” 或 “Enumeration(枚举类)” 去遍历集合。今天，我们就一起学习一下它们之间到底有什么区别。 我们先看看 Enumeration.java 和 Iterator.java的源码，再说它们的区别。Enumeration是一个接口，它的源码如下： 12345678package java.util;public interface Enumeration&lt;E&gt; &#123; boolean hasMoreElements(); E nextElement();&#125; Iterator也是一个接口，它的源码如下： 123456789package java.util;public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); void remove();&#125; 看完代码了，我们再来说说它们之间的区别。 函数接口不同 Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。 Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。 Iterator支持fail-fast机制，而Enumeration不支持。 Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。 而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。 Iterator和Enumeration实例下面，我们编写一个Hashtable，然后分别通过 Iterator 和 Enumeration 去遍历它，比较它们的效率。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import java.util.Enumeration;import java.util.Hashtable;import java.util.Iterator;import java.util.Map.Entry;import java.util.Random;/* * 测试分别通过 Iterator 和 Enumeration 去遍历Hashtable * @author skywang */public class IteratorEnumeration &#123; public static void main(String[] args) &#123; int val; Random r = new Random(); Hashtable table = new Hashtable(); for (int i=0; i&lt;100000; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); table.put(String.valueOf(i), val); &#125; // 通过Iterator遍历Hashtable iterateHashtable(table) ; // 通过Enumeration遍历Hashtable enumHashtable(table); &#125; /* * 通过Iterator遍历Hashtable */ private static void iterateHashtable(Hashtable table) &#123; long startTime = System.currentTimeMillis(); Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; //System.out.println("iter:"+iter.next()); iter.next(); &#125; long endTime = System.currentTimeMillis(); countTime(startTime, endTime); &#125; /* * 通过Enumeration遍历Hashtable */ private static void enumHashtable(Hashtable table) &#123; long startTime = System.currentTimeMillis(); Enumeration enu = table.elements(); while(enu.hasMoreElements()) &#123; //System.out.println("enu:"+enu.nextElement()); enu.nextElement(); &#125; long endTime = System.currentTimeMillis(); countTime(startTime, endTime); &#125; private static void countTime(long start, long end) &#123; System.out.println("time: "+(end-start)+"ms"); &#125;&#125; 运行结果如下： 12time: 9mstime: 5ms 从中，我们可以看出。Enumeration 比 Iterator 的遍历速度更快。为什么呢？这是因为，Hashtable中Iterator是通过Enumeration去实现的，而且Iterator添加了对fail-fast机制的支持；所以，执行的操作自然要多一些。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Iterator</tag>
        <tag>Enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 HashSet]]></title>
    <url>%2F2015%2F09%2F15%2F8-Collection-Map%2F16-HashSet%2F</url>
    <content type="text"><![CDATA[HashSet 简介HashSet 是一个没有重复元素的集合。 它是由HashMap实现的，不保证元素的顺序，而且HashSet允许使用 null 元素。HashSet是非同步的。如果多个线程同时访问一个哈希 set，而其中至少一个线程修改了该 set，那么它必须 保持外部同步。这通常是通过对自然封装该 set 的对象执行同步操作来完成的。如果不存在这样的对象，则应该使用 Collections.synchronizedSet 方法来“包装” set。最好在创建时完成这一操作，以防止对该 set 进行意外的不同步访问：1Set s = Collections.synchronizedSet(new HashSet(...)); HashSet通过iterator()返回的迭代器是fail-fast的。 HashSet的构造函数1234567891011121314 // 默认构造函数public HashSet() // 带集合的构造函数public HashSet(Collection&lt;? extends E&gt; c) // 指定HashSet初始容量和加载因子的构造函数public HashSet(int initialCapacity, float loadFactor) // 指定HashSet初始容量的构造函数public HashSet(int initialCapacity) // 指定HashSet初始容量和加载因子的构造函数,dummy没有任何作用HashSet(int initialCapacity, float loadFactor, boolean dummy) HashSet的主要API12345678boolean add(E object)void clear()Object clone()boolean contains(Object object)boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object object)int size() HashSet数据结构HashSet的继承关系如下：12345678java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractSet&lt;E&gt; ↳ java.util.HashSet&lt;E&gt;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable &#123; &#125; HashSet与Map关系图： 从图中可以看出： HashSet继承于AbstractSet，并且实现了Set接口。 HashSet的本质是一个”没有重复元素”的集合，它是通过HashMap实现的。HashSet中含有一个”HashMap类型的成员变量”map，HashSet的操作函数，实际上都是通过map实现的。 HashSet源码解析(基于JDK1.6.0_45)为了更了解HashSet的原理，下面对HashSet源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141package java.util;public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; // HashSet是通过map(HashMap对象)保存内容的 private transient HashMap&lt;E,Object&gt; map; // PRESENT是向map中插入key-value对应的value // 因为HashSet中只需要用到key，而HashMap是key-value键值对； // 所以，向map中添加键值对时，键值对的值固定是PRESENT private static final Object PRESENT = new Object(); // 默认构造函数 public HashSet() &#123; // 调用HashMap的默认构造函数，创建map map = new HashMap&lt;E,Object&gt;(); &#125; // 带集合的构造函数 public HashSet(Collection&lt;? extends E&gt; c) &#123; // 创建map。 // 为什么要调用Math.max((int) (c.size()/.75f) + 1, 16)，从 (c.size()/.75f) + 1 和 16 中选择一个比较大的树呢？ // 首先，说明(c.size()/.75f) + 1 // 因为从HashMap的效率(时间成本和空间成本)考虑，HashMap的加载因子是0.75。 // 当HashMap的“阈值”(阈值=HashMap总的大小*加载因子) &lt; “HashMap实际大小”时， // 就需要将HashMap的容量翻倍。 // 所以，(c.size()/.75f) + 1 计算出来的正好是总的空间大小。 // 接下来，说明为什么是 16 。 // HashMap的总的大小，必须是2的指数倍。若创建HashMap时，指定的大小不是2的指数倍； // HashMap的构造函数中也会重新计算，找出比“指定大小”大的最小的2的指数倍的数。 // 所以，这里指定为16是从性能考虑。避免重复计算。 map = new HashMap&lt;E,Object&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); // 将集合(c)中的全部元素添加到HashSet中 addAll(c); &#125; // 指定HashSet初始容量和加载因子的构造函数 public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; // 指定HashSet初始容量的构造函数 public HashSet(int initialCapacity) &#123; map = new HashMap&lt;E,Object&gt;(initialCapacity); &#125; HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor); &#125; // 返回HashSet的迭代器 public Iterator&lt;E&gt; iterator() &#123; // 实际上返回的是HashMap的“key集合的迭代器” return map.keySet().iterator(); &#125; public int size() &#123; return map.size(); &#125; public boolean isEmpty() &#123; return map.isEmpty(); &#125; public boolean contains(Object o) &#123; return map.containsKey(o); &#125; // 将元素(e)添加到HashSet中 public boolean add(E e) &#123; return map.put(e, PRESENT)==null; &#125; // 删除HashSet中的元素(o) public boolean remove(Object o) &#123; return map.remove(o)==PRESENT; &#125; public void clear() &#123; map.clear(); &#125; // 克隆一个HashSet，并返回Object对象 public Object clone() &#123; try &#123; HashSet&lt;E&gt; newSet = (HashSet&lt;E&gt;) super.clone(); newSet.map = (HashMap&lt;E, Object&gt;) map.clone(); return newSet; &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // Write out HashMap capacity and load factor s.writeInt(map.capacity()); s.writeFloat(map.loadFactor()); // Write out size s.writeInt(map.size()); // Write out all elements in the proper order. for (Iterator i=map.keySet().iterator(); i.hasNext(); ) s.writeObject(i.next()); &#125; // java.io.Serializable的读取函数 // 将HashSet的“总的容量，加载因子，实际容量，所有的元素”依次读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // Read in HashMap capacity and load factor and create backing HashMap int capacity = s.readInt(); float loadFactor = s.readFloat(); map = (((HashSet)this) instanceof LinkedHashSet ? new LinkedHashMap&lt;E,Object&gt;(capacity, loadFactor) : new HashMap&lt;E,Object&gt;(capacity, loadFactor)); // Read in size int size = s.readInt(); // Read in all elements in the proper order. for (int i=0; i&lt;size; i++) &#123; E e = (E) s.readObject(); map.put(e, PRESENT); &#125; &#125;&#125; 说明： HashSet的代码实际上非常简单，通过上面的注释应该很能够看懂。它是通过HashMap实现的，若对HashSet的理解有困难，建议先学习以下HashMap；学完HashMap之后，在学习HashSet就非常容易了。 HashSet遍历方式通过Iterator遍历HashSet第一步：根据iterator()获取HashSet的迭代器。第二步：遍历迭代器获取各个元素。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// 假设set是HashSet对象for(Iterator iterator = set.iterator(); iterator.hasNext(); ) &#123; iterator.next();&#125; ``` ## 通过for-each遍历HashSet第一步：根据toArray()获取HashSet的元素集合对应的数组。第二步：遍历数组，获取各个元素。// 假设set是HashSet对象，并且set中元素是String类型String[] arr = (String[])set.toArray(new String[0]);for (String str:arr) System.out.printf("for each : %s\n", str);HashSet的遍历测试程序如下： ```javaimport java.util.Random;import java.util.Iterator;import java.util.HashSet;/* * @desc 介绍HashSet遍历方法 * * @author skywang */public class HashSetIteratorTest &#123; public static void main(String[] args) &#123; // 新建HashSet HashSet set = new HashSet(); // 添加元素 到HashSet中 for (int i=0; i&lt;5; i++) set.add(""+i); // 通过Iterator遍历HashSet iteratorHashSet(set) ; // 通过for-each遍历HashSet foreachHashSet(set); &#125; /* * 通过Iterator遍历HashSet。推荐方式 */ private static void iteratorHashSet(HashSet set) &#123; for(Iterator iterator = set.iterator(); iterator.hasNext(); ) &#123; System.out.printf("iterator : %s\n", iterator.next()); &#125; &#125; /* * 通过for-each遍历HashSet。不推荐！此方法需要先将Set转换为数组 */ private static void foreachHashSet(HashSet set) &#123; String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf("for each : %s\n", str); &#125;&#125; 运行结果： 12345678910iterator : 3iterator : 2iterator : 1iterator : 0iterator : 4for each : 3for each : 2for each : 1for each : 0for each : 4 HashSet示例下面我们通过实例学习如何使用HashSet 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.Iterator;import java.util.HashSet;/* * @desc HashSet常用API的使用。 * * @author skywang */public class HashSetTest &#123; public static void main(String[] args) &#123; // HashSet常用API testHashSetAPIs() ; &#125; /* * HashSet除了iterator()和add()之外的其它常用API */ private static void testHashSetAPIs() &#123; // 新建HashSet HashSet set = new HashSet(); // 将元素添加到Set中 set.add("a"); set.add("b"); set.add("c"); set.add("d"); set.add("e"); // 打印HashSet的实际大小 System.out.printf("size : %d\n", set.size()); // 判断HashSet是否包含某个值 System.out.printf("HashSet contains a :%s\n", set.contains("a")); System.out.printf("HashSet contains g :%s\n", set.contains("g")); // 删除HashSet中的“e” set.remove("e"); // 将Set转换为数组 String[] arr = (String[])set.toArray(new String[0]); for (String str:arr) System.out.printf("for each : %s\n", str); // 新建一个包含b、c、f的HashSet HashSet otherset = new HashSet(); otherset.add("b"); otherset.add("c"); otherset.add("f"); // 克隆一个removeset，内容和set一模一样 HashSet removeset = (HashSet)set.clone(); // 删除“removeset中，属于otherSet的元素” removeset.removeAll(otherset); // 打印removeset System.out.printf("removeset : %s\n", removeset); // 克隆一个retainset，内容和set一模一样 HashSet retainset = (HashSet)set.clone(); // 保留“retainset中，属于otherSet的元素” retainset.retainAll(otherset); // 打印retainset System.out.printf("retainset : %s\n", retainset); // 遍历HashSet for(Iterator iterator = set.iterator(); iterator.hasNext(); ) System.out.printf("iterator : %s\n", iterator.next()); // 清空HashSet set.clear(); // 输出HashSet是否为空 System.out.printf("%s\n", set.isEmpty()?"set is empty":"set is not empty"); &#125;&#125; 运行结果： 1234567891011121314size : 5HashSet contains a :trueHashSet contains g :falsefor each : dfor each : bfor each : cfor each : aremoveset : [d, a]retainset : [b, c]iterator : diterator : biterator : citerator : aset is empty]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Set</tag>
        <tag>HashSet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Map总结]]></title>
    <url>%2F2015%2F09%2F15%2F8-Collection-Map%2F14-Map%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Map 总结学完了Map的全部内容，我们再回头看看Map的框架图。 Map概括 Map 是“键值对”映射的抽象接口。 AbstractMap 实现了Map中的绝大部分函数接口。它减少了“Map的实现类”的重复编码。 SortedMap 有序的“键值对”映射接口。 NavigableMap 是继承于SortedMap的，支持导航函数的接口。 HashMap, Hashtable, TreeMap, WeakHashMap这4个类是“键值对”映射的实现类。它们各有区别！ HashMap 是基于“拉链法”实现的散列表。一般用于单线程程序中。 Hashtable 也是基于“拉链法”实现的散列表。它一般用于多线程程序中。 WeakHashMap 也是基于“拉链法”实现的散列表，它一般也用于单线程程序中。相比HashMap，WeakHashMap中的键是“弱键”，当“弱键”被GC回收时，它对应的键值对也会被从WeakHashMap中删除；而HashMap中的键是强键。 TreeMap 是有序的散列表，它是通过红黑树实现的。它一般用于单线程中存储有序的映射。 HashMap和Hashtable异同HashMap和Hashtable的相同点 HashMap和Hashtable都是存储“键值对(key-value)”的散列表，而且都是采用拉链法实现的。 存储的思想都是：通过table数组存储，数组的每一个元素都是一个Entry；而一个Entry就是一个单向链表，Entry链表中的每一个节点就保存了key-value键值对数据。 添加key-value键值对：首先，根据key值计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据数组索引找到Entry(即，单向链表)，再遍历单向链表，将key和链表中的每一个节点的key进行对比。若key已经存在Entry链表中，则用该value值取代旧的value值；若key不存在Entry链表中，则新建一个key-value节点，并将该节点插入Entry链表的表头位置。 删除key-value键值对：删除键值对，相比于“添加键值对”来说，简单很多。首先，还是根据key计算出哈希值，再计算出数组索引(即，该key-value在table中的索引)。然后，根据索引找出Entry(即，单向链表)。若节点key-value存在与链表Entry中，则删除链表中的节点即可。 上面介绍了HashMap和Hashtable的相同点。正是由于它们都是散列表，我们关注更多的是“它们的区别，以及它们分别适合在什么情况下使用”。那接下来，我们先看看它们的区别。 HashMap和Hashtable的不同点继承和实现方式不同 HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 HashMap的定义: 123public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; ... &#125; Hashtable的定义: 123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; ... &#125; 从中，我们可以看出：1.1 HashMap和Hashtable都实现了Map、Cloneable、java.io.Serializable接口。 实现了Map接口，意味着它们都支持key-value键值对操作。支持“添加key-value键值对”、“获取key”、“获取value”、“获取map大小”、“清空map”等基本的key-value键值对操作。 实现了Cloneable接口，意味着它能被克隆。 实现了java.io.Serializable接口，意味着它们支持序列化，能通过序列化去传输。 1.2 HashMap继承于AbstractMap，而Hashtable继承于Dictionary Dictionary是一个抽象类，它直接继承于Object类，没有实现任何接口。Dictionary类是JDK 1.0的引入的。虽然Dictionary也支持“添加key-value键值对”、“获取value”、“获取大小”等基本操作，但它的API函数比Map少；而且 Dictionary一般是通过Enumeration(枚举类)去遍历，Map则是通过Iterator(迭代器)去遍历。 然而‘由于Hashtable也实现了Map接口，所以，它即支持Enumeration遍历，也支持Iterator遍历。关于这点，后面还会进一步说明。 AbstractMap是一个抽象类，它实现了Map接口的绝大部分API函数；为Map的具体实现类提供了极大的便利。它是JDK 1.2新增的类。 线程安全不同Hashtable的几乎所有函数都是同步的，即它是线程安全的，支持多线程。而HashMap的函数则是非同步的，它不是线程安全的。若要在多线程中使用HashMap，需要我们额外的进行同步处理。 对HashMap的同步处理可以使用Collections类提供的synchronizedMap静态方法，或者直接使用JDK 5.0之后提供的java.util.concurrent包里的ConcurrentHashMap类。 对null值的处理不同HashMap的key、value都可以为null。Hashtable的key、value都不可以为null。 我们先看看HashMap和Hashtable “添加key-value”的方法 HashMap的添加key-value的方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 将“key-value”添加到HashMap中public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125;// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; // recordAccess()函数什么也没有做 e.recordAccess(this); return oldValue; &#125; &#125; // 添加第1个“key为null”的元素都table中的时候，会执行到这里。 // 它的作用是将“设置table[0]的key为null，值为value”。 modCount++; addEntry(0, null, value, 0); return null;&#125; Hashtable的添加key-value的方法 123456789101112131415161718192021222324252627282930313233343536373839404142// 将“key-value”添加到Hashtable中public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; // Hashtable中不能插入key为null的元素！！！ // 否则，下面的语句会抛出异常！ int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; 根据上面的代码，我们可以看出： Hashtable的key或value，都不能为null！否则，会抛出异常NullPointerException。HashMap的key、value都可以为null。 当HashMap的key为null时，HashMap会将其固定的插入table[0]位置(即HashMap散列表的第一个位置)；而且table[0]处只会容纳一个key为null的值，当有多个key为null的值插入的时候，table[0]会保留最后插入的value。 支持的遍历种类不同HashMap只支持Iterator(迭代器)遍历。 而Hashtable支持Iterator(迭代器)和Enumeration(枚举器)两种方式遍历。 Enumeration 是JDK 1.0添加的接口，只有hasMoreElements(), nextElement() 两个API接口，不能通过Enumeration()对元素进行修改 。而Iterator 是JDK 1.2才添加的接口，支持hasNext(), next(), remove() 三个API接口。HashMap也是JDK 1.2版本才添加的，所以用Iterator取代Enumeration，HashMap只支持Iterator遍历。 Iterator迭代器的遍历顺序不同HashMap是“从前向后”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。Hashtabl是“从后往前”的遍历数组；再对数组具体某一项对应的链表，从表头开始进行遍历。 容量的初始值 和 增加方式都不一样HashMap默认的容量大小是16；增加容量时，每次将容量变为“原始容量x2”。Hashtable默认的容量大小是11；增加容量时，每次将容量变为“原始容量x2 + 1”。 HashMap 和 Hashtable 默认的“加载因子” 都是0.75。 添加key-value时的hash值算法不同HashMap 添加元素时，是使用自定义的哈希算法。Hashtable 没有自定义哈希算法，而直接采用的key的hashCode()。 HashMap 添加元素时，是使用自定义的哈希算法。 1234567891011121314151617181920212223242526272829static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;// 将“key-value”添加到HashMap中public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125; Hashtable 没有自定义哈希算法，而直接采用的key的hashCode()。 12345678910111213141516171819202122232425262728293031323334353637383940public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; HashMap和Hashtable使用的情景其实，若了解它们之间的不同之处后，可以很容易的区分根据情况进行取舍。例如：(01) 若在单线程中，我们往往会选择HashMap；而在多线程中，则会选择Hashtable。(02)，若不能插入null元素，则选择Hashtable；否则，可以选择HashMap。但这个不是绝对的标准。例如，在多线程中，我们可以自己对HashMap进行同步，也可以选择ConcurrentHashMap。当HashMap和Hashtable都不能满足自己的需求时，还可以考虑新定义一个类，继承或重新实现散列表；当然，一般情况下是不需要的了。 HashMap和WeakHashMap异同HashMap和WeakHashMap的相同点 它们都是散列表，存储的是“键值对”映射。 它们都继承于AbstractMap，并且实现Map基础。 它们的构造函数都一样。它们都包括4个构造函数，而且函数的参数都一样。 默认的容量大小是16，默认的加载因子是0.75。 它们的“键”和“值”都允许为null。 它们都是“非同步的”。 HashMap和WeakHashMap的不同点 HashMap实现了Cloneable和Serializable接口，而WeakHashMap没有。HashMap实现Cloneable，意味着它能通过clone()克隆自己。HashMap实现Serializable，意味着它支持序列化，能通过序列化去传输。 HashMap的“键”是“强引用(StrongReference)”，而WeakHashMap的键是“弱引用(WeakReference)”。WeakReference的“弱键”能实现WeakReference对“键值对”的动态回收。当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。 这个“弱键”实现的动态回收“键值对”的原理呢？其实，通过WeakReference(弱引用)和ReferenceQueue(引用队列)实现的。 首先，我们需要了解WeakHashMap中： “键”是WeakReference，即key是弱键。 ReferenceQueue是一个引用队列，它是和WeakHashMap联合使用的。当弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 WeakHashMap中的ReferenceQueue是queue。 WeakHashMap是通过数组实现的，我们假设这个数组是table。 接下来，说说“动态回收”的步骤。 新建WeakHashMap，将“键值对”添加到WeakHashMap中。将“键值对”添加到WeakHashMap中时，添加的键都是弱键。 实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到queue队列中。例如，当我们在将“弱键”key添加到WeakHashMap之后；后来将key设为null。这时，便没有外部外部对象再引用该了key。 接着，当Java虚拟机的GC回收内存时，会回收key的相关内存；同时，将key添加到queue队列中。 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的“弱键”；同步它们，就是删除table中被GC回收的“弱键”对应的键值对。例如，当我们“读取WeakHashMap中的元素或获取WeakReference的大小时”，它会先同步table和queue，目的是“删除table中被GC回收的‘弱键’对应的键值对”。删除的方法就是逐个比较“table中元素的‘键’和queue中的‘键’”，若它们相当，则删除“table中的该键值对”。 HashMap和WeakHashMap的比较测试程序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.WeakHashMap;import java.util.Date;import java.lang.ref.WeakReference;/** * @desc HashMap 和 WeakHashMap比较程序 * @author skywang * @email kuiwu-wang@163.com */public class CompareHashmapAndWeakhashmap &#123; public static void main(String[] args) throws Exception &#123; // 当“弱键”是String时，比较HashMap和WeakHashMap compareWithString(); // 当“弱键”是自定义类型时，比较HashMap和WeakHashMap compareWithSelfClass(); &#125; /** * 遍历map，并打印map的大小 */ private static void iteratorAndCountMap(Map map) &#123; // 遍历map for (Iterator iter = map.entrySet().iterator(); iter.hasNext(); ) &#123; Map.Entry en = (Map.Entry)iter.next(); System.out.printf("map entry : %s - %s\n ",en.getKey(), en.getValue()); &#125; // 打印HashMap的实际大小 System.out.printf(" map size:%s\n\n", map.size()); &#125; /** * 通过String对象测试HashMap和WeakHashMap */ private static void compareWithString() &#123; // 新建4个String字符串 String w1 = new String("W1"); String w2 = new String("W2"); String h1 = new String("H1"); String h2 = new String("H2"); // 新建 WeakHashMap对象，并将w1,w2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(w1, "w1"); wmap.put(w2, "w2"); // 新建 HashMap对象，并将h1,h2添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(h1, "h1"); hmap.put(h2, "h2"); // 删除HashMap中的“h1”。 // 结果：删除“h1”之后，HashMap中只有 h2 ！ hmap.remove(h1); // 将WeakHashMap中的w1设置null，并执行gc()。系统会回收w1 // 结果：w1是“弱键”，被GC回收后，WeakHashMap中w1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 w2 // 注意：若去掉“w1=null” 或者“System.gc()”，结果都会不一样！ w1 = null; System.gc(); // 遍历并打印HashMap的大小 System.out.printf(" -- HashMap --\n"); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(" -- WeakHashMap --\n"); iteratorAndCountMap(wmap); &#125; /** * 通过自定义类测试HashMap和WeakHashMap */ private static void compareWithSelfClass() &#123; // 新建4个自定义对象 Self s1 = new Self(10); Self s2 = new Self(20); Self s3 = new Self(30); Self s4 = new Self(40); // 新建 WeakHashMap对象，并将s1,s2添加到 WeakHashMap中 Map wmap = new WeakHashMap(); wmap.put(s1, "s1"); wmap.put(s2, "s2"); // 新建 HashMap对象，并将s3,s4添加到 WeakHashMap中 Map hmap = new HashMap(); hmap.put(s3, "s3"); hmap.put(s4, "s4"); // 删除HashMap中的s3。 // 结果：删除s3之后，HashMap中只有 s4 ！ hmap.remove(s3); // 将WeakHashMap中的s1设置null，并执行gc()。系统会回收w1 // 结果：s1是“弱键”，被GC回收后，WeakHashMap中s1对应的键值对，也会被从WeakHashMap中删除。 // w2是“弱键”，但它不是null，不会被GC回收；也就不会被从WeakHashMap中删除。 // 因此，WeakHashMap中只有 s2 // 注意：若去掉“s1=null” 或者“System.gc()”，结果都会不一样！ s1 = null; System.gc(); /* // 休眠500ms try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // */ // 遍历并打印HashMap的大小 System.out.printf(" -- Self-def HashMap --\n"); iteratorAndCountMap(hmap); // 遍历并打印WeakHashMap的大小 System.out.printf(" -- Self-def WeakHashMap --\n"); iteratorAndCountMap(wmap); &#125; private static class Self &#123; int id; public Self(int id) &#123; this.id = id; &#125; // 覆盖finalize()方法 // 在GC回收时会被执行 protected void finalize() throws Throwable &#123; super.finalize(); System.out.printf("GC Self: id=%d addr=0x%s)\n", id, this); &#125; &#125;&#125; 运行结果： 12345678910111213141516 -- HashMap --map entry : H2 - h2map size:1 -- WeakHashMap --map entry : W2 - w2map size:1 -- Self-def HashMap --map entry : CompareHashmapAndWeakhashmap$Self@1ff9dc36 - s4map size:1 -- Self-def WeakHashMap --GC Self: id=10 addr=0xCompareHashmapAndWeakhashmap$Self@12276af2)map entry : CompareHashmapAndWeakhashmap$Self@59de3f2d - s2map size:1]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Set]]></title>
    <url>%2F2015%2F09%2F15%2F8-Collection-Map%2F15-Set%2F</url>
    <content type="text"><![CDATA[Set前面，我们已经系统的对List和Map进行了学习。接下来，我们开始可以学习Set。相信经过Map的了解之后，学习Set会容易很多。毕竟，Set的实现类都是基于Map来实现的(HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Set架构。 Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。 AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。 HastSet 和 TreeSet 是Set的两个实现类。 HashSet依赖于HashMap，它实际上是通过HashMap实现的。HashSet中的元素是无序的。 TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。TreeSet中的元素是有序的。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 WeakHashMap]]></title>
    <url>%2F2015%2F09%2F06%2F8-Collection-Map%2F13-WeakHashMap%2F</url>
    <content type="text"><![CDATA[WeakHashMap简介WeakHashMap 继承于AbstractMap，实现了Map接口。和HashMap一样，WeakHashMap 也是一个散列表，它存储的内容也是键值对(key-value)映射，而且键和值都可以是null。不过WeakHashMap的键是“弱键”。在 WeakHashMap 中，当某个键不再正常使用时，会被从WeakHashMap中被自动移除。更精确地说，对于一个给定的键，其映射的存在并不阻止垃圾回收器对该键的丢弃，这就使该键成为可终止的，被终止，然后被回收。某个键被终止时，它对应的键值对也就从映射中有效地移除了。 这个“弱键”的原理呢？大致上就是，通过WeakReference和ReferenceQueue实现的。 WeakHashMap的key是“弱键”，即是WeakReference类型的；ReferenceQueue是一个队列，它会保存被GC回收的“弱键”。实现步骤是： 新建WeakHashMap，将“键值对”添加到WeakHashMap中。 实际上，WeakHashMap是通过数组table保存Entry(键值对)；每一个Entry实际上是一个单向链表，即Entry是键值对链表。 当某“弱键”不再被其它对象引用，并被GC回收时。在GC回收该“弱键”时，这个“弱键”也同时会被添加到ReferenceQueue(queue)队列中。 当下一次我们需要操作WeakHashMap时，会先同步table和queue。table中保存了全部的键值对，而queue中保存被GC回收的键值对；同步它们，就是删除table中被GC回收的键值对。 这就是“弱键”如何被自动从WeakHashMap中删除的步骤了。 和HashMap一样，WeakHashMap是不同步的。可以使用 Collections.synchronizedMap 方法来构造同步的 WeakHashMap。 WeakHashMap的构造函数WeakHashMap共有4个构造函数,如下： 1234567891011// 默认构造函数。WeakHashMap()// 指定“容量大小”的构造函数WeakHashMap(int capacity)// 指定“容量大小”和“加载因子”的构造函数WeakHashMap(int capacity, float loadFactor)// 包含“子Map”的构造函数WeakHashMap(Map&lt;? extends K, ? extends V&gt; map) WeakHashMap的API12345678910111213void clear()Object clone()boolean containsKey(Object key)boolean containsValue(Object value)Set&lt;Entry&lt;K, V&gt;&gt; entrySet()V get(Object key)boolean isEmpty()Set&lt;K&gt; keySet()V put(K key, V value)void putAll(Map&lt;? extends K, ? extends V&gt; map)V remove(Object key)int size()Collection&lt;V&gt; values() WeakHashMap数据结构WeakHashMap的继承关系如下 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.WeakHashMap&lt;K, V&gt;public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; WeakHashMap与Map关系如下图： 从图中可以看出： WeakHashMap继承于AbstractMap，并且实现了Map接口。 WeakHashMap是哈希表，但是它的键是”弱键”。WeakHashMap中保护几个重要的成员变量：table, size, threshold, loadFactor, modCount, queue。 table 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size 是Hashtable的大小，它是Hashtable保存的键值对的数量。 threshold 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。 loadFactor 就是加载因子。 modCount 是用来实现fail-fast机制的 queue 保存的是“已被GC清除”的“弱引用的键”。 WeakHashMap源码解析(基于JDK1.6.0_45)下面对WeakHashMap的源码进行说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679package java.util;import java.lang.ref.WeakReference;import java.lang.ref.ReferenceQueue;public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; // 默认的初始容量是16，必须是2的幂。 private static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 private static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // WeakHashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 private Entry[] table; // WeakHashMap的大小，它是WeakHashMap保存的键值对的数量 private int size; // WeakHashMap的阈值，用于判断是否需要调整WeakHashMap的容量（threshold = 容量*加载因子） private int threshold; // 加载因子实际大小 private final float loadFactor; // queue保存的是“已被GC清除”的“弱引用的键”。 // 弱引用和ReferenceQueue 是联合使用的：如果弱引用所引用的对象被垃圾回收， // Java虚拟机就会把这个弱引用加入到与之关联的引用队列中 private final ReferenceQueue&lt;K&gt; queue = new ReferenceQueue&lt;K&gt;(); // WeakHashMap被改变的次数 private volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public WeakHashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Initial Capacity: "+ initialCapacity); // WeakHashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load factor: "+ loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 创建Entry数组，用来保存数据 table = new Entry[capacity]; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“WeakHashMap阈值”，当WeakHashMap中存储数据的数量达到threshold时， // 就需要将WeakHashMap的容量加倍。 threshold = (int)(capacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public WeakHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public WeakHashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; threshold = (int)(DEFAULT_INITIAL_CAPACITY); table = new Entry[DEFAULT_INITIAL_CAPACITY]; &#125; // 包含“子Map”的构造函数 public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, 16), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到WeakHashMap中 putAll(m); &#125; // 键为null的mask值。 // 因为WeakReference中允许“null的key”，若直接插入“null的key”，将其当作弱引用时，会被删除。 // 因此，这里对于“key为null”的清空，都统一替换为“key为NULL_KEY”，“NULL_KEY”是“静态的final常量”。 private static final Object NULL_KEY = new Object(); // 对“null的key”进行特殊处理 private static Object maskNull(Object key) &#123; return (key == null ? NULL_KEY : key); &#125; // 还原对“null的key”的特殊处理 private static &lt;K&gt; K unmaskNull(Object key) &#123; return (K) (key == NULL_KEY ? null : key); &#125; // 判断“x”和“y”是否相等 static boolean eq(Object x, Object y) &#123; return x == y || x.equals(y); &#125; // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; // 清空table中无用键值对。原理如下： // (01) 当WeakHashMap中某个“弱引用的key”由于没有再被引用而被GC收回时， // 被回收的“该弱引用key”也被会被添加到"ReferenceQueue(queue)"中。 // (02) 当我们执行expungeStaleEntries时， // 就遍历"ReferenceQueue(queue)"中的所有key // 然后就在“WeakReference的table”中删除与“ReferenceQueue(queue)中key”对应的键值对 private void expungeStaleEntries() &#123; Entry&lt;K,V&gt; e; while ( (e = (Entry&lt;K,V&gt;) queue.poll()) != null) &#123; int h = e.hash; int i = indexFor(h, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; p = prev; while (p != null) &#123; Entry&lt;K,V&gt; next = p.next; if (p == e) &#123; if (prev == e) table[i] = next; else prev.next = next; e.next = null; // Help GC e.value = null; // " " size--; break; &#125; prev = p; p = next; &#125; &#125; &#125; // 获取WeakHashMap的table(存放键值对的数组) private Entry[] getTable() &#123; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return table; &#125; // 获取WeakHashMap的实际大小 public int size() &#123; if (size == 0) return 0; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); return size; &#125; public boolean isEmpty() &#123; return size() == 0; &#125; // 获取key对应的value public V get(Object key) &#123; Object k = maskNull(key); // 获取key的hash值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; // 在“该hash值对应的链表”上查找“键值等于key”的元素 while (e != null) &#123; if (e.hash == h &amp;&amp; eq(k, e.get())) return e.value; e = e.next; &#125; return null; &#125; // WeakHashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 Entry&lt;K,V&gt; getEntry(Object key) &#123; Object k = maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; while (e != null &amp;&amp; !(e.hash == h &amp;&amp; eq(k, e.get()))) e = e.next; return e; &#125; // 将“key-value”添加到WeakHashMap中 public V put(K key, V value) &#123; K k = (K) maskNull(key); int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; V oldValue = e.value; if (value != oldValue) e.value = value; return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在于WeakHashMap中，则将“key-value”添加到table中 modCount++; Entry&lt;K,V&gt; e = tab[i]; tab[i] = new Entry&lt;K,V&gt;(k, value, queue, h, e); if (++size &gt;= threshold) resize(tab.length * 2); return null; &#125; // 重新调整WeakHashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = getTable(); int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个newTable，将“旧的table”的全部元素添加到“新的newTable”中， // 然后，将“新的newTable”赋值给“旧的table”。 Entry[] newTable = new Entry[newCapacity]; transfer(oldTable, newTable); table = newTable; if (size &gt;= threshold / 2) &#123; threshold = (int)(newCapacity * loadFactor); &#125; else &#123; // 删除table中“已被GC回收的key对应的键值对” expungeStaleEntries(); transfer(newTable, oldTable); table = oldTable; &#125; &#125; // 将WeakHashMap中的全部元素都添加到newTable中 private void transfer(Entry[] src, Entry[] dest) &#123; for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j]; src[j] = null; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object key = e.get(); if (key == null) &#123; e.next = null; // Help GC e.value = null; // " " size--; &#125; else &#123; int i = indexFor(e.hash, dest.length); e.next = dest[i]; dest[i] = e; &#125; e = next; &#125; &#125; &#125; // 将"m"的全部元素都添加到WeakHashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 将“m”中的元素逐个添加到WeakHashMap中。 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue()); &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Object k = maskNull(key); // 获取哈希值。 int h = HashMap.hash(k.hashCode()); Entry[] tab = getTable(); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e.value; &#125; prev = e; e = next; &#125; return null; &#125; // 删除“键值对” Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Entry[] tab = getTable(); Map.Entry entry = (Map.Entry)o; Object k = maskNull(entry.getKey()); int h = HashMap.hash(k.hashCode()); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e; &#125; prev = e; e = next; &#125; return null; &#125; // 清空WeakHashMap，将所有的元素设为null public void clear() &#123; while (queue.poll() != null) ; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; ++i) tab[i] = null; size = 0; while (queue.poll() != null) ; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value==null) return containsNullValue(); // 若“value不为null”，则查找WeakHashMap中是否有值为value的节点。 Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = getTable(); for (int i = tab.length ; i-- &gt; 0 ;) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value==null) return true; return false; &#125; // Entry是单向链表。 // 它是 “WeakHashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 private static class Entry&lt;K,V&gt; extends WeakReference&lt;K&gt; implements Map.Entry&lt;K,V&gt; &#123; private V value; private final int hash; // 指向下一个节点 private Entry&lt;K,V&gt; next; // 构造函数。 Entry(K key, V value, ReferenceQueue&lt;K&gt; queue, int hash, Entry&lt;K,V&gt; next) &#123; super(key, queue); this.value = value; this.hash = hash; this.next = next; &#125; public K getKey() &#123; return WeakHashMap.&lt;K&gt;unmaskNull(get()); &#125; public V getValue() &#123; return value; &#125; public V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public int hashCode() &#123; Object k = getKey(); Object v = getValue(); return ((k==null ? 0 : k.hashCode()) ^ (v==null ? 0 : v.hashCode())); &#125; public String toString() &#123; return getKey() + "=" + getValue(); &#125; &#125; // HashIterator是WeakHashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; entry = null; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned = null; // expectedModCount用于实现fast-fail机制。 int expectedModCount = modCount; // 下一个键(强引用) Object nextKey = null; // 当前键(强引用) Object currentKey = null; // 构造函数 HashIterator() &#123; index = (size() != 0 ? table.length : 0); &#125; // 是否存在下一个元素 public boolean hasNext() &#123; Entry[] t = table; // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 while (nextKey == null) &#123; Entry&lt;K,V&gt; e = entry; int i = index; while (e == null &amp;&amp; i &gt; 0) e = t[--i]; entry = e; index = i; if (e == null) &#123; currentKey = null; return false; &#125; nextKey = e.get(); // hold on to key in strong ref if (nextKey == null) entry = entry.next; &#125; return true; &#125; // 获取下一个元素 protected Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (nextKey == null &amp;&amp; !hasNext()) throw new NoSuchElementException(); lastReturned = entry; entry = entry.next; currentKey = nextKey; nextKey = null; return lastReturned; &#125; // 删除当前元素 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); WeakHashMap.this.remove(currentKey); expectedModCount = modCount; lastReturned = null; currentKey = null; &#125; &#125; // value的迭代器 private class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // WeakHashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return new KeyIterator(); &#125; public int size() &#123; return WeakHashMap.this.size(); &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; if (containsKey(o)) &#123; WeakHashMap.this.remove(o); return true; &#125; else return false; &#125; public void clear() &#123; WeakHashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(); &#125; public int size() &#123; return WeakHashMap.this.size(); &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; WeakHashMap.this.clear(); &#125; &#125; // 返回“WeakHashMap的Entry集合” // 它实际是返回一个EntrySet对象 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(); &#125; // 是否包含“值(o)” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k = e.getKey(); Entry candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; // 删除“值(o)” public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; // 返回WeakHashMap的大小 public int size() &#123; return WeakHashMap.this.size(); &#125; // 清空WeakHashMap public void clear() &#123; WeakHashMap.this.clear(); &#125; // 拷贝函数。将WeakHashMap中的全部元素都拷贝到List中 private List&lt;Map.Entry&lt;K,V&gt;&gt; deepCopy() &#123; List&lt;Map.Entry&lt;K,V&gt;&gt; list = new ArrayList&lt;Map.Entry&lt;K,V&gt;&gt;(size()); for (Map.Entry&lt;K,V&gt; e : this) list.add(new AbstractMap.SimpleEntry&lt;K,V&gt;(e)); return list; &#125; // 返回Entry对应的Object[]数组 public Object[] toArray() &#123; return deepCopy().toArray(); &#125; // 返回Entry对应的T[]数组(T[]我们新建数组时，定义的数组类型) public &lt;T&gt; T[] toArray(T[] a) &#123; return deepCopy().toArray(a); &#125; &#125;&#125; 说明：WeakHashMap和HashMap都是通过”拉链法”实现的散列表。它们的源码绝大部分内容都一样，这里就只是对它们不同的部分就是说明。 WeakReference是“弱键”实现的哈希表。 它这个“弱键”的目的就是：实现对“键值对”的动态回收。 当“弱键”不再被使用到时，GC会回收它，WeakReference也会将“弱键”对应的键值对删除。 “弱键”是一个“弱引用(WeakReference)”，在Java中，WeakReference和ReferenceQueue 是联合使用的。在WeakHashMap中亦是如此：如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。 接着，WeakHashMap会根据“引用队列”，来删除“WeakHashMap中已被GC回收的‘弱键’对应的键值对”。 另外，理解上面思想的重点是通过 expungeStaleEntries() 函数去理解。 WeakHashMap遍历方式遍历WeakHashMap的键值对第一步：根据entrySet()获取WeakHashMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 遍历WeakHashMap的键第一步：根据keySet()获取WeakHashMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历WeakHashMap的值第一步：根据value()获取WeakHashMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是WeakHashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; WeakHashMap遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.WeakHashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历WeakHashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */public class WeakHashMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); WeakHashMap map = new WeakHashMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到WeakHashMap中 map.put(key, value); System.out.println(" key:"+key+" value:"+value); &#125; // 通过entrySet()遍历WeakHashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历WeakHashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历WeakHashMap的value iteratorHashMapJustValues(map); &#125; /* * 通过entry set遍历WeakHashMap * 效率高! */ private static void iteratorHashMapByEntryset(WeakHashMap map) &#123; if (map == null) return ; System.out.println("\niterator WeakHashMap By entryset"); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+" -- "+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历WeakHashMap * 效率低! */ private static void iteratorHashMapByKeyset(WeakHashMap map) &#123; if (map == null) return ; System.out.println("\niterator WeakHashMap By keyset"); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+" -- "+integ.intValue()); &#125; &#125; /* * 遍历WeakHashMap的values */ private static void iteratorHashMapJustValues(WeakHashMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; WeakHashMap示例下面通过实例来学习如何使用WeakHashMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Iterator;import java.util.Map;import java.util.WeakHashMap;import java.util.Date;import java.lang.ref.WeakReference;/** * @desc WeakHashMap测试程序 * * @author skywang * @email kuiwu-wang@163.com */public class WeakHashMapTest &#123; public static void main(String[] args) throws Exception &#123; testWeakHashMapAPIs(); &#125; private static void testWeakHashMapAPIs() &#123; // 初始化3个“弱键” String w1 = new String("one"); String w2 = new String("two"); String w3 = new String("three"); // 新建WeakHashMap Map wmap = new WeakHashMap(); // 添加键值对 wmap.put(w1, "w1"); wmap.put(w2, "w2"); wmap.put(w3, "w3"); // 打印出wmap System.out.printf("\nwmap:%s\n",wmap ); // containsKey(Object key) :是否包含键key System.out.printf("contains key two : %s\n",wmap.containsKey("two")); System.out.printf("contains key five : %s\n",wmap.containsKey("five")); // containsValue(Object value) :是否包含值value System.out.printf("contains value 0 : %s\n",wmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 wmap.remove("three"); System.out.printf("wmap: %s\n",wmap ); // ---- 测试 WeakHashMap 的自动回收特性 ---- // 将w1设置null。 // 这意味着“弱键”w1再没有被其它对象引用，调用gc时会回收WeakHashMap中与“w1”对应的键值对 w1 = null; // 内存回收。这里，会回收WeakHashMap中与“w1”对应的键值对 System.gc(); // 遍历WeakHashMap Iterator iter = wmap.entrySet().iterator(); while (iter.hasNext()) &#123; Map.Entry en = (Map.Entry)iter.next(); System.out.printf("next : %s - %s\n",en.getKey(),en.getValue()); &#125; // 打印WeakHashMap的实际大小 System.out.printf(" after gc WeakHashMap size:%s\n", wmap.size()); &#125;&#125; 运行结果： 1234567wmap:&#123;three=w3, one=w1, two=w2&#125;contains key two : truecontains key five : falsecontains value 0 : falsewmap: &#123;one=w1, two=w2&#125;next : two - w2 after gc WeakHashMap size:1]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>WeakHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 TreeMap]]></title>
    <url>%2F2015%2F08%2F08%2F8-Collection-Map%2F12-TreeMap%2F</url>
    <content type="text"><![CDATA[TreeMap 简介TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。TreeMap 继承于AbstractMap，所以它是一个Map，即一个key-value集合。TreeMap 实现了NavigableMap接口，意味着它支持一系列的导航方法。比如返回有序的key集合。TreeMap 实现了Cloneable接口，意味着它能被克隆。TreeMap 实现了java.io.Serializable接口，意味着它支持序列化。 TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。TreeMap的基本操作 containsKey、get、put 和 remove 的时间复杂度是 log(n) 。另外，TreeMap是非同步的。 它的iterator 方法返回的迭代器是fail-fastl的。 TreeMap的构造函数1234567891011// 默认构造函数。使用该构造函数，TreeMap中的元素按照自然排序进行排列。TreeMap()// 创建的TreeMap包含MapTreeMap(Map&lt;? extends K, ? extends V&gt; copyFrom)// 指定Tree的比较器TreeMap(Comparator&lt;? super K&gt; comparator)// 创建的TreeSet包含copyFromTreeMap(SortedMap&lt;K, ? extends V&gt; copyFrom) TreeMap的API12345678910111213141516171819202122232425262728293031323334Entry&lt;K, V&gt; ceilingEntry(K key)K ceilingKey(K key)void clear()Object clone()Comparator&lt;? super K&gt; comparator()boolean containsKey(Object key)NavigableSet&lt;K&gt; descendingKeySet()NavigableMap&lt;K, V&gt; descendingMap()Set&lt;Entry&lt;K, V&gt;&gt; entrySet()Entry&lt;K, V&gt; firstEntry()K firstKey()Entry&lt;K, V&gt; floorEntry(K key)K floorKey(K key)V get(Object key)NavigableMap&lt;K, V&gt; headMap(K to, boolean inclusive)SortedMap&lt;K, V&gt; headMap(K toExclusive)Entry&lt;K, V&gt; higherEntry(K key)K higherKey(K key)boolean isEmpty()Set&lt;K&gt; keySet()Entry&lt;K, V&gt; lastEntry()K lastKey()Entry&lt;K, V&gt; lowerEntry(K key)K lowerKey(K key)NavigableSet&lt;K&gt; navigableKeySet()Entry&lt;K, V&gt; pollFirstEntry()Entry&lt;K, V&gt; pollLastEntry()V put(K key, V value)V remove(Object key)int size()SortedMap&lt;K, V&gt; subMap(K fromInclusive, K toExclusive)NavigableMap&lt;K, V&gt; subMap(K from, boolean fromInclusive, K to, boolean toInclusive)NavigableMap&lt;K, V&gt; tailMap(K from, boolean inclusive)SortedMap&lt;K, V&gt; tailMap(K fromInclusive) TreeMap数据结构TreeMap的继承关系 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.TreeMap&lt;K, V&gt;public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable &#123;&#125; TreeMap与Map关系图： 从图中可以看出： TreeMap实现继承于AbstractMap，并且实现了NavigableMap接口。 TreeMap的本质是R-B Tree(红黑树)，它包含几个重要的成员变量： root, size, comparator。 root 是红黑数的根节点。它是Entry类型，Entry是红黑数的节点，它包含了红黑数的6个基本组成成分：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)。Entry节点根据key进行排序，Entry节点包含的内容为value。 红黑数排序时，根据Entry中的key进行排序；Entry中的key比较大小是根据比较器comparator来进行判断的。 size是红黑数中节点的个数。 关于红黑数的具体算法，请参考”红黑树(一) 原理和算法详细介绍”。 TreeMap源码解析(基于JDK1.6.0_45)为了更了解TreeMap的原理，下面对TreeMap源码代码作出分析。我们先给出源码内容，后面再对源码进行详细说明，当然，源码内容中也包含了详细的代码注释。 说明: 在详细介绍TreeMap的代码之前，我们先建立一个整体概念。TreeMap是通过红黑树实现的，TreeMap存储的是key-value键值对，TreeMap的排序是基于对key的排序。TreeMap提供了操作“key”、“key-value”、“value”等方法，也提供了对TreeMap这颗树进行整体操作的方法，如获取子树、反向树。后面的解说内容分为几部分,首先，介绍TreeMap的核心，即红黑树相关部分；然后，介绍TreeMap的主要函数；再次，介绍TreeMap实现的几个接口；最后，补充介绍TreeMap的其它内容。 TreeMap本质上是一颗红黑树。要彻底理解TreeMap，建议读者先理解红黑树。关于红黑树的原理，可以参考：红黑树(一) 原理和算法详细介绍 http://www.cnblogs.com/skywang12345/p/3245399.html#a1 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211221231241251261271281291301311321331341351361371381391401411421431441451461471481491501511521531541551561571581591601611621631641651661671681691701711721731741751761771781791801811821831841851861871881891901911921931941951961971981992002012022032042052062072082092102112122132142152162172182192202212222232242252262272282292302312322332342352362372382392402412422432442452462472482492502512522532542552562572582592602612622632642652662672682692702712722732742752762772782792802812822832842852862872882892902912922932942952962972982993003013023033043053063073083093103113123133143153163173183193203213223233243253263273283293303313323333343353363373383393403413423433443453463473483493503513523533543553563573583593603613623633643653663673683693703713723733743753763773783793803813823833843853863873883893903913923933943953963973983994004014024034044054064074084094104114124134144154164174184194204214224234244254264274284294304314324334344354364374384394404414424434444454464474484494504514524534544554564574584594604614624634644654664674684694704714724734744754764774784794804814824834844854864874884894904914924934944954964974984995005015025035045055065075085095105115125135145155165175185195205215225235245255265275285295305315325335345355365375385395405415425435445455465475485495505515525535545555565575585595605615625635645655665675685695705715725735745755765775785795805815825835845855865875885895905915925935945955965975985996006016026036046056066076086096106116126136146156166176186196206216226236246256266276286296306316326336346356366376386396406416426436446456466476486496506516526536546556566576586596606616626636646656666676686696706716726736746756766776786796806816826836846856866876886896906916926936946956966976986997007017027037047057067077087097107117127137147157167177187197207217227237247257267277287297307317327337347357367377387397407417427437447457467477487497507517527537547557567577587597607617627637647657667677687697707717727737747757767777787797807817827837847857867877887897907917927937947957967977987998008018028038048058068078088098108118128138148158168178188198208218228238248258268278288298308318328338348358368378388398408418428438448458468478488498508518528538548558568578588598608618628638648658668678688698708718728738748758768778788798808818828838848858868878888898908918928938948958968978988999009019029039049059069079089099109119129139149159169179189199209219229239249259269279289299309319329339349359369379389399409419429439449459469479489499509519529539549559569579589599609619629639649659669679689699709719729739749759769779789799809819829839849859869879889899909919929939949959969979989991000100110021003100410051006100710081009101010111012101310141015101610171018101910201021102210231024102510261027102810291030103110321033103410351036103710381039104010411042104310441045104610471048104910501051105210531054105510561057105810591060106110621063106410651066106710681069107010711072107310741075107610771078107910801081108210831084108510861087108810891090109110921093109410951096109710981099110011011102110311041105110611071108110911101111111211131114111511161117111811191120112111221123112411251126112711281129113011311132113311341135113611371138113911401141114211431144114511461147114811491150115111521153115411551156115711581159116011611162116311641165116611671168116911701171117211731174117511761177117811791180118111821183118411851186118711881189119011911192119311941195119611971198119912001201120212031204120512061207120812091210121112121213121412151216121712181219122012211222122312241225122612271228122912301231123212331234123512361237123812391240124112421243124412451246124712481249125012511252125312541255125612571258125912601261126212631264126512661267126812691270127112721273127412751276127712781279128012811282128312841285128612871288128912901291129212931294129512961297129812991300130113021303130413051306130713081309131013111312131313141315131613171318131913201321132213231324132513261327132813291330133113321333133413351336133713381339134013411342134313441345134613471348134913501351135213531354135513561357135813591360136113621363136413651366136713681369137013711372137313741375137613771378137913801381138213831384138513861387138813891390139113921393139413951396139713981399140014011402140314041405140614071408140914101411141214131414141514161417141814191420142114221423142414251426142714281429143014311432143314341435143614371438143914401441144214431444144514461447144814491450145114521453145414551456145714581459146014611462146314641465146614671468146914701471147214731474147514761477147814791480148114821483148414851486148714881489149014911492149314941495149614971498149915001501150215031504150515061507150815091510151115121513151415151516151715181519152015211522152315241525152615271528152915301531153215331534153515361537153815391540154115421543154415451546154715481549155015511552155315541555155615571558155915601561156215631564156515661567156815691570157115721573157415751576157715781579158015811582158315841585158615871588158915901591159215931594159515961597159815991600160116021603160416051606160716081609161016111612161316141615161616171618161916201621162216231624162516261627162816291630163116321633163416351636163716381639164016411642164316441645164616471648164916501651165216531654165516561657165816591660166116621663166416651666166716681669167016711672167316741675167616771678167916801681168216831684168516861687168816891690169116921693169416951696169716981699170017011702170317041705170617071708170917101711171217131714171517161717171817191720172117221723172417251726172717281729173017311732173317341735173617371738173917401741174217431744174517461747174817491750175117521753175417551756175717581759176017611762176317641765176617671768176917701771177217731774177517761777177817791780178117821783178417851786178717881789179017911792179317941795179617971798179918001801180218031804180518061807180818091810181118121813181418151816181718181819182018211822182318241825182618271828182918301831183218331834183518361837183818391840184118421843184418451846184718481849185018511852185318541855185618571858185918601861186218631864186518661867186818691870187118721873187418751876187718781879188018811882188318841885188618871888188918901891189218931894189518961897189818991900190119021903190419051906190719081909191019111912191319141915191619171918191919201921192219231924192519261927192819291930193119321933193419351936193719381939194019411942194319441945194619471948194919501951195219531954195519561957195819591960196119621963196419651966196719681969197019711972197319741975197619771978197919801981198219831984198519861987198819891990199119921993199419951996199719981999200020012002200320042005200620072008200920102011201220132014201520162017201820192020202120222023202420252026202720282029203020312032203320342035203620372038203920402041204220432044204520462047204820492050package java.util;public class TreeMap&lt;K,V&gt;extends AbstractMap&lt;K,V&gt;implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; // 比较器。用来给TreeMap排序 private final Comparator&lt;? super K&gt; comparator; // TreeMap是红黑树实现的，root是红黑书的根节点 private transient Entry&lt;K,V&gt; root = null; // 红黑树的节点总数 private transient int size = 0; // 记录红黑树的修改次数 private transient int modCount = 0; // 默认构造函数 public TreeMap() &#123; comparator = null; &#125; // 带比较器的构造函数 public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; &#125; // 带Map的构造函数，Map会成为TreeMap的子集 public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m); &#125; // 带SortedMap的构造函数，SortedMap会成为TreeMap的子集 public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; &#125; public int size() &#123; return size; &#125; // 返回TreeMap中是否包含“键(key)” public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回TreeMap中是否包含"值(value)" public boolean containsValue(Object value) &#123; // getFirstEntry() 是返回红黑树的第一个节点 // successor(e) 是获取节点e的后继节点 for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) if (valEquals(value, e.value)) return true; return false; &#125; // 获取“键(key)”对应的“值(value)” public V get(Object key) &#123; // 获取“键”为key的节点(p) Entry&lt;K,V&gt; p = getEntry(key); // 若节点(p)为null，返回null；否则，返回节点对应的值 return (p==null ? null : p.value); &#125; public Comparator&lt;? super K&gt; comparator() &#123; return comparator; &#125; // 获取第一个节点对应的key public K firstKey() &#123; return key(getFirstEntry()); &#125; // 获取最后一个节点对应的key public K lastKey() &#123; return key(getLastEntry()); &#125; // 将map中的全部节点添加到TreeMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; map) &#123; // 获取map的大小 int mapSize = map.size(); // 如果TreeMap的大小是0,且map的大小不是0,且map是已排序的“key-value对” if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) &#123; Comparator c = ((SortedMap)map).comparator(); // 如果TreeMap和map的比较器相等； // 则将map的元素全部拷贝到TreeMap中，然后返回！ if (c == comparator || (c != null &amp;&amp; c.equals(comparator))) &#123; ++modCount; try &#123; buildFromSorted(mapSize, map.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return; &#125; &#125; // 调用AbstractMap中的putAll(); // AbstractMap中的putAll()又会调用到TreeMap的put() super.putAll(map); &#125; // 获取TreeMap中“键”为key的节点 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 若“比较器”为null，则通过getEntryUsingComparator()获取“键”为key的节点 if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的右孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; return null; &#125; // 获取TreeMap中“键”为key的节点(对应TreeMap的比较器不是null的情况) final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; // 将p设为根节点 Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); // 若“p的key” &lt; key，则p=“p的左孩子” if (cmp &lt; 0) p = p.left; // 若“p的key” &gt; key，则p=“p的左孩子” else if (cmp &gt; 0) p = p.right; // 若“p的key” = key，则返回节点p else return p; &#125; &#125; return null; &#125; // 获取TreeMap中大于或等于key的最小的节点； // 若不存在(即TreeMap中所有节点的键都比key大)，就返回null final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”又2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null; &#125; // 获取TreeMap中不大于key的最大的节点； // 若不存在(即TreeMap中所有节点的键都比key小)，就返回null // getFloorEntry的原理和getCeilingEntry类似，这里不再多说。 final Entry&lt;K,V&gt; getFloorEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else if (cmp &lt; 0) &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; else return p; &#125; return null; &#125; // 获取TreeMap中大于key的最小的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getHigherEntry进行理解。 final Entry&lt;K,V&gt; getHigherEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; &#125; else &#123; if (p.right != null) &#123; p = p.right; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 获取TreeMap中小于key的最大的节点。 // 若不存在，就返回null。 // 请参照getCeilingEntry来对getLowerEntry进行理解。 final Entry&lt;K,V&gt; getLowerEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); if (cmp &gt; 0) &#123; if (p.right != null) p = p.right; else return p; &#125; else &#123; if (p.left != null) &#123; p = p.left; &#125; else &#123; Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.left) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; &#125; &#125; return null; &#125; // 将“key, value”添加到TreeMap中 // 理解TreeMap的前提是掌握“红黑树”。 // 若理解“红黑树中添加节点”的算法，则很容易理解put。 public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; // 若红黑树为空，则插入根节点 if (t == null) &#123; // TBD: // 5045147: (coll) Adding null to an empty TreeSet should // throw NullPointerException // // compare(key, key); // type check root = new Entry&lt;K,V&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; // 在二叉树(红黑树是特殊的二叉树)中，找到(key, value)的插入位置。 // 红黑树是以key来进行排序的，所以这里以key来进行查找。 if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // 新建红黑树的节点(e) Entry&lt;K,V&gt; e = new Entry&lt;K,V&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; // 红黑树插入节点后，不再是一颗红黑树； // 这里通过fixAfterInsertion的处理，来恢复红黑树的特性。 fixAfterInsertion(e); size++; modCount++; return null; &#125; // 删除TreeMap中的键为key的节点，并返回节点的值 public V remove(Object key) &#123; // 找到键为key的节点 Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; // 保存节点的值 V oldValue = p.value; // 删除节点 deleteEntry(p); return oldValue; &#125; // 清空红黑树 public void clear() &#123; modCount++; size = 0; root = null; &#125; // 克隆一个TreeMap，并返回Object对象 public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into "virgin" state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone; &#125; // 获取第一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry()); &#125; // 获取最后一个节点(对外接口)。 public Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(getLastEntry()); &#125; // 获取第一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; // 获取第一个节点 Entry&lt;K,V&gt; p = getFirstEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除第一个节点 if (p != null) deleteEntry(p); return result; &#125; // 获取最后一个节点，并将改节点从TreeMap中删除。 public Map.Entry&lt;K,V&gt; pollLastEntry() &#123; // 获取最后一个节点 Entry&lt;K,V&gt; p = getLastEntry(); Map.Entry&lt;K,V&gt; result = exportEntry(p); // 删除最后一个节点 if (p != null) deleteEntry(p); return result; &#125; // 返回小于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(getLowerEntry(key)); &#125; // 返回小于key的最大的键值对所对应的KEY，没有的话返回null public K lowerKey(K key) &#123; return keyOrNull(getLowerEntry(key)); &#125; // 返回不大于key的最大的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(getFloorEntry(key)); &#125; // 返回不大于key的最大的键值对所对应的KEY，没有的话返回null public K floorKey(K key) &#123; return keyOrNull(getFloorEntry(key)); &#125; // 返回不小于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(getCeilingEntry(key)); &#125; // 返回不小于key的最小的键值对所对应的KEY，没有的话返回null public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key)); &#125; // 返回大于key的最小的键值对，没有的话返回null public Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(getHigherEntry(key)); &#125; // 返回大于key的最小的键值对所对应的KEY，没有的话返回null public K higherKey(K key) &#123; return keyOrNull(getHigherEntry(key)); &#125; // TreeMap的红黑树节点对应的集合 private transient EntrySet entrySet = null; // KeySet为KeySet导航类 private transient KeySet&lt;K&gt; navigableKeySet = null; // descendingMap为键值对的倒序“映射” private transient NavigableMap&lt;K,V&gt; descendingMap = null; // 返回TreeMap的“键的集合” public Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 获取“可导航”的Key的集合 // 实际上是返回KeySet类的对象。 public NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nks = navigableKeySet; return (nks != null) ? nks : (navigableKeySet = new KeySet(this)); &#125; // 返回“TreeMap的值对应的集合” public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values()); &#125; // 获取TreeMap的Entry的集合，实际上是返回EntrySet类的对象。 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet()); &#125; // 获取TreeMap的降序Map // 实际上是返回DescendingSubMap类的对象 public NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true)); &#125; // 获取TreeMap的子Map // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; return new AscendingSubMap(this, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部” // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; return new AscendingSubMap(this, true, null, true, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) &#123; return new AscendingSubMap(this, false, fromKey, inclusive, true, null, true); &#125; // 获取“子Map”。 // 范围是从fromKey(包括) 到 toKey(不包括) public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey(不包括) public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey(包括) 到 最后一个节点 public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // ”TreeMap的值的集合“对应的类，它集成于AbstractCollection class Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // "TreeMap的值的集合"中是否包含"对象o" public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除"TreeMap的值的集合"中的"对象o" public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除"TreeMap的值的集合" public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // EntrySet是“TreeMap的所有键值对组成的集合”， // EntrySet集合的单位是单个“键值对”。 class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125; &#125; // 返回“TreeMap的KEY组成的迭代器(顺序)” Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry()); &#125; // 返回“TreeMap的KEY组成的迭代器(逆序)” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry()); &#125; // KeySet是“TreeMap中所有的KEY组成的集合” // KeySet继承于AbstractSet，而且实现了NavigableSet接口。 static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; &#123; // NavigableMap成员，KeySet是通过NavigableMap实现的 private final NavigableMap&lt;E, Object&gt; m; KeySet(NavigableMap&lt;E,Object&gt; map) &#123; m = map; &#125; // 升序迭代器 public Iterator&lt;E&gt; iterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器keyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器keyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).keyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).keyIterator()); &#125; // 降序迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; // 若是TreeMap对象，则调用TreeMap的迭代器descendingKeyIterator() // 否则，调用TreeMap子类NavigableSubMap的迭代器descendingKeyIterator() if (m instanceof TreeMap) return ((TreeMap&lt;E,Object&gt;)m).descendingKeyIterator(); else return (Iterator&lt;E&gt;)(((TreeMap.NavigableSubMap)m).descendingKeyIterator()); &#125; public int size() &#123; return m.size(); &#125; public boolean isEmpty() &#123; return m.isEmpty(); &#125; public boolean contains(Object o) &#123; return m.containsKey(o); &#125; public void clear() &#123; m.clear(); &#125; public E lower(E e) &#123; return m.lowerKey(e); &#125; public E floor(E e) &#123; return m.floorKey(e); &#125; public E ceiling(E e) &#123; return m.ceilingKey(e); &#125; public E higher(E e) &#123; return m.higherKey(e); &#125; public E first() &#123; return m.firstKey(); &#125; public E last() &#123; return m.lastKey(); &#125; public Comparator&lt;? super E&gt; comparator() &#123; return m.comparator(); &#125; public E pollFirst() &#123; Map.Entry&lt;E,Object&gt; e = m.pollFirstEntry(); return e == null? null : e.getKey(); &#125; public E pollLast() &#123; Map.Entry&lt;E,Object&gt; e = m.pollLastEntry(); return e == null? null : e.getKey(); &#125; public boolean remove(Object o) &#123; int oldSize = size(); m.remove(o); return size() != oldSize; &#125; public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive, E toElement, boolean toInclusive) &#123; return new TreeSet&lt;E&gt;(m.subMap(fromElement, fromInclusive, toElement, toInclusive)); &#125; public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.headMap(toElement, inclusive)); &#125; public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) &#123; return new TreeSet&lt;E&gt;(m.tailMap(fromElement, inclusive)); &#125; public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) &#123; return subSet(fromElement, true, toElement, false); &#125; public SortedSet&lt;E&gt; headSet(E toElement) &#123; return headSet(toElement, false); &#125; public SortedSet&lt;E&gt; tailSet(E fromElement) &#123; return tailSet(fromElement, true); &#125; public NavigableSet&lt;E&gt; descendingSet() &#123; return new TreeSet(m.descendingMap()); &#125; &#125; // 它是TreeMap中的一个抽象迭代器，实现了一些通用的接口。 abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // 上一次返回元素 Entry&lt;K,V&gt; lastReturned; // 期望的修改次数，用于实现fast-fail机制 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 获取上一个节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向"新的当前节点"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125; &#125; // TreeMap的Entry对应的迭代器 final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // TreeMap的Value对应的迭代器 final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125; &#125; // reeMap的KEY组成的迭代器(顺序) final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125; &#125; // TreeMap的KEY组成的迭代器(逆序) final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125; &#125; // 比较两个对象的大小 final int compare(Object k1, Object k2) &#123; return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2) : comparator.compare((K)k1, (K)k2); &#125; // 判断两个对象是否相等 final static boolean valEquals(Object o1, Object o2) &#123; return (o1==null ? o2==null : o1.equals(o2)); &#125; // 返回“Key-Value键值对”的一个简单拷贝(AbstractMap.SimpleImmutableEntry&lt;K,V&gt;对象) // 可用来读取“键值对”的值 static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e); &#125; // 若“键值对”不为null，则返回KEY；否则，返回null static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key; &#125; // 若“键值对”不为null，则返回KEY；否则，抛出异常 static &lt;K&gt; K key(Entry&lt;K,?&gt; e) &#123; if (e==null) throw new NoSuchElementException(); return e.key; &#125; // TreeMap的SubMap，它一个抽象类，实现了公共操作。 // 它包括了"(升序)AscendingSubMap"和"(降序)DescendingSubMap"两个子类。 static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException("fromKey &gt; toKey"); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"大于/等于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"大于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"小于/等于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取"小于/等于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"小于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取"小于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException("key out of range"); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取"SubMap的第一个键" public final K firstKey() &#123; return key(subLowest()); &#125; // 获取"SubMap的最后一个键" public final K lastKey() &#123; return key(subHighest()); &#125; // 获取"SubMap的第一个键值对" public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取"SubMap的最后一个键值对" public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回"SubMap的第一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回"SubMap的最后一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的"Key集合"。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回"Key集合"对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向"新的当前节点"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; &#125; // 升序的SubMap，继承于NavigableSubMap static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866124060L; // 构造函数 AscendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 比较器 public Comparator&lt;? super K&gt; comparator() &#123; return m.comparator(); &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException("fromKey out of range"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException("toKey out of range"); return new AscendingSubMap(m, false, fromKey, fromInclusive, false, toKey, toInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException("toKey out of range"); return new AscendingSubMap(m, fromStart, lo, loInclusive, false, toKey, inclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException("fromKey out of range"); return new AscendingSubMap(m, false, fromKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new DescendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // “升序EntrySet集合”类 // 实现了iterator() final class AscendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new SubMapEntryIterator(absLowest(), absHighFence()); &#125; &#125; // 返回“升序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new AscendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absHigher(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absLower(key); &#125; &#125; // 降序的SubMap，继承于NavigableSubMap // 相比于升序SubMap，它的实现机制是将“SubMap的比较器反转”！ static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException("fromKey out of range"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException("fromKey out of range"); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125; &#125; // SubMap是旧版本的类，新的Java中没有用到。 private class SubMap extends AbstractMap&lt;K,V&gt; implements SortedMap&lt;K,V&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -6520786458950516097L; private boolean fromStart = false, toEnd = false; private K fromKey, toKey; private Object readResolve() &#123; return new AscendingSubMap(TreeMap.this, fromStart, fromKey, true, toEnd, toKey, false); &#125; public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; throw new InternalError(); &#125; public K lastKey() &#123; throw new InternalError(); &#125; public K firstKey() &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; headMap(K toKey) &#123; throw new InternalError(); &#125; public SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; throw new InternalError(); &#125; public Comparator&lt;? super K&gt; comparator() &#123; throw new InternalError(); &#125; &#125; // 红黑树的节点颜色--红色 private static final boolean RED = false; // 红黑树的节点颜色--黑色 private static final boolean BLACK = true; // “红黑树的节点”对应的类。 // 包含了 key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色) static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 键 K key; // 值 V value; // 左孩子 Entry&lt;K,V&gt; left = null; // 右孩子 Entry&lt;K,V&gt; right = null; // 父节点 Entry&lt;K,V&gt; parent; // 当前节点颜色 boolean color = BLACK; // 构造函数 Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; // 返回“键” public K getKey() &#123; return key; &#125; // 返回“值” public V getValue() &#123; return value; &#125; // 更新“值”，返回旧的值 public V setValue(V value) &#123; V oldValue = this.value; this.value = value; return oldValue; &#125; // 判断两个节点是否相等的函数，覆盖equals()函数。 // 若两个节点的“key相等”并且“value相等”，则两个节点相等 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue()); &#125; // 覆盖hashCode函数。 public int hashCode() &#123; int keyHash = (key==null ? 0 : key.hashCode()); int valueHash = (value==null ? 0 : value.hashCode()); return keyHash ^ valueHash; &#125; // 覆盖toString()函数。 public String toString() &#123; return key + "=" + value; &#125; &#125; // 返回“红黑树的第一个节点” final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p; &#125; // 返回“红黑树的最后一个节点” final Entry&lt;K,V&gt; getLastEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.right != null) p = p.right; return p; &#125; // 返回“节点t的后继节点” static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.right != null) &#123; Entry&lt;K,V&gt; p = t.right; while (p.left != null) p = p.left; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.right) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点t的前继节点” static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) &#123; if (t == null) return null; else if (t.left != null) &#123; Entry&lt;K,V&gt; p = t.left; while (p.right != null) p = p.right; return p; &#125; else &#123; Entry&lt;K,V&gt; p = t.parent; Entry&lt;K,V&gt; ch = t; while (p != null &amp;&amp; ch == p.left) &#123; ch = p; p = p.parent; &#125; return p; &#125; &#125; // 返回“节点p的颜色” // 根据“红黑树的特性”可知：空节点颜色是黑色。 private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? BLACK : p.color); &#125; // 返回“节点p的父节点” private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) &#123; return (p == null ? null: p.parent); &#125; // 设置“节点p的颜色为c” private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) &#123; if (p != null) p.color = c; &#125; // 设置“节点p的左孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.left; &#125; // 设置“节点p的右孩子” private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) &#123; return (p == null) ? null: p.right; &#125; // 对节点p执行“左旋”操作 private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125; &#125; // 对节点p执行“右旋”操作 private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125; &#125; // 插入之后的修正操作。 // 目的是保证：红黑树插入节点之后，仍然是一颗红黑树 private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK; &#125; // 删除“红黑树的节点p” private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor (p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125; &#125; // 删除之后的修正操作。 // 目的是保证：红黑树删除节点之后，仍然是一颗红黑树 private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK); &#125; private static final long serialVersionUID = 919286545866124006L; // java.io.Serializable的写入函数 // 将TreeMap的“容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将TreeMap的“容量、所有的Entry”依次读出 private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null); &#125; // 根据已经一个排好序的map创建一个TreeMap private void buildFromSorted(int size, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; this.size = size; root = buildFromSorted(0, 0, size-1, computeRedLevel(size), it, str, defaultVal); &#125; // 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; // 计算节点树为sz的最大深度，也是红色节点的深度值。 private static int computeRedLevel(int sz) &#123; int level = 0; for (int m = sz - 1; m &gt;= 0; m = m / 2 - 1) level++; return level; &#125;&#125; TreeMap的红黑树相关内容TreeMap中于红黑树相关的主要函数有: 数据结构红黑树的节点颜色–红色1private static final boolean RED = false; 红黑树的节点颜色–黑色1private static final boolean BLACK = true; “红黑树的节点”对应的类。123static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; ... &#125;Entry包含了6个部分内容：key(键)、value(值)、left(左孩子)、right(右孩子)、parent(父节点)、color(颜色)Entry节点根据key进行排序，Entry节点包含的内容为value。 相关操作左旋1private void rotateLeft(Entry&lt;K,V&gt; p) &#123; ... &#125; 右旋1private void rotateRight(Entry&lt;K,V&gt; p) &#123; ... &#125; 插入操作1public V put(K key, V value) &#123; ... &#125; 插入修正操作红黑树执行插入操作之后，要执行“插入修正操作”。目的是：保红黑树在进行插入节点之后，仍然是一颗红黑树1private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; ... &#125; 删除操作1private void deleteEntry(Entry&lt;K,V&gt; p) &#123; ... &#125; 删除修正操作红黑树执行删除之后，要执行“删除修正操作”。目的是保证：红黑树删除节点之后，仍然是一颗红黑树 1private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; ... &#125; 关于红黑树部分，这里主要是指出了TreeMap中那些是红黑树的主要相关内容。具体的红黑树相关操作API，这里没有详细说明，因为它们仅仅只是将算法翻译成代码。读者可以参考“红黑树(一) 原理和算法详细介绍”进行了解。 TreeMap的构造函数默认构造函数使用默认构造函数构造TreeMap时，使用java的默认的比较器比较Key的大小，从而对TreeMap进行排序。 123public TreeMap() &#123; comparator = null;&#125; 带比较器的构造函数123public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125; 带Map的构造函数，Map会成为TreeMap的子集1234public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125; 该构造函数会调用putAll()将m中的所有元素添加到TreeMap中。putAll()源码如下： 1234public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) put(e.getKey(), e.getValue());&#125; 从中，我们可以看出putAll()就是将m中的key-value逐个的添加到TreeMap中。 带SortedMap的构造函数，SortedMap会成为TreeMap的子集12345678public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; 该构造函数不同于上一个构造函数，在上一个构造函数中传入的参数是Map，Map不是有序的，所以要逐个添加。而该构造函数的参数是SortedMap是一个有序的Map，我们通过buildFromSorted()来创建对应的Map。buildFromSorted涉及到的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 根据已经一个排好序的map创建一个TreeMap // 将map中的元素逐个添加到TreeMap中，并返回map的中间元素作为根节点。 private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi, int redLevel, Iterator it, java.io.ObjectInputStream str, V defaultVal) throws java.io.IOException, ClassNotFoundException &#123; if (hi &lt; lo) return null; // 获取中间元素 int mid = (lo + hi) / 2; Entry&lt;K,V&gt; left = null; // 若lo小于mid，则递归调用获取(middel的)左孩子。 if (lo &lt; mid) left = buildFromSorted(level+1, lo, mid - 1, redLevel, it, str, defaultVal); // 获取middle节点对应的key和value K key; V value; if (it != null) &#123; if (defaultVal==null) &#123; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;)it.next(); key = entry.getKey(); value = entry.getValue(); &#125; else &#123; key = (K)it.next(); value = defaultVal; &#125; &#125; else &#123; // use stream key = (K) str.readObject(); value = (defaultVal != null ? defaultVal : (V) str.readObject()); &#125; // 创建middle节点 Entry&lt;K,V&gt; middle = new Entry&lt;K,V&gt;(key, value, null); // 若当前节点的深度=红色节点的深度，则将节点着色为红色。 if (level == redLevel) middle.color = RED; // 设置middle为left的父亲，left为middle的左孩子 if (left != null) &#123; middle.left = left; left.parent = middle; &#125; if (mid &lt; hi) &#123; // 递归调用获取(middel的)右孩子。 Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel, it, str, defaultVal); // 设置middle为left的父亲，left为middle的左孩子 middle.right = right; right.parent = middle; &#125; return middle; &#125; 要理解buildFromSorted，重点说明以下几点： 第一，buildFromSorted是通过递归将SortedMap中的元素逐个关联。第二，buildFromSorted返回middle节点(中间节点)作为root。第三，buildFromSorted添加到红黑树中时，只将level == redLevel的节点设为红色。第level级节点，实际上是buildFromSorted转换成红黑树后的最底端(假设根节点在最上方)的节点；只将红黑树最底端的阶段着色为红色，其余都是黑色。 TreeMap的Entry相关函数TreeMap的 firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry() 原理都是类似的；下面以firstEntry()来进行详细说明 我们先看看firstEntry()和getFirstEntry()的代码： 1234567891011public Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(getFirstEntry());&#125;final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p;&#125; 从中，我们可以看出 firstEntry() 和 getFirstEntry() 都是用于获取第一个节点。但是，firstEntry() 是对外接口； getFirstEntry() 是内部接口。而且，firstEntry() 是通过 getFirstEntry() 来实现的。那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?先告诉大家原因，再进行详细说明。这么做的目的是：防止用户修改返回的Entry。getFirstEntry()返回的Entry是可以被修改的，但是经过firstEntry()返回的Entry不能被修改，只可以读取Entry的key值和value值。下面我们看看到底是如何实现的。 (01) getFirstEntry()返回的是Entry节点，而Entry是红黑树的节点，它的源码如下： 12345678// 返回“红黑树的第一个节点”final Entry&lt;K,V&gt; getFirstEntry() &#123; Entry&lt;K,V&gt; p = root; if (p != null) while (p.left != null) p = p.left; return p;&#125; 从中，我们可以调用Entry的getKey()、getValue()来获取key和value值，以及调用setValue()来修改value的值。 (02) firstEntry()返回的是exportEntry(getFirstEntry())。下面我们看看exportEntry()干了些什么？ 1234static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : new AbstractMap.SimpleImmutableEntry&lt;K,V&gt;(e);&#125; 实际上，exportEntry() 是新建一个AbstractMap.SimpleImmutableEntry类型的对象，并返回。 SimpleImmutableEntry的实现在AbstractMap.java中，下面我们看看AbstractMap.SimpleImmutableEntry是如何实现的，代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static class SimpleImmutableEntry&lt;K,V&gt;implements Entry&lt;K,V&gt;, java.io.Serializable&#123; private static final long serialVersionUID = 7138329143949025153L; private final K key; private final V value; public SimpleImmutableEntry(K key, V value) &#123; this.key = key; this.value = value; &#125; public SimpleImmutableEntry(Entry&lt;? extends K, ? extends V&gt; entry) &#123; this.key = entry.getKey(); this.value = entry.getValue(); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; public V setValue(V value) &#123; throw new UnsupportedOperationException(); &#125; public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue()); &#125; public int hashCode() &#123; return (key == null ? 0 : key.hashCode()) ^ (value == null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key + "=" + value; &#125;&#125; 从中，我们可以看出SimpleImmutableEntry实际上是简化的key-value节点。它只提供了getKey()、getValue()方法类获取节点的值；但不能修改value的值，因为调用 setValue() 会抛出异常UnsupportedOperationException(); 再回到我们之前的问题：那为什么外界不能直接调用 getFirstEntry()，而需要多此一举的调用 firstEntry() 呢?现在我们清晰的了解到：(01) firstEntry()是对外接口，而getFirstEntry()是内部接口。(02) 对firstEntry()返回的Entry对象只能进行getKey()、getValue()等读取操作；而对getFirstEntry()返回的对象除了可以进行读取操作之后，还可以通过setValue()修改值。 TreeMap的key相关函数TreeMap的firstKey()、lastKey()、lowerKey()、higherKey()、floorKey()、ceilingKey()原理都是类似的；下面以ceilingKey()来进行详细说明 ceilingKey(K key)的作用是“返回大于/等于key的最小的键值对所对应的KEY，没有的话返回null”，它的代码如下： 123public K ceilingKey(K key) &#123; return keyOrNull(getCeilingEntry(key));&#125; ceilingKey()是通过getCeilingEntry()实现的。keyOrNull()的代码很简单，它是获取节点的key，没有的话，返回null。 123static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) &#123; return e == null? null : e.key;&#125; getCeilingEntry(K key)的作用是“获取TreeMap中大于/等于key的最小的节点，若不存在(即TreeMap中所有节点的键都比key大)，就返回null”。它的实现代码如下： 12345678910111213141516171819202122232425262728293031323334353637final Entry&lt;K,V&gt; getCeilingEntry(K key) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = compare(key, p.key); // 情况一：若“p的key” &gt; key。 // 若 p 存在左孩子，则设 p=“p的左孩子”； // 否则，返回p if (cmp &lt; 0) &#123; if (p.left != null) p = p.left; else return p; // 情况二：若“p的key” &lt; key。 &#125; else if (cmp &gt; 0) &#123; // 若 p 存在右孩子，则设 p=“p的右孩子” if (p.right != null) &#123; p = p.right; &#125; else &#123; // 若 p 不存在右孩子，则找出 p 的后继节点，并返回 // 注意：这里返回的 “p的后继节点”有2种可能性：第一，null；第二，TreeMap中大于key的最小的节点。 // 理解这一点的核心是，getCeilingEntry是从root开始遍历的。 // 若getCeilingEntry能走到这一步，那么，它之前“已经遍历过的节点的key”都 &gt; key。 // 能理解上面所说的，那么就很容易明白，为什么“p的后继节点”有2种可能性了。 Entry&lt;K,V&gt; parent = p.parent; Entry&lt;K,V&gt; ch = p; while (parent != null &amp;&amp; ch == parent.right) &#123; ch = parent; parent = parent.parent; &#125; return parent; &#125; // 情况三：若“p的key” = key。 &#125; else return p; &#125; return null;&#125; TreeMap的values()函数values() 返回“TreeMap中值的集合” values()的实现代码如下： 1234public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null) ? vs : (values = new Values());&#125; 说明：从中，我们可以发现values()是通过 new Values() 来实现 “返回TreeMap中值的集合”。 那么Values()是如何实现的呢？ 没错！由于返回的是值的集合，那么Values()肯定返回一个集合；而Values()正好是集合类Value的构造函数。Values继承于AbstractCollection，它的代码如下： 123456789101112131415161718192021222324252627282930313233// ”TreeMap的值的集合“对应的类，它集成于AbstractCollectionclass Values extends AbstractCollection&lt;V&gt; &#123; // 返回迭代器 public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry()); &#125; // 返回个数 public int size() &#123; return TreeMap.this.size(); &#125; // "TreeMap的值的集合"中是否包含"对象o" public boolean contains(Object o) &#123; return TreeMap.this.containsValue(o); &#125; // 删除"TreeMap的值的集合"中的"对象o" public boolean remove(Object o) &#123; for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) &#123; if (valEquals(e.getValue(), o)) &#123; deleteEntry(e); return true; &#125; &#125; return false; &#125; // 清空删除"TreeMap的值的集合" public void clear() &#123; TreeMap.this.clear(); &#125;&#125; 说明：从中，我们可以知道Values类就是一个集合。而 AbstractCollection 实现了除 size() 和 iterator() 之外的其它函数，因此只需要在Values类中实现这两个函数即可。size() 的实现非常简单，Values集合中元素的个数=该TreeMap的元素个数。(TreeMap每一个元素都有一个值嘛！)iterator() 则返回一个迭代器，用于遍历Values。下面，我们一起可以看看iterator()的实现： 123public Iterator&lt;V&gt; iterator() &#123; return new ValueIterator(getFirstEntry());&#125; 说明： iterator() 是通过ValueIterator() 返回迭代器的，ValueIterator是一个类。代码如下： 12345678final class ValueIterator extends PrivateEntryIterator&lt;V&gt; &#123; ValueIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public V next() &#123; return nextEntry().value; &#125;&#125; 说明：ValueIterator的代码很简单，它的主要实现应该在它的父类PrivateEntryIterator中。下面我们一起看看PrivateEntryIterator的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 下一节点 Entry&lt;K,V&gt; next; // 上一次返回的节点 Entry&lt;K,V&gt; lastReturned; // 修改次数统计数 int expectedModCount; PrivateEntryIterator(Entry&lt;K,V&gt; first) &#123; expectedModCount = modCount; lastReturned = null; next = first; &#125; // 是否存在下一个节点 public final boolean hasNext() &#123; return next != null; &#125; // 返回下一个节点 final Entry&lt;K,V&gt; nextEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = successor(e); lastReturned = e; return e; &#125; // 返回上一节点 final Entry&lt;K,V&gt; prevEntry() &#123; Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点 public void remove() &#123; if (lastReturned == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); // deleted entries are replaced by their successors if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; deleteEntry(lastReturned); expectedModCount = modCount; lastReturned = null; &#125;&#125; 说明：PrivateEntryIterator是一个抽象类，它的实现很简单，只只实现了Iterator的remove()和hasNext()接口，没有实现next()接口。而我们在ValueIterator中已经实现的next()接口。至此，我们就了解了iterator()的完整实现了。 TreeMap的entrySet()函数entrySet() 返回“键值对集合”。顾名思义，它返回的是一个集合，集合的元素是“键值对”。 下面，我们看看它是如何实现的？entrySet() 的实现代码如下： 1234public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySet es = entrySet; return (es != null) ? es : (entrySet = new EntrySet());&#125; 说明：entrySet()返回的是一个EntrySet对象。 下面我们看看EntrySet的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041// EntrySet是“TreeMap的所有键值对组成的集合”，// EntrySet集合的单位是单个“键值对”。class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new EntryIterator(getFirstEntry()); &#125; // EntrySet中是否包含“键值对Object” public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); return p != null &amp;&amp; valEquals(p.getValue(), value); &#125; // 删除EntrySet中的“键值对Object” public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; V value = entry.getValue(); Entry&lt;K,V&gt; p = getEntry(entry.getKey()); if (p != null &amp;&amp; valEquals(p.getValue(), value)) &#123; deleteEntry(p); return true; &#125; return false; &#125; // 返回EntrySet中元素个数 public int size() &#123; return TreeMap.this.size(); &#125; // 清空EntrySet public void clear() &#123; TreeMap.this.clear(); &#125;&#125; 说明：EntrySet是“TreeMap的所有键值对组成的集合”，而且它单位是单个“键值对”。EntrySet是一个集合，它继承于AbstractSet。而AbstractSet实现了除size() 和 iterator() 之外的其它函数，因此，我们重点了解一下EntrySet的size() 和 iterator() 函数 size() 的实现非常简单，AbstractSet集合中元素的个数=该TreeMap的元素个数。iterator() 则返回一个迭代器，用于遍历AbstractSet。从上面的源码中，我们可以发现iterator() 是通过EntryIterator实现的；下面我们看看EntryIterator的源码： 12345678final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; EntryIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125; 说明：和Values类一样，EntryIterator也继承于PrivateEntryIterator类。 TreeMap实现的Cloneable接口TreeMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个TreeMap对象并返回。 1234567891011121314151617181920212223242526// 克隆一个TreeMap，并返回Object对象public Object clone() &#123; TreeMap&lt;K,V&gt; clone = null; try &#123; clone = (TreeMap&lt;K,V&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // Put clone into "virgin" state (except for comparator) clone.root = null; clone.size = 0; clone.modCount = 0; clone.entrySet = null; clone.navigableKeySet = null; clone.descendingMap = null; // Initialize clone with our mappings try &#123; clone.buildFromSorted(size, entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125; return clone;&#125; TreeMap实现的Serializable接口TreeMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将TreeMap的“容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将TreeMap的“容量、所有的Entry”依次读出。readObject() 和 writeObject() 正好是一对，通过它们，我能实现TreeMap的串行传输。 12345678910111213141516171819202122232425262728293031// java.io.Serializable的写入函数// 将TreeMap的“容量，所有的Entry”都写入到输出流中private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out the Comparator and any hidden stuff s.defaultWriteObject(); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) for (Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125;&#125;// java.io.Serializable的读取函数：根据写入方式读出// 先将TreeMap的“容量、所有的Entry”依次读出private void readObject(final java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in the Comparator and any hidden stuff s.defaultReadObject(); // Read in size int size = s.readInt(); buildFromSorted(size, null, s, null);&#125; 说到这里，就顺便说一下“关键字transient”的作用 transient是Java语言的关键字，它被用来表示一个域不是该对象串行化的一部分。Java的serialization提供了一种持久化对象实例的机制。当持久化对象时，可能有一个特殊的对象数据成员，我们不想用serialization机制来保存它。为了在一个特定对象的一个域上关闭serialization，可以在这个域前加上关键字transient。当一个对象被串行化的时候，transient型变量的值不包括在串行化的表示中，然而非transient型的变量是被包括进去的。 TreeMap实现的NavigableMap接口firstKey()、lastKey()、lowerKey()、higherKey()、ceilingKey()、floorKey();firstEntry()、 lastEntry()、 lowerEntry()、 higherEntry()、 floorEntry()、 ceilingEntry()、 pollFirstEntry() 、 pollLastEntry();上面已经讲解过这些API了，下面对其它的API进行说明。 1 反向TreeMapdescendingMap() 的作用是返回当前TreeMap的反向的TreeMap。所谓反向，就是排序顺序和原始的顺序相反。 我们已经知道TreeMap是一颗红黑树，而红黑树是有序的。TreeMap的排序方式是通过比较器，在创建TreeMap的时候，若指定了比较器，则使用该比较器；否则，就使用Java的默认比较器。而获取TreeMap的反向TreeMap的原理就是将比较器反向即可！ 理解了descendingMap()的反向原理之后，再讲解一下descendingMap()的代码。 12345678// 获取TreeMap的降序Mappublic NavigableMap&lt;K, V&gt; descendingMap() &#123; NavigableMap&lt;K, V&gt; km = descendingMap; return (km != null) ? km : (descendingMap = new DescendingSubMap(this, true, null, true, true, null, true));&#125; 从中，我们看出descendingMap()实际上是返回DescendingSubMap类的对象。下面，看看DescendingSubMap的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091static final class DescendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; &#123; private static final long serialVersionUID = 912986545866120460L; DescendingSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive); &#125; // 反转的比较器：是将原始比较器反转得到的。 private final Comparator&lt;? super K&gt; reverseComparator = Collections.reverseOrder(m.comparator); // 获取反转比较器 public Comparator&lt;? super K&gt; comparator() &#123; return reverseComparator; &#125; // 获取“子Map”。 // 范围是从fromKey 到 toKey；fromInclusive是是否包含fromKey的标记，toInclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive) &#123; if (!inRange(fromKey, fromInclusive)) throw new IllegalArgumentException("fromKey out of range"); if (!inRange(toKey, toInclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, toInclusive, false, fromKey, fromInclusive); &#125; // 获取“Map的头部”。 // 范围从第一个节点 到 toKey, inclusive是是否包含toKey的标记 public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) &#123; if (!inRange(toKey, inclusive)) throw new IllegalArgumentException("toKey out of range"); return new DescendingSubMap(m, false, toKey, inclusive, toEnd, hi, hiInclusive); &#125; // 获取“Map的尾部”。 // 范围是从 fromKey 到 最后一个节点，inclusive是是否包含fromKey的标记 public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive)&#123; if (!inRange(fromKey, inclusive)) throw new IllegalArgumentException("fromKey out of range"); return new DescendingSubMap(m, fromStart, lo, loInclusive, false, fromKey, inclusive); &#125; // 获取对应的降序Map public NavigableMap&lt;K,V&gt; descendingMap() &#123; NavigableMap&lt;K,V&gt; mv = descendingMapView; return (mv != null) ? mv : (descendingMapView = new AscendingSubMap(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive)); &#125; // 返回“升序Key迭代器” Iterator&lt;K&gt; keyIterator() &#123; return new DescendingSubMapKeyIterator(absHighest(), absLowFence()); &#125; // 返回“降序Key迭代器” Iterator&lt;K&gt; descendingKeyIterator() &#123; return new SubMapKeyIterator(absLowest(), absHighFence()); &#125; // “降序EntrySet集合”类 // 实现了iterator() final class DescendingEntrySetView extends EntrySetView &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return new DescendingSubMapEntryIterator(absHighest(), absLowFence()); &#125; &#125; // 返回“降序EntrySet集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; EntrySetView es = entrySetView; return (es != null) ? es : new DescendingEntrySetView(); &#125; TreeMap.Entry&lt;K,V&gt; subLowest() &#123; return absHighest(); &#125; TreeMap.Entry&lt;K,V&gt; subHighest() &#123; return absLowest(); &#125; TreeMap.Entry&lt;K,V&gt; subCeiling(K key) &#123; return absFloor(key); &#125; TreeMap.Entry&lt;K,V&gt; subHigher(K key) &#123; return absLower(key); &#125; TreeMap.Entry&lt;K,V&gt; subFloor(K key) &#123; return absCeiling(key); &#125; TreeMap.Entry&lt;K,V&gt; subLower(K key) &#123; return absHigher(key); &#125;&#125; 从中，我们看出DescendingSubMap是降序的SubMap，它的实现机制是将“SubMap的比较器反转”。 它继承于NavigableSubMap。而NavigableSubMap是一个继承于AbstractMap的抽象类；它包括2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”。NavigableSubMap为它的两个子类实现了许多公共API。下面看看NavigableSubMap的源码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529static abstract class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, java.io.Serializable &#123; // TreeMap的拷贝 final TreeMap&lt;K,V&gt; m; // lo是“子Map范围的最小值”，hi是“子Map范围的最大值”； // loInclusive是“是否包含lo的标记”，hiInclusive是“是否包含hi的标记” // fromStart是“表示是否从第一个节点开始计算”， // toEnd是“表示是否计算到最后一个节点 ” final K lo, hi; final boolean fromStart, toEnd; final boolean loInclusive, hiInclusive; // 构造函数 NavigableSubMap(TreeMap&lt;K,V&gt; m, boolean fromStart, K lo, boolean loInclusive, boolean toEnd, K hi, boolean hiInclusive) &#123; if (!fromStart &amp;&amp; !toEnd) &#123; if (m.compare(lo, hi) &gt; 0) throw new IllegalArgumentException("fromKey &gt; toKey"); &#125; else &#123; if (!fromStart) // type check m.compare(lo, lo); if (!toEnd) m.compare(hi, hi); &#125; this.m = m; this.fromStart = fromStart; this.lo = lo; this.loInclusive = loInclusive; this.toEnd = toEnd; this.hi = hi; this.hiInclusive = hiInclusive; &#125; // 判断key是否太小 final boolean tooLow(Object key) &#123; // 若该SubMap不包括“起始节点”， // 并且，“key小于最小键(lo)”或者“key等于最小键(lo)，但最小键却没包括在该SubMap内” // 则判断key太小。其余情况都不是太小！ if (!fromStart) &#123; int c = m.compare(key, lo); if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive)) return true; &#125; return false; &#125; // 判断key是否太大 final boolean tooHigh(Object key) &#123; // 若该SubMap不包括“结束节点”， // 并且，“key大于最大键(hi)”或者“key等于最大键(hi)，但最大键却没包括在该SubMap内” // 则判断key太大。其余情况都不是太大！ if (!toEnd) &#123; int c = m.compare(key, hi); if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive)) return true; &#125; return false; &#125; // 判断key是否在“lo和hi”开区间范围内 final boolean inRange(Object key) &#123; return !tooLow(key) &amp;&amp; !tooHigh(key); &#125; // 判断key是否在封闭区间内 final boolean inClosedRange(Object key) &#123; return (fromStart || m.compare(key, lo) &gt;= 0) &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0); &#125; // 判断key是否在区间内, inclusive是区间开关标志 final boolean inRange(Object key, boolean inclusive) &#123; return inclusive ? inRange(key) : inClosedRange(key); &#125; // 返回最低的Entry final TreeMap.Entry&lt;K,V&gt; absLowest() &#123; // 若“包含起始节点”，则调用getFirstEntry()返回第一个节点 // 否则的话，若包括lo，则调用getCeilingEntry(lo)获取大于/等于lo的最小的Entry; // 否则，调用getHigherEntry(lo)获取大于lo的最小Entry TreeMap.Entry&lt;K,V&gt; e = (fromStart ? m.getFirstEntry() : (loInclusive ? m.getCeilingEntry(lo) : m.getHigherEntry(lo))); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回最高的Entry final TreeMap.Entry&lt;K,V&gt; absHighest() &#123; // 若“包含结束节点”，则调用getLastEntry()返回最后一个节点 // 否则的话，若包括hi，则调用getFloorEntry(hi)获取小于/等于hi的最大的Entry; // 否则，调用getLowerEntry(hi)获取大于hi的最大Entry TreeMap.Entry&lt;K,V&gt; e = TreeMap.Entry&lt;K,V&gt; e = (toEnd ? m.getLastEntry() : (hiInclusive ? m.getFloorEntry(hi) : m.getLowerEntry(hi))); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"大于/等于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于/等于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了！ if (tooLow(key)) return absLowest(); // 获取“大于/等于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"大于key的最小的Entry" final TreeMap.Entry&lt;K,V&gt; absHigher(K key) &#123; // 只有在“key太小”的情况下，absLowest()返回的Entry才是“大于key的最小Entry” // 其它情况下不行。例如，当包含“起始节点”时，absLowest()返回的是最小Entry了,而不一定是“大于key的最小Entry”！ if (tooLow(key)) return absLowest(); // 获取“大于key的最小Entry” TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key); return (e == null || tooHigh(e.key)) ? null : e; &#125; // 返回"小于/等于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absFloor(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于/等于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了！ if (tooHigh(key)) return absHighest(); // 获取"小于/等于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回"小于key的最大的Entry" final TreeMap.Entry&lt;K,V&gt; absLower(K key) &#123; // 只有在“key太大”的情况下，(absHighest)返回的Entry才是“小于key的最大Entry” // 其它情况下不行。例如，当包含“结束节点”时，absHighest()返回的是最大Entry了,而不一定是“小于key的最大Entry”！ if (tooHigh(key)) return absHighest(); // 获取"小于key的最大的Entry" TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key); return (e == null || tooLow(e.key)) ? null : e; &#125; // 返回“大于最大节点中的最小节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absHighFence() &#123; return (toEnd ? null : (hiInclusive ? m.getHigherEntry(hi) : m.getCeilingEntry(hi))); &#125; // 返回“小于最小节点中的最大节点”，不存在的话，返回null final TreeMap.Entry&lt;K,V&gt; absLowFence() &#123; return (fromStart ? null : (loInclusive ? m.getLowerEntry(lo) : m.getFloorEntry(lo))); &#125; // 下面几个abstract方法是需要NavigableSubMap的实现类实现的方法 abstract TreeMap.Entry&lt;K,V&gt; subLowest(); abstract TreeMap.Entry&lt;K,V&gt; subHighest(); abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key); abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key); abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key); abstract TreeMap.Entry&lt;K,V&gt; subLower(K key); // 返回“顺序”的键迭代器 abstract Iterator&lt;K&gt; keyIterator(); // 返回“逆序”的键迭代器 abstract Iterator&lt;K&gt; descendingKeyIterator(); // 返回SubMap是否为空。空的话，返回true，否则返回false public boolean isEmpty() &#123; return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty(); &#125; // 返回SubMap的大小 public int size() &#123; return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size(); &#125; // 返回SubMap是否包含键key public final boolean containsKey(Object key) &#123; return inRange(key) &amp;&amp; m.containsKey(key); &#125; // 将key-value 插入SubMap中 public final V put(K key, V value) &#123; if (!inRange(key)) throw new IllegalArgumentException("key out of range"); return m.put(key, value); &#125; // 获取key对应值 public final V get(Object key) &#123; return !inRange(key)? null : m.get(key); &#125; // 删除key对应的键值对 public final V remove(Object key) &#123; return !inRange(key)? null : m.remove(key); &#125; // 获取“大于/等于key的最小键值对” public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) &#123; return exportEntry(subCeiling(key)); &#125; // 获取“大于/等于key的最小键” public final K ceilingKey(K key) &#123; return keyOrNull(subCeiling(key)); &#125; // 获取“大于key的最小键值对” public final Map.Entry&lt;K,V&gt; higherEntry(K key) &#123; return exportEntry(subHigher(key)); &#125; // 获取“大于key的最小键” public final K higherKey(K key) &#123; return keyOrNull(subHigher(key)); &#125; // 获取“小于/等于key的最大键值对” public final Map.Entry&lt;K,V&gt; floorEntry(K key) &#123; return exportEntry(subFloor(key)); &#125; // 获取“小于/等于key的最大键” public final K floorKey(K key) &#123; return keyOrNull(subFloor(key)); &#125; // 获取“小于key的最大键值对” public final Map.Entry&lt;K,V&gt; lowerEntry(K key) &#123; return exportEntry(subLower(key)); &#125; // 获取“小于key的最大键” public final K lowerKey(K key) &#123; return keyOrNull(subLower(key)); &#125; // 获取"SubMap的第一个键" public final K firstKey() &#123; return key(subLowest()); &#125; // 获取"SubMap的最后一个键" public final K lastKey() &#123; return key(subHighest()); &#125; // 获取"SubMap的第一个键值对" public final Map.Entry&lt;K,V&gt; firstEntry() &#123; return exportEntry(subLowest()); &#125; // 获取"SubMap的最后一个键值对" public final Map.Entry&lt;K,V&gt; lastEntry() &#123; return exportEntry(subHighest()); &#125; // 返回"SubMap的第一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollFirstEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subLowest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // 返回"SubMap的最后一个键值对"，并从SubMap中删除改键值对 public final Map.Entry&lt;K,V&gt; pollLastEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = subHighest(); Map.Entry&lt;K,V&gt; result = exportEntry(e); if (e != null) m.deleteEntry(e); return result; &#125; // Views transient NavigableMap&lt;K,V&gt; descendingMapView = null; transient EntrySetView entrySetView = null; transient KeySet&lt;K&gt; navigableKeySetView = null; // 返回NavigableSet对象，实际上返回的是当前对象的"Key集合"。 public final NavigableSet&lt;K&gt; navigableKeySet() &#123; KeySet&lt;K&gt; nksv = navigableKeySetView; return (nksv != null) ? nksv : (navigableKeySetView = new TreeMap.KeySet(this)); &#125; // 返回"Key集合"对象 public final Set&lt;K&gt; keySet() &#123; return navigableKeySet(); &#125; // 返回“逆序”的Key集合 public NavigableSet&lt;K&gt; descendingKeySet() &#123; return descendingMap().navigableKeySet(); &#125; // 排列fromKey(包含) 到 toKey(不包含) 的子map public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) &#123; return subMap(fromKey, true, toKey, false); &#125; // 返回当前Map的头部(从第一个节点 到 toKey, 不包括toKey) public final SortedMap&lt;K,V&gt; headMap(K toKey) &#123; return headMap(toKey, false); &#125; // 返回当前Map的尾部[从 fromKey(包括fromKeyKey) 到 最后一个节点] public final SortedMap&lt;K,V&gt; tailMap(K fromKey) &#123; return tailMap(fromKey, true); &#125; // Map的Entry的集合 abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; private transient int size = -1, sizeModCount; // 获取EntrySet的大小 public int size() &#123; // 若SubMap是从“开始节点”到“结尾节点”，则SubMap大小就是原TreeMap的大小 if (fromStart &amp;&amp; toEnd) return m.size(); // 若SubMap不是从“开始节点”到“结尾节点”，则调用iterator()遍历EntrySetView中的元素 if (size == -1 || sizeModCount != m.modCount) &#123; sizeModCount = m.modCount; size = 0; Iterator i = iterator(); while (i.hasNext()) &#123; size++; i.next(); &#125; &#125; return size; &#125; // 判断EntrySetView是否为空 public boolean isEmpty() &#123; TreeMap.Entry&lt;K,V&gt; n = absLowest(); return n == null || tooHigh(n.key); &#125; // 判断EntrySetView是否包含Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry node = m.getEntry(key); return node != null &amp;&amp; valEquals(node.getValue(), entry.getValue()); &#125; // 从EntrySetView中删除Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); if (!inRange(key)) return false; TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key); if (node!=null &amp;&amp; valEquals(node.getValue(),entry.getValue()))&#123; m.deleteEntry(node); return true; &#125; return false; &#125; &#125; // SubMap的迭代器 abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; &#123; // 上一次被返回的Entry TreeMap.Entry&lt;K,V&gt; lastReturned; // 指向下一个Entry TreeMap.Entry&lt;K,V&gt; next; // “栅栏key”。根据SubMap是“升序”还是“降序”具有不同的意义 final K fenceKey; int expectedModCount; // 构造函数 SubMapIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; // 每创建一个SubMapIterator时，保存修改次数 // 若后面发现expectedModCount和modCount不相等，则抛出ConcurrentModificationException异常。 // 这就是所说的fast-fail机制的原理！ expectedModCount = m.modCount; lastReturned = null; next = first; fenceKey = fence == null ? null : fence.key; &#125; // 是否存在下一个Entry public final boolean hasNext() &#123; return next != null &amp;&amp; next.key != fenceKey; &#125; // 返回下一个Entry final TreeMap.Entry&lt;K,V&gt; nextEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的后继节点 next = successor(e); lastReturned = e; return e; &#125; // 返回上一个Entry final TreeMap.Entry&lt;K,V&gt; prevEntry() &#123; TreeMap.Entry&lt;K,V&gt; e = next; if (e == null || e.key == fenceKey) throw new NoSuchElementException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // next指向e的前继节点 next = predecessor(e); lastReturned = e; return e; &#125; // 删除当前节点(用于“升序的SubMap”)。 // 删除之后，可以继续升序遍历；红黑树特性没变。 final void removeAscending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); // 这里重点强调一下“为什么当lastReturned的左右孩子都不为空时，要将其赋值给next”。 // 目的是为了“删除lastReturned节点之后，next节点指向的仍然是下一个节点”。 // 根据“红黑树”的特性可知： // 当被删除节点有两个儿子时。那么，首先把“它的后继节点的内容”复制给“该节点的内容”；之后，删除“它的后继节点”。 // 这意味着“当被删除节点有两个儿子时，删除当前节点之后，'新的当前节点'实际上是‘原有的后继节点(即下一个节点)’”。 // 而此时next仍然指向"新的当前节点"。也就是说next是仍然是指向下一个节点；能继续遍历红黑树。 if (lastReturned.left != null &amp;&amp; lastReturned.right != null) next = lastReturned; m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; // 删除当前节点(用于“降序的SubMap”)。 // 删除之后，可以继续降序遍历；红黑树特性没变。 final void removeDescending() &#123; if (lastReturned == null) throw new IllegalStateException(); if (m.modCount != expectedModCount) throw new ConcurrentModificationException(); m.deleteEntry(lastReturned); lastReturned = null; expectedModCount = m.modCount; &#125; &#125; // SubMap的Entry迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // SubMap的Key迭代器，它只支持升序操作，继承于SubMapIterator final class SubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(first, fence); &#125; // 获取下一个节点(升序) public K next() &#123; return nextEntry().key; &#125; // 删除当前节点(升序) public void remove() &#123; removeAscending(); &#125; &#125; // 降序SubMap的Entry迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public Map.Entry&lt;K,V&gt; next() &#123; return prevEntry(); &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125; // 降序SubMap的Key迭代器，它只支持降序操作，继承于SubMapIterator final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt; &#123; DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last, TreeMap.Entry&lt;K,V&gt; fence) &#123; super(last, fence); &#125; // 获取下一个节点(降序) public K next() &#123; return prevEntry().key; &#125; // 删除当前节点(降序) public void remove() &#123; removeDescending(); &#125; &#125;&#125; NavigableSubMap源码很多，但不难理解；读者可以通过源码和注释进行理解。 其实，读完NavigableSubMap的源码后，我们可以得出它的核心思想是：它是一个抽象集合类，为2个子类——“(升序)AscendingSubMap”和”(降序)DescendingSubMap”而服务；因为NavigableSubMap实现了许多公共API。它的最终目的是实现下面的一系列函数： 12345678headMap(K toKey, boolean inclusive) headMap(K toKey)subMap(K fromKey, K toKey)subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)tailMap(K fromKey)tailMap(K fromKey, boolean inclusive)navigableKeySet() descendingKeySet() TreeMap其它函数1 顺序遍历和逆序遍历TreeMap的顺序遍历和逆序遍历原理非常简单。由于TreeMap中的元素是从小到大的顺序排列的。因此，顺序遍历，就是从第一个元素开始，逐个向后遍历；而倒序遍历则恰恰相反，它是从最后一个元素开始，逐个往前遍历。 我们可以通过 keyIterator() 和 descendingKeyIterator()来说明！keyIterator()的作用是返回顺序的KEY的集合，descendingKeyIterator()的作用是返回逆序的KEY的集合。 12345keyIterator() 的代码如下：Iterator&lt;K&gt; keyIterator() &#123; return new KeyIterator(getFirstEntry());&#125; 说明：从中我们可以看出keyIterator() 是返回以“第一个节点(getFirstEntry)” 为其实元素的迭代器。KeyIterator的代码如下： 12345678final class KeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; KeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return nextEntry().key; &#125;&#125; 说明：KeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，就是执行的顺序遍历了。 descendingKeyIterator()的代码如下： 123Iterator&lt;K&gt; descendingKeyIterator() &#123; return new DescendingKeyIterator(getLastEntry());&#125; 说明：从中我们可以看出descendingKeyIterator() 是返回以“最后一个节点(getLastEntry)” 为其实元素的迭代器。再看看DescendingKeyIterator的代码： 12345678final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; &#123; DescendingKeyIterator(Entry&lt;K,V&gt; first) &#123; super(first); &#125; public K next() &#123; return prevEntry().key; &#125;&#125; 说明：DescendingKeyIterator继承于PrivateEntryIterator。当我们通过next()不断获取下一个元素的时候，实际上调用的是prevEntry()获取的上一个节点，这样它实际上执行的是逆序遍历了。 至此，TreeMap的相关内容就全部介绍完毕了。若有错误或纰漏的地方，欢迎指正！ TreeMap遍历方式遍历TreeMap的键值对第一步：根据entrySet()获取TreeMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 4.2 遍历TreeMap的键第一步：根据keySet()获取TreeMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 4.3 遍历TreeMap的值第一步：根据value()获取TreeMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是TreeMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; TreeMap遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.TreeMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历TreeMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorTreeMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorTreeMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorTreeMapJustValues() * * @author skywang */public class TreeMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); TreeMap map = new TreeMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到TreeMap中 map.put(key, value); System.out.println(&quot; key:&quot;+key+&quot; value:&quot;+value); &#125; // 通过entrySet()遍历TreeMap的key-value iteratorTreeMapByEntryset(map) ; // 通过keySet()遍历TreeMap的key-value iteratorTreeMapByKeyset(map) ; // 单单遍历TreeMap的value iteratorTreeMapJustValues(map); &#125; /* * 通过entry set遍历TreeMap * 效率高! */ private static void iteratorTreeMapByEntryset(TreeMap map) &#123; if (map == null) return ; System.out.println(&quot;\niterator TreeMap By entryset&quot;); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+&quot; -- &quot;+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历TreeMap * 效率低! */ private static void iteratorTreeMapByKeyset(TreeMap map) &#123; if (map == null) return ; System.out.println(&quot;\niterator TreeMap By keyset&quot;); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+&quot; -- &quot;+integ.intValue()); &#125; &#125; /* * 遍历TreeMap的values */ private static void iteratorTreeMapJustValues(TreeMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; TreeMap示例下面通过实例来学习如何使用TreeMap 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151import java.util.*;/** * @desc TreeMap测试程序 * * @author skywang */public class TreeMapTest &#123; public static void main(String[] args) &#123; // 测试常用的API testTreeMapOridinaryAPIs(); // 测试TreeMap的导航函数 //testNavigableMapAPIs(); // 测试TreeMap的子Map函数 //testSubMapAPIs(); &#125; /** * 测试常用的API */ private static void testTreeMapOridinaryAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加操作 tmap.put("one", r.nextInt(10)); tmap.put("two", r.nextInt(10)); tmap.put("three", r.nextInt(10)); System.out.printf("\n ---- testTreeMapOridinaryAPIs ----\n"); // 打印出TreeMap System.out.printf("%s\n",tmap ); // 通过Iterator遍历key-value Iterator iter = tmap.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.printf("next : %s - %s\n", entry.getKey(), entry.getValue()); &#125; // TreeMap的键值对个数 System.out.printf("size: %s\n", tmap.size()); // containsKey(Object key) :是否包含键key System.out.printf("contains key two : %s\n",tmap.containsKey("two")); System.out.printf("contains key five : %s\n",tmap.containsKey("five")); // containsValue(Object value) :是否包含值value System.out.printf("contains value 0 : %s\n",tmap.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 tmap.remove("three"); System.out.printf("tmap:%s\n",tmap ); // clear() ： 清空TreeMap tmap.clear(); // isEmpty() : TreeMap是否为空 System.out.printf("%s\n", (tmap.isEmpty()?"tmap is empty":"tmap is not empty") ); &#125; /** * 测试TreeMap的子Map函数 */ public static void testSubMapAPIs() &#123; // 新建TreeMap TreeMap tmap = new TreeMap(); // 添加“键值对” tmap.put("a", 101); tmap.put("b", 102); tmap.put("c", 103); tmap.put("d", 104); tmap.put("e", 105); System.out.printf("\n ---- testSubMapAPIs ----\n"); // 打印出TreeMap System.out.printf("tmap:\n\t%s\n", tmap); // 测试 headMap(K toKey) System.out.printf("tmap.headMap(\"c\"):\n\t%s\n", tmap.headMap("c")); // 测试 headMap(K toKey, boolean inclusive) System.out.printf("tmap.headMap(\"c\", true):\n\t%s\n", tmap.headMap("c", true)); System.out.printf("tmap.headMap(\"c\", false):\n\t%s\n", tmap.headMap("c", false)); // 测试 tailMap(K fromKey) System.out.printf("tmap.tailMap(\"c\"):\n\t%s\n", tmap.tailMap("c")); // 测试 tailMap(K fromKey, boolean inclusive) System.out.printf("tmap.tailMap(\"c\", true):\n\t%s\n", tmap.tailMap("c", true)); System.out.printf("tmap.tailMap(\"c\", false):\n\t%s\n", tmap.tailMap("c", false)); // 测试 subMap(K fromKey, K toKey) System.out.printf("tmap.subMap(\"a\", \"c\"):\n\t%s\n", tmap.subMap("a", "c")); // 测试 System.out.printf("tmap.subMap(\"a\", true, \"c\", true):\n\t%s\n", tmap.subMap("a", true, "c", true)); System.out.printf("tmap.subMap(\"a\", true, \"c\", false):\n\t%s\n", tmap.subMap("a", true, "c", false)); System.out.printf("tmap.subMap(\"a\", false, \"c\", true):\n\t%s\n", tmap.subMap("a", false, "c", true)); System.out.printf("tmap.subMap(\"a\", false, \"c\", false):\n\t%s\n", tmap.subMap("a", false, "c", false)); // 测试 navigableKeySet() System.out.printf("tmap.navigableKeySet():\n\t%s\n", tmap.navigableKeySet()); // 测试 descendingKeySet() System.out.printf("tmap.descendingKeySet():\n\t%s\n", tmap.descendingKeySet()); &#125; /** * 测试TreeMap的导航函数 */ public static void testNavigableMapAPIs() &#123; // 新建TreeMap NavigableMap nav = new TreeMap(); // 添加“键值对” nav.put("aaa", 111); nav.put("bbb", 222); nav.put("eee", 333); nav.put("ccc", 555); nav.put("ddd", 444); System.out.printf("\n ---- testNavigableMapAPIs ----\n"); // 打印出TreeMap System.out.printf("Whole list:%s%n", nav); // 获取第一个key、第一个Entry System.out.printf("First key: %s\tFirst entry: %s%n",nav.firstKey(), nav.firstEntry()); // 获取最后一个key、最后一个Entry System.out.printf("Last key: %s\tLast entry: %s%n",nav.lastKey(), nav.lastEntry()); // 获取“小于/等于bbb”的最大键值对 System.out.printf("Key floor before bbb: %s%n",nav.floorKey("bbb")); // 获取“小于bbb”的最大键值对 System.out.printf("Key lower before bbb: %s%n", nav.lowerKey("bbb")); // 获取“大于/等于bbb”的最小键值对 System.out.printf("Key ceiling after ccc: %s%n",nav.ceilingKey("ccc")); // 获取“大于bbb”的最小键值对 System.out.printf("Key higher after ccc: %s%n\n",nav.higherKey("ccc")); &#125;&#125; 运行结果： 12345678910&#123;one=8, three=4, two=2&#125;next : one - 8next : three - 4next : two - 2size: 3contains key two : truecontains key five : falsecontains value 0 : falsetmap:&#123;one=8, two=2&#125;tmap is empty]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>TreeMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 HashTable]]></title>
    <url>%2F2015%2F07%2F28%2F8-Collection-Map%2F11-Hashtable%2F</url>
    <content type="text"><![CDATA[Hashtable 简介和HashMap一样，Hashtable 也是一个散列表，它存储的内容是键值对(key-value)映射。 Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。 Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。此外，Hashtable中的映射不是有序的。Hashtable 的实例有两个参数影响其性能：初始容量 和 加载因子。 初始容量 容量是哈希表中桶的数量，初始容量就是哈希表创建时的容量。注意，哈希表的状态为 open：在发生“哈希冲突”的情况下，单个桶会存储多个条目，这些条目必须按顺序搜索。 加载因子 是对哈希表在其容量自动增加之前可以达到多满的一个尺度。初始容量和加载因子这两个参数只是对该实现的提示。关于何时以及是否调用 rehash 方法的具体细节则依赖于该实现。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查找某个条目的时间（在大多数 Hashtable 操作中，包括 get 和 put 操作，都反映了这一点）。 Hashtable的构造函数12345678910111213141516171819202122232425262728293031323334// 默认构造函数。public Hashtable() // 指定“容量大小”的构造函数public Hashtable(int initialCapacity) // 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor) // 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t)``` # Hashtable的API```javasynchronized void clear()synchronized Object clone() boolean contains(Object value)synchronized boolean containsKey(Object key)synchronized boolean containsValue(Object value)synchronized Enumeration&lt;V&gt; elements()synchronized Set&lt;Entry&lt;K, V&gt;&gt; entrySet()synchronized boolean equals(Object object)synchronized V get(Object key)synchronized int hashCode()synchronized boolean isEmpty()synchronized Set&lt;K&gt; keySet()synchronized Enumeration&lt;K&gt; keys()synchronized V put(K key, V value)synchronized void putAll(Map&lt;? extends K, ? extends V&gt; map)synchronized V remove(Object key)synchronized int size()synchronized String toString()synchronized Collection&lt;V&gt; values() Hashtable数据结构Hashtable的继承关系 123456java.lang.Object ↳ java.util.Dictionary&lt;K, V&gt; ↳ java.util.Hashtable&lt;K, V&gt;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; &#125; Hashtable与Map关系如下图： 从图中可以看出： Hashtable继承于Dictionary类，实现了Map接口。Map是”key-value键值对”接口，Dictionary是声明了操作”键值对”函数接口的抽象类。 Hashtable是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, count, threshold, loadFactor, modCount。 table 是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 count 是Hashtable的大小，它是Hashtable保存的键值对的数量。 threshold 是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值=”容量*加载因子”。 loadFactor 就是加载因子。 modCount 是用来实现fail-fast机制的。 Hashtable源码解析(基于JDK1.6.0_45)为了更了解Hashtable的原理，下面对Hashtable源码代码作出分析。 在阅读源码时，建议参考后面的说明来建立对Hashtable的整体认识，这样更容易理解Hashtable。 说明: 在详细介绍Hashtable的代码之前，我们需要了解：和Hashmap一样，Hashtable也是一个散列表，它也是通过“拉链法”解决哈希冲突的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792package java.util;import java.io.*;public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable &#123; // Hashtable保存key-value的数组。 // Hashtable是采用拉链法实现的，每一个Entry本质上是一个单向链表 private transient Entry[] table; // Hashtable中元素的实际数量 private transient int count; // 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子） private int threshold; // 加载因子 private float loadFactor; // Hashtable被改变的次数 private transient int modCount = 0; // 序列版本号 private static final long serialVersionUID = 1421746759512286392L; // 指定“容量大小”和“加载因子”的构造函数 public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor); &#125; // 指定“容量大小”的构造函数 public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f); &#125; // 默认构造函数。 public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f); &#125; // 包含“子Map”的构造函数 public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t); &#125; public synchronized int size() &#123; return count; &#125; public synchronized boolean isEmpty() &#123; return count == 0; &#125; // 返回“所有key”的枚举对象 public synchronized Enumeration&lt;K&gt; keys() &#123; return this.&lt;K&gt;getEnumeration(KEYS); &#125; // 返回“所有value”的枚举对象 public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES); &#125; // 判断Hashtable是否包含“值(value)” public synchronized boolean contains(Object value) &#123; // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false; &#125; public boolean containsValue(Object value) &#123; return contains(value); &#125; // 判断Hashtable是否包含key public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false; &#125; // 返回key对应的value，没有的话返回null public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null; &#125; // 调整Hashtable的长度，将长度变成原来的(2倍+1) // (01) 将“旧的Entry数组”赋值给一个临时变量。 // (02) 创建一个“新的Entry数组”，并赋值给“旧的Entry数组” // (03) 将“Hashtable”中的全部元素依次添加到“新的Entry数组”中 protected void rehash() &#123; int oldCapacity = table.length; Entry[] oldMap = table; int newCapacity = oldCapacity * 2 + 1; Entry[] newMap = new Entry[newCapacity]; modCount++; threshold = (int)(newCapacity * loadFactor); table = newMap; for (int i = oldCapacity ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; old = oldMap[i] ; old != null ; ) &#123; Entry&lt;K,V&gt; e = old; old = old.next; int index = (e.hash &amp; 0x7FFFFFFF) % newCapacity; e.next = newMap[index]; newMap[index] = e; &#125; &#125; &#125; // 将“key-value”添加到Hashtable中 public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null; &#125; // 删除Hashtable中键为key的元素 public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null; &#125; // 将“Map(t)”的中全部元素逐一添加到Hashtable中 public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue()); &#125; // 清空Hashtable // 将Hashtable的table数组的值全部设为null public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0; &#125; // 克隆一个Hashtable，并以Object的形式返回。 public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; public synchronized String toString() &#123; int max = size() - 1; if (max == -1) return "&#123;&#125;"; StringBuilder sb = new StringBuilder(); Iterator&lt;Map.Entry&lt;K,V&gt;&gt; it = entrySet().iterator(); sb.append('&#123;'); for (int i = 0; ; i++) &#123; Map.Entry&lt;K,V&gt; e = it.next(); K key = e.getKey(); V value = e.getValue(); sb.append(key == this ? "(this Map)" : key.toString()); sb.append('='); sb.append(value == this ? "(this Map)" : value.toString()); if (i == max) return sb.append('&#125;').toString(); sb.append(", "); &#125; &#125; // 获取Hashtable的枚举类对象 // 若Hashtable的实际大小为0,则返回“空枚举类”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125; &#125; // 获取Hashtable的迭代器 // 若Hashtable的实际大小为0,则返回“空迭代器”对象； // 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) private &lt;T&gt; Iterator&lt;T&gt; getIterator(int type) &#123; if (count == 0) &#123; return (Iterator&lt;T&gt;) emptyIterator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, true); &#125; &#125; // Hashtable的“key的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;K&gt; keySet = null; // Hashtable的“key-value的集合”。它是一个Set，意味着没有重复元素 private transient volatile Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // Hashtable的“key-value的集合”。它是一个Collection，意味着可以有重复元素 private transient volatile Collection&lt;V&gt; values = null; // 返回一个被synchronizedSet封装后的KeySet对象 // synchronizedSet封装的目的是对KeySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;K&gt; keySet() &#123; if (keySet == null) keySet = Collections.synchronizedSet(new KeySet(), this); return keySet; &#125; // Hashtable的Key的Set集合。 // KeySet继承于AbstractSet，所以，KeySet中的元素没有重复的。 private class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return getIterator(KEYS); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return Hashtable.this.remove(o) != null; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedSet封装后的EntrySet对象 // synchronizedSet封装的目的是对EntrySet的所有方法都添加synchronized，实现多线程同步 public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; if (entrySet==null) entrySet = Collections.synchronizedSet(new EntrySet(), this); return entrySet; &#125; // Hashtable的Entry的Set集合。 // EntrySet继承于AbstractSet，所以，EntrySet中的元素没有重复的。 private class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return getIterator(ENTRIES); &#125; public boolean add(Map.Entry&lt;K,V&gt; o) &#123; return super.add(o); &#125; // 查找EntrySet中是否包含Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，查找Entry链表中是否存在Object public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry entry = (Map.Entry)o; Object key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry e = tab[index]; e != null; e = e.next) if (e.hash==hash &amp;&amp; e.equals(entry)) return true; return false; &#125; // 删除元素Object(0) // 首先，在table中找到o对应的Entry(Entry是一个单向链表) // 然后，删除链表中的元素Object public boolean remove(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; K key = entry.getKey(); Entry[] tab = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e.hash==hash &amp;&amp; e.equals(entry)) &#123; modCount++; if (prev != null) prev.next = e.next; else tab[index] = e.next; count--; e.value = null; return true; &#125; &#125; return false; &#125; public int size() &#123; return count; &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 返回一个被synchronizedCollection封装后的ValueCollection对象 // synchronizedCollection封装的目的是对ValueCollection的所有方法都添加synchronized，实现多线程同步 public Collection&lt;V&gt; values() &#123; if (values==null) values = Collections.synchronizedCollection(new ValueCollection(), this); return values; &#125; // Hashtable的value的Collection集合。 // ValueCollection继承于AbstractCollection，所以，ValueCollection中的元素可以重复的。 private class ValueCollection extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return getIterator(VALUES); &#125; public int size() &#123; return count; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; Hashtable.this.clear(); &#125; &#125; // 重新equals()函数 // 若两个Hashtable的所有key-value键值对都相等，则判断它们两个相等 public synchronized boolean equals(Object o) &#123; if (o == this) return true; if (!(o instanceof Map)) return false; Map&lt;K,V&gt; t = (Map&lt;K,V&gt;) o; if (t.size() != size()) return false; try &#123; // 通过迭代器依次取出当前Hashtable的key-value键值对 // 并判断该键值对，存在于Hashtable(o)中。 // 若不存在，则立即返回false；否则，遍历完“当前Hashtable”并返回true。 Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); K key = e.getKey(); V value = e.getValue(); if (value == null) &#123; if (!(t.get(key)==null &amp;&amp; t.containsKey(key))) return false; &#125; else &#123; if (!value.equals(t.get(key))) return false; &#125; &#125; &#125; catch (ClassCastException unused) &#123; return false; &#125; catch (NullPointerException unused) &#123; return false; &#125; return true; &#125; // 计算Hashtable的哈希值 // 若 Hashtable的实际大小为0 或者 加载因子&lt;0，则返回0。 // 否则，返回“Hashtable中的每个Entry的key和value的异或值 的总和”。 public synchronized int hashCode() &#123; int h = 0; if (count == 0 || loadFactor &lt; 0) return h; // Returns zero loadFactor = -loadFactor; // Mark hashCode computation in progress Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) for (Entry e = tab[i]; e != null; e = e.next) h += e.key.hashCode() ^ e.value.hashCode(); loadFactor = -loadFactor; // Mark hashCode computation complete return h; &#125; // java.io.Serializable的写入函数 // 将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中 private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table; &#125; private void reconstitutionPut(Entry[] tab, K key, V value) throws StreamCorruptedException &#123; if (value == null) &#123; throw new java.io.StreamCorruptedException(); &#125; // Makes sure the key is not already in the hashtable. // This should not happen in deserialized version. int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; throw new java.io.StreamCorruptedException(); &#125; &#125; // Creates the new entry. Entry&lt;K,V&gt; e = tab[index]; tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); count++; &#125; // Hashtable的Entry节点，它本质上是一个单向链表。 // 也因此，我们才能推断出Hashtable是由拉链法实现的散列表 private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+"="+value.toString(); &#125; &#125; private static final int KEYS = 0; private static final int VALUES = 1; private static final int ENTRIES = 2; // Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException("Hashtable Enumerator"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException("Hashtable Enumerator"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125; &#125; private static Enumeration emptyEnumerator = new EmptyEnumerator(); private static Iterator emptyIterator = new EmptyIterator(); // 空枚举类 // 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。 private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException("Hashtable Enumerator"); &#125; &#125; // 空迭代器 // 当Hashtable的实际大小为0；此时，又要通过迭代器遍历Hashtable时，返回的是“空迭代器”的对象。 private static class EmptyIterator implements Iterator&lt;Object&gt; &#123; EmptyIterator() &#123; &#125; public boolean hasNext() &#123; return false; &#125; public Object next() &#123; throw new NoSuchElementException("Hashtable Iterator"); &#125; public void remove() &#123; throw new IllegalStateException("Hashtable Iterator"); &#125; &#125;&#125; Hashtable的“拉链法”相关内容Hashtable数据存储数组1private transient Entry[] table; Hashtable中的key-value都是存储在table数组中的。 数据节点Entry的数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // 哈希值 int hash; K key; V value; // 指向的下一个Entry，即链表的下一个节点 Entry&lt;K,V&gt; next; // 构造函数 protected Entry(int hash, K key, V value, Entry&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; protected Object clone() &#123; return new Entry&lt;K,V&gt;(hash, key, value, (next==null ? null : (Entry&lt;K,V&gt;) next.clone())); &#125; public K getKey() &#123; return key; &#125; public V getValue() &#123; return value; &#125; // 设置value。若value是null，则抛出异常。 public V setValue(V value) &#123; if (value == null) throw new NullPointerException(); V oldValue = this.value; this.value = value; return oldValue; &#125; // 覆盖equals()方法，判断两个Entry是否相等。 // 若两个Entry的key和value都相等，则认为它们相等。 public boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; return (key==null ? e.getKey()==null : key.equals(e.getKey())) &amp;&amp; (value==null ? e.getValue()==null : value.equals(e.getValue())); &#125; public int hashCode() &#123; return hash ^ (value==null ? 0 : value.hashCode()); &#125; public String toString() &#123; return key.toString()+"="+value.toString(); &#125;&#125; 从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说Hashtable是通过拉链法解决哈希冲突的。 Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 Hashtable的构造函数Hashtable共包括4个构造函数 1234567891011121314151617181920212223242526272829303132// 默认构造函数。public Hashtable() &#123; // 默认构造函数，指定的容量大小是11；加载因子是0.75 this(11, 0.75f);&#125;// 指定“容量大小”的构造函数public Hashtable(int initialCapacity) &#123; this(initialCapacity, 0.75f);&#125;// 指定“容量大小”和“加载因子”的构造函数public Hashtable(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load: "+loadFactor); if (initialCapacity==0) initialCapacity = 1; this.loadFactor = loadFactor; table = new Entry[initialCapacity]; threshold = (int)(initialCapacity * loadFactor);&#125;// 包含“子Map”的构造函数public Hashtable(Map&lt;? extends K, ? extends V&gt; t) &#123; this(Math.max(2*t.size(), 11), 0.75f); // 将“子Map”的全部元素都添加到Hashtable中 putAll(t);&#125; Hashtable的主要对外接口clear()clear() 的作用是清空Hashtable。它是将Hashtable的table数组的值全部设为null 1234567public synchronized void clear() &#123; Entry tab[] = table; modCount++; for (int index = tab.length; --index &gt;= 0; ) tab[index] = null; count = 0;&#125; contains() 和 containsValue()contains() 和 containsValue() 的作用都是判断Hashtable是否包含“值(value)” 1234567891011121314151617181920212223public boolean containsValue(Object value) &#123; return contains(value);&#125;public synchronized boolean contains(Object value) &#123; // Hashtable中“键值对”的value不能是null， // 若是null的话，抛出异常! if (value == null) &#123; throw new NullPointerException(); &#125; // 从后向前遍历table数组中的元素(Entry) // 对于每个Entry(单向链表)，逐个遍历，判断节点的值是否等于value Entry tab[] = table; for (int i = tab.length ; i-- &gt; 0 ;) &#123; for (Entry&lt;K,V&gt; e = tab[i] ; e != null ; e = e.next) &#123; if (e.value.equals(value)) &#123; return true; &#125; &#125; &#125; return false;&#125; containsKey()containsKey() 的作用是判断Hashtable是否包含key 1234567891011121314public synchronized boolean containsKey(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， // % tab.length 的目的是防止数据越界 int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return true; &#125; &#125; return false;&#125; elements()elements() 的作用是返回“所有value”的枚举对象 123456789101112public synchronized Enumeration&lt;V&gt; elements() &#123; return this.&lt;V&gt;getEnumeration(VALUES);&#125;// 获取Hashtable的枚举类对象private &lt;T&gt; Enumeration&lt;T&gt; getEnumeration(int type) &#123; if (count == 0) &#123; return (Enumeration&lt;T&gt;)emptyEnumerator; &#125; else &#123; return new Enumerator&lt;T&gt;(type, false); &#125;&#125; 从中，我们可以看出： 若Hashtable的实际大小为0,则返回“空枚举类”对象emptyEnumerator； 否则，返回正常的Enumerator的对象。(Enumerator实现了迭代器和枚举两个接口) 我们先看看emptyEnumerator对象是如何实现的 12345678910111213141516171819private static Enumeration emptyEnumerator = new EmptyEnumerator();// 空枚举类// 当Hashtable的实际大小为0；此时，又要通过Enumeration遍历Hashtable时，返回的是“空枚举类”的对象。private static class EmptyEnumerator implements Enumeration&lt;Object&gt; &#123; EmptyEnumerator() &#123; &#125; // 空枚举类的hasMoreElements() 始终返回false public boolean hasMoreElements() &#123; return false; &#125; // 空枚举类的nextElement() 抛出异常 public Object nextElement() &#123; throw new NoSuchElementException("Hashtable Enumerator"); &#125;&#125; 我们在来看看Enumeration类 Enumerator的作用是提供了“通过elements()遍历Hashtable的接口” 和 “通过entrySet()遍历Hashtable的接口”。因为，它同时实现了 “Enumerator接口”和“Iterator接口”。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104private class Enumerator&lt;T&gt; implements Enumeration&lt;T&gt;, Iterator&lt;T&gt; &#123; // 指向Hashtable的table Entry[] table = Hashtable.this.table; // Hashtable的总的大小 int index = table.length; Entry&lt;K,V&gt; entry = null; Entry&lt;K,V&gt; lastReturned = null; int type; // Enumerator是 “迭代器(Iterator)” 还是 “枚举类(Enumeration)”的标志 // iterator为true，表示它是迭代器；否则，是枚举类。 boolean iterator; // 在将Enumerator当作迭代器使用时会用到，用来实现fail-fast机制。 protected int expectedModCount = modCount; Enumerator(int type, boolean iterator) &#123; this.type = type; this.iterator = iterator; &#125; // 从遍历table的数组的末尾向前查找，直到找到不为null的Entry。 public boolean hasMoreElements() &#123; Entry&lt;K,V&gt; e = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (e == null &amp;&amp; i &gt; 0) &#123; e = t[--i]; &#125; entry = e; index = i; return e != null; &#125; // 获取下一个元素 // 注意：从hasMoreElements() 和nextElement() 可以看出“Hashtable的elements()遍历方式” // 首先，从后向前的遍历table数组。table数组的每个节点都是一个单向链表(Entry)。 // 然后，依次向后遍历单向链表Entry。 public T nextElement() &#123; Entry&lt;K,V&gt; et = entry; int i = index; Entry[] t = table; /* Use locals for faster loop iteration */ while (et == null &amp;&amp; i &gt; 0) &#123; et = t[--i]; &#125; entry = et; index = i; if (et != null) &#123; Entry&lt;K,V&gt; e = lastReturned = entry; entry = e.next; return type == KEYS ? (T)e.key : (type == VALUES ? (T)e.value : (T)e); &#125; throw new NoSuchElementException("Hashtable Enumerator"); &#125; // 迭代器Iterator的判断是否存在下一个元素 // 实际上，它是调用的hasMoreElements() public boolean hasNext() &#123; return hasMoreElements(); &#125; // 迭代器获取下一个元素 // 实际上，它是调用的nextElement() public T next() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); return nextElement(); &#125; // 迭代器的remove()接口。 // 首先，它在table数组中找出要删除元素所在的Entry， // 然后，删除单向链表Entry中的元素。 public void remove() &#123; if (!iterator) throw new UnsupportedOperationException(); if (lastReturned == null) throw new IllegalStateException("Hashtable Enumerator"); if (modCount != expectedModCount) throw new ConcurrentModificationException(); synchronized(Hashtable.this) &#123; Entry[] tab = Hashtable.this.table; int index = (lastReturned.hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index], prev = null; e != null; prev = e, e = e.next) &#123; if (e == lastReturned) &#123; modCount++; expectedModCount++; if (prev == null) tab[index] = e.next; else prev.next = e.next; count--; lastReturned = null; return; &#125; &#125; throw new ConcurrentModificationException(); &#125; &#125;&#125; entrySet(), keySet(), keys(), values()的实现方法和elements()差不多，而且源码中已经明确的给出了注释。这里就不再做过多说明了。 get()get() 的作用就是获取key对应的value，没有的话返回null 12345678910111213public synchronized V get(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); // 计算索引值， int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)”，然后在链表中找出“哈希值”和“键值”与key都相等的元素 for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; return e.value; &#125; &#125; return null;&#125; put()put() 的作用是对外提供接口，让Hashtable对象可以通过put()将“key-value”添加到Hashtable中。 12345678910111213141516171819202122232425262728293031323334353637383940public synchronized V put(K key, V value) &#123; // Hashtable中不能插入value为null的元素！！！ if (value == null) &#123; throw new NullPointerException(); &#125; // 若“Hashtable中已存在键为key的键值对”， // 则用“新的value”替换“旧的value” Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; for (Entry&lt;K,V&gt; e = tab[index] ; e != null ; e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; V old = e.value; e.value = value; return old; &#125; &#125; // 若“Hashtable中不存在键为key的键值对”， // (01) 将“修改统计数”+1 modCount++; // (02) 若“Hashtable实际容量” &gt; “阈值”(阈值=总的容量 * 加载因子) // 则调整Hashtable的大小 if (count &gt;= threshold) &#123; // Rehash the table if the threshold is exceeded rehash(); tab = table; index = (hash &amp; 0x7FFFFFFF) % tab.length; &#125; // (03) 将“Hashtable中index”位置的Entry(链表)保存到e中 Entry&lt;K,V&gt; e = tab[index]; // (04) 创建“新的Entry节点”，并将“新的Entry”插入“Hashtable的index位置”，并设置e为“新的Entry”的下一个元素(即“新Entry”为链表表头)。 tab[index] = new Entry&lt;K,V&gt;(hash, key, value, e); // (05) 将“Hashtable的实际容量”+1 count++; return null;&#125; putAll()putAll() 的作用是将“Map(t)”的中全部元素逐一添加到Hashtable中 1234public synchronized void putAll(Map&lt;? extends K, ? extends V&gt; t) &#123; for (Map.Entry&lt;? extends K, ? extends V&gt; e : t.entrySet()) put(e.getKey(), e.getValue());&#125; remove()remove() 的作用就是删除Hashtable中键为key的元素 12345678910111213141516171819202122public synchronized V remove(Object key) &#123; Entry tab[] = table; int hash = key.hashCode(); int index = (hash &amp; 0x7FFFFFFF) % tab.length; // 找到“key对应的Entry(链表)” // 然后在链表中找出要删除的节点，并删除该节点。 for (Entry&lt;K,V&gt; e = tab[index], prev = null ; e != null ; prev = e, e = e.next) &#123; if ((e.hash == hash) &amp;&amp; e.key.equals(key)) &#123; modCount++; if (prev != null) &#123; prev.next = e.next; &#125; else &#123; tab[index] = e.next; &#125; count--; V oldValue = e.value; e.value = null; return oldValue; &#125; &#125; return null;&#125; Hashtable实现的Cloneable接口Hashtable实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个Hashtable对象并返回。 12345678910111213141516171819// 克隆一个Hashtable，并以Object的形式返回。public synchronized Object clone() &#123; try &#123; Hashtable&lt;K,V&gt; t = (Hashtable&lt;K,V&gt;) super.clone(); t.table = new Entry[table.length]; for (int i = table.length ; i-- &gt; 0 ; ) &#123; t.table[i] = (table[i] != null) ? (Entry&lt;K,V&gt;) table[i].clone() : null; &#125; t.keySet = null; t.entrySet = null; t.values = null; t.modCount = 0; return t; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125;&#125; Hashtable实现的Serializable接口Hashtable实现java.io.Serializable，分别实现了串行读取、写入功能。 串行写入函数就是将Hashtable的“总的容量，实际容量，所有的Entry”都写入到输出流中串行读取函数：根据写入方式读出将Hashtable的“总的容量，实际容量，所有的Entry”依次读出 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private synchronized void writeObject(java.io.ObjectOutputStream s) throws IOException&#123; // Write out the length, threshold, loadfactor s.defaultWriteObject(); // Write out length, count of elements and then the key/value objects s.writeInt(table.length); s.writeInt(count); for (int index = table.length-1; index &gt;= 0; index--) &#123; Entry entry = table[index]; while (entry != null) &#123; s.writeObject(entry.key); s.writeObject(entry.value); entry = entry.next; &#125; &#125;&#125;private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the length, threshold, and loadfactor s.defaultReadObject(); // Read the original length of the array and number of elements int origlength = s.readInt(); int elements = s.readInt(); // Compute new size with a bit of room 5% to grow but // no larger than the original size. Make the length // odd if it's large enough, this helps distribute the entries. // Guard against the length ending up zero, that's not valid. int length = (int)(elements * loadFactor) + (elements / 20) + 3; if (length &gt; elements &amp;&amp; (length &amp; 1) == 0) length--; if (origlength &gt; 0 &amp;&amp; length &gt; origlength) length = origlength; Entry[] table = new Entry[length]; count = 0; // Read the number of elements and then all the key/value objects for (; elements &gt; 0; elements--) &#123; K key = (K)s.readObject(); V value = (V)s.readObject(); // synch could be eliminated for performance reconstitutionPut(table, key, value); &#125; this.table = table;&#125; Hashtable遍历方式遍历Hashtable的键值对第一步：根据entrySet()获取Hashtable的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = table.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 通过Iterator遍历Hashtable的键第一步：根据keySet()获取Hashtable的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = table.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)table.get(key);&#125; 通过Iterator遍历Hashtable的值第一步：根据value()获取Hashtable的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设table是Hashtable对象// table中的key是String类型，value是Integer类型Integer value = null;Collection c = table.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 通过Enumeration遍历Hashtable的键第一步：根据keys()获取Hashtable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。 1234Enumeration enu = table.keys();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125; 通过Enumeration遍历Hashtable的值第一步：根据elements()获取Hashtable的集合。第二步：通过Enumeration遍历“第一步”得到的集合。 1234Enumeration enu = table.elements();while(enu.hasMoreElements()) &#123; System.out.println(enu.nextElement());&#125; 遍历测试程序如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/* * @desc Hashtable的测试程序。 */public class HashtableTest &#123; public static void main(String[] args) &#123; testHashtableAPIs(); &#125; private static void testHashtableAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建Hashtable Hashtable table = new Hashtable(); // 添加操作 table.put("one", r.nextInt(10)); table.put("two", r.nextInt(10)); table.put("three", r.nextInt(10)); // 打印出table System.out.println("table:"+table ); // 通过Iterator遍历key-value Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println("next : "+ entry.getKey() +" - "+entry.getValue()); &#125; // Hashtable的键值对个数 System.out.println("size:"+table.size()); // containsKey(Object key) :是否包含键key System.out.println("contains key two : "+table.containsKey("two")); System.out.println("contains key five : "+table.containsKey("five")); // containsValue(Object value) :是否包含值value System.out.println("contains value 0 : "+table.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 table.remove("three"); System.out.println("table:"+table ); // clear() ： 清空Hashtable table.clear(); // isEmpty() : Hashtable是否为空 System.out.println((table.isEmpty()?"table is empty":"table is not empty") ); &#125;&#125; Hashtable示例下面通过一个实例来学习如何使用Hashtable。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.*;/* * @desc Hashtable的测试程序。 */public class HashtableTest &#123; public static void main(String[] args) &#123; testHashtableAPIs(); &#125; private static void testHashtableAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建Hashtable Hashtable table = new Hashtable(); // 添加操作 table.put("one", r.nextInt(10)); table.put("two", r.nextInt(10)); table.put("three", r.nextInt(10)); // 打印出table System.out.println("table:"+table ); // 通过Iterator遍历key-value Iterator iter = table.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println("next : "+ entry.getKey() +" - "+entry.getValue()); &#125; // Hashtable的键值对个数 System.out.println("size:"+table.size()); // containsKey(Object key) :是否包含键key System.out.println("contains key two : "+table.containsKey("two")); System.out.println("contains key five : "+table.containsKey("five")); // containsValue(Object value) :是否包含值value System.out.println("contains value 0 : "+table.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 table.remove("three"); System.out.println("table:"+table ); // clear() ： 清空Hashtable table.clear(); // isEmpty() : Hashtable是否为空 System.out.println((table.isEmpty()?"table is empty":"table is not empty") ); &#125;&#125; (某一次)运行结果： 12345678910table:&#123;two=5, one=0, three=6&#125;next : two - 5next : one - 0next : three - 6size:3contains key two : truecontains key five : falsecontains value 0 : truetable:&#123;two=5, one=0&#125;table is empty]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>HashTable</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 HashMap]]></title>
    <url>%2F2015%2F07%2F10%2F8-Collection-Map%2F10-HashMap%2F</url>
    <content type="text"><![CDATA[HashMap简介HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。 HashMap 的实现不是同步的，这意味着它不是线程安全的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。 HashMap的构造函数HashMap共有4个构造函数,如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 默认构造函数。public HashMap() &#123; // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init();&#125;// 指定“容量大小”和“加载因子”的构造函数public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init();&#125;// 指定“容量大小”的构造函数public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 包含“子Map”的构造函数public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m);&#125; HashMap的API12345678910111213void clear()Object clone()boolean containsKey(Object key)boolean containsValue(Object value)Set&lt;Entry&lt;K, V&gt;&gt; entrySet()V get(Object key)boolean isEmpty()Set&lt;K&gt; keySet()V put(K key, V value)void putAll(Map&lt;? extends K, ? extends V&gt; map)V remove(Object key)int size()Collection&lt;V&gt; values() HashMap数据结构HashMap的继承关系 1234567java.lang.Object ↳ java.util.AbstractMap&lt;K, V&gt; ↳ java.util.HashMap&lt;K, V&gt;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; &#125; HashMap与Map关系如下图： 从图中可以看出： HashMap继承于AbstractMap类，实现了Map接口。Map是”key-value键值对”接口，AbstractMap实现了”键值对”的通用函数接口。 HashMap是通过”拉链法”实现的哈希表。它包括几个重要的成员变量：table, size, threshold, loadFactor, modCount。 table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的”key-value键值对”都是存储在Entry数组中的。 size是HashMap的大小，它是HashMap保存的键值对的数量 threshold是HashMap的阈值，用于判断是否需要调整HashMap的容量。threshold的值=”容量*加载因子”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 loadFactor就是加载因子。 modCount是用来实现fail-fast机制的。 HashMap源码解析为了更了解HashMap的原理，下面对HashMap源码代码作出分析。在阅读源码时，建议参考后面的说明来建立对HashMap的整体认识，这样更容易理解HashMap。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759package java.util;import java.io.*;public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable&#123; // 默认的初始容量是16，必须是2的幂。 static final int DEFAULT_INITIAL_CAPACITY = 16; // 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换） static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认加载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 存储数据的Entry数组，长度是2的幂。 // HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表 transient Entry[] table; // HashMap的大小，它是HashMap保存的键值对的数量 transient int size; // HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子） int threshold; // 加载因子实际大小 final float loadFactor; // HashMap被改变的次数 transient volatile int modCount; // 指定“容量大小”和“加载因子”的构造函数 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); // HashMap的最大容量只能是MAXIMUM_CAPACITY if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); // 找出“大于initialCapacity”的最小的2的幂 int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; // 设置“加载因子” this.loadFactor = loadFactor; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(capacity * loadFactor); // 创建Entry数组，用来保存数据 table = new Entry[capacity]; init(); &#125; // 指定“容量大小”的构造函数 public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; // 默认构造函数。 public HashMap() &#123; // 设置“加载因子” this.loadFactor = DEFAULT_LOAD_FACTOR; // 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。 threshold = (int)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR); // 创建Entry数组，用来保存数据 table = new Entry[DEFAULT_INITIAL_CAPACITY]; init(); &#125; // 包含“子Map”的构造函数 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); // 将m中的全部元素逐个添加到HashMap中 putAllForCreate(m); &#125; static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; // 返回索引值 // h &amp; (length-1)保证返回值的小于length static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; public int size() &#123; return size; &#125; public boolean isEmpty() &#123; return size == 0; &#125; // 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; // 获取“key为null”的元素的值 // HashMap将“key为null”的元素存储在table[0]位置！ private V getForNullKey() &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; // HashMap是否包含key public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125; // 返回“键为key”的键值对 final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; // 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null; &#125; // putForNullKey()的作用是将“key为null”键值对添加到table[0]位置 private V putForNullKey(V value) &#123; for (Entry&lt;K,V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 这里的完全不会被执行到! modCount++; addEntry(0, null, value, 0); return null; &#125; // 创建HashMap对应的“添加方法”， // 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap // 而put()是对外提供的往HashMap中添加元素的方法。 private void putForCreate(K key, V value) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); // 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; e.value = value; return; &#125; &#125; // 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中 createEntry(hash, key, value, i); &#125; // 将“m”中的全部元素都添加到HashMap中。 // 该方法被内部的构造HashMap的方法所调用。 private void putAllForCreate(Map&lt;? extends K, ? extends V&gt; m) &#123; // 利用迭代器将元素逐个添加到HashMap中 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); putForCreate(e.getKey(), e.getValue()); &#125; &#125; // 重新调整HashMap的大小，newCapacity是调整后的单位 void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; // 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中， // 然后，将“新HashMap”赋值给“旧HashMap”。 Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); &#125; // 将HashMap中的全部元素都添加到newTable中 void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125; &#125; // 将"m"的全部元素都添加到HashMap中 public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125; &#125; // 删除“键为key”元素 public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value); &#125; // 删除“键为key”的元素 final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 删除“键值对” final Entry&lt;K,V&gt; removeMapping(Object o) &#123; if (!(o instanceof Map.Entry)) return null; Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o; Object key = entry.getKey(); int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中的“键值对e” // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (e.hash == hash &amp;&amp; e.equals(entry)) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e; &#125; // 清空HashMap，将所有的元素设为null public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0; &#125; // 是否包含“值为value”的元素 public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; // 是否包含null值 private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false; &#125; // 克隆一个HashMap，并返回Object对象 public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result; &#125; // Entry是单向链表。 // 它是 “HashMap链式存储法”对应的链表。 // 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125; &#125; // 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; // 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 // 它和addEntry的区别是： // (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素； // put()是通过addEntry()新增Entry的。 // 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； // 因此，需要调用addEntry() // (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 // 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； // 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中 // 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 // 此时，调用createEntry()即可。 void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++; &#125; // HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。 // 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。 private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125; &#125; // value的迭代器 private final class ValueIterator extends HashIterator&lt;V&gt; &#123; public V next() &#123; return nextEntry().value; &#125; &#125; // key的迭代器 private final class KeyIterator extends HashIterator&lt;K&gt; &#123; public K next() &#123; return nextEntry().getKey(); &#125; &#125; // Entry的迭代器 private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125; &#125; // 返回一个“key迭代器” Iterator&lt;K&gt; newKeyIterator() &#123; return new KeyIterator(); &#125; // 返回一个“value迭代器” Iterator&lt;V&gt; newValueIterator() &#123; return new ValueIterator(); &#125; // 返回一个“entry迭代器” Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator(); &#125; // HashMap的Entry对应的集合 private transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = null; // 返回“key的集合”，实际上返回一个“KeySet对象” public Set&lt;K&gt; keySet() &#123; Set&lt;K&gt; ks = keySet; return (ks != null ? ks : (keySet = new KeySet())); &#125; // Key对应的集合 // KeySet继承于AbstractSet，说明该集合中没有重复的Key。 private final class KeySet extends AbstractSet&lt;K&gt; &#123; public Iterator&lt;K&gt; iterator() &#123; return newKeyIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsKey(o); &#125; public boolean remove(Object o) &#123; return HashMap.this.removeEntryForKey(o) != null; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“value集合”，实际上返回的是一个Values对象 public Collection&lt;V&gt; values() &#123; Collection&lt;V&gt; vs = values; return (vs != null ? vs : (values = new Values())); &#125; // “value集合” // Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”， // Values中的元素能够重复。因为不同的key可以指向相同的value。 private final class Values extends AbstractCollection&lt;V&gt; &#123; public Iterator&lt;V&gt; iterator() &#123; return newValueIterator(); &#125; public int size() &#123; return size; &#125; public boolean contains(Object o) &#123; return containsValue(o); &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // 返回“HashMap的Entry集合” public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0(); &#125; // 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象 private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet()); &#125; // EntrySet对应的集合 // EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。 private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125; &#125; // java.io.Serializable的写入函数 // 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws IOException &#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125; &#125; private static final long serialVersionUID = 362498820763181265L; // java.io.Serializable的读取函数：根据写入方式读出 // 将HashMap的“总的容量，实际容量，所有的Entry”依次读出 private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException &#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125; &#125; // 返回“HashMap总的容量” int capacity() &#123; return table.length; &#125; // 返回“HashMap的加载因子” float loadFactor() &#123; return loadFactor; &#125;&#125; 说明: 在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。 HashMap的“拉链法”相关内容1、HashMap数据存储数组1transient Entry[] table; HashMap中的key-value都是存储在Entry数组中的。 2、数据节点Entry的数据结构结构图表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; // 指向下一个节点 Entry&lt;K,V&gt; next; final int hash; // 构造函数。 // 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)" Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 判断两个Entry是否相等 // 若两个Entry的“key”和“value”都相等，则返回true。 // 否则，返回false public final boolean equals(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null &amp;&amp; k1.equals(k2))) &#123; Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null &amp;&amp; v1.equals(v2))) return true; &#125; return false; &#125; // 实现hashCode() public final int hashCode() &#123; return (key==null ? 0 : key.hashCode()) ^ (value==null ? 0 : value.hashCode()); &#125; public final String toString() &#123; return getKey() + "=" + getValue(); &#125; // 当向HashMap中添加元素时，绘调用recordAccess()。 // 这里不做任何处理 void recordAccess(HashMap&lt;K,V&gt; m) &#123; &#125; // 当从HashMap中删除元素时，绘调用recordRemoval()。 // 这里不做任何处理 void recordRemoval(HashMap&lt;K,V&gt; m) &#123; &#125;&#125; 从中，我们可以看出 Entry 实际上就是一个单向链表。这也是为什么我们说HashMap是通过拉链法解决哈希冲突的。Entry 实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数。这些都是基本的读取/修改key、value值的函数。 HashMap的主要对外接口clear()clear() 的作用是清空HashMap。它是通过将所有的元素设为null来实现的。 1234567public void clear() &#123; modCount++; Entry[] tab = table; for (int i = 0; i &lt; tab.length; i++) tab[i] = null; size = 0;&#125; containsKey()containsKey() 的作用是判断HashMap是否包含key。 123public boolean containsKey(Object key) &#123; return getEntry(key) != null;&#125; containsKey() 首先通过getEntry(key)获取key对应的Entry，然后判断该Entry是否为null。getEntry()的源码如下： 123456789101112131415final Entry&lt;K,V&gt; getEntry(Object key) &#123; // 获取哈希值 // HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值 int hash = (key == null) ? 0 : hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null;&#125; getEntry() 的作用就是返回“键为key”的键值对，它的实现源码中已经进行了说明。这里需要强调的是：HashMap将“key为null”的元素都放在table的位置0处，即table[0]中；“key不为null”的放在table的其余位置！ containsValue()containsValue() 的作用是判断HashMap是否包含“值为value”的元素。 12345678910111213public boolean containsValue(Object value) &#123; // 若“value为null”，则调用containsNullValue()查找 if (value == null) return containsNullValue(); // 若“value不为null”，则查找HashMap中是否有值为value的节点。 Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false;&#125; 从中，我们可以看出containsNullValue()分为两步进行处理：第一，若“value为null”，则调用containsNullValue()。第二，若“value不为null”，则查找HashMap中是否有值为value的节点。 containsNullValue() 的作用判断HashMap中是否包含“值为null”的元素。 12345678private boolean containsNullValue() &#123; Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (e.value == null) return true; return false;&#125; entrySet()、values()、keySet()它们3个的原理类似，这里以entrySet()为例来说明。entrySet()的作用是返回“HashMap中所有Entry的集合”，它是一个集合。实现代码如下： 12345678910111213141516171819202122232425262728293031323334// 返回“HashMap的Entry集合”public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; return entrySet0();&#125;// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象private Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet; return es != null ? es : (entrySet = new EntrySet());&#125;// EntrySet对应的集合// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。private final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123; return newEntryIterator(); &#125; public boolean contains(Object o) &#123; if (!(o instanceof Map.Entry)) return false; Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o; Entry&lt;K,V&gt; candidate = getEntry(e.getKey()); return candidate != null &amp;&amp; candidate.equals(e); &#125; public boolean remove(Object o) &#123; return removeMapping(o) != null; &#125; public int size() &#123; return size; &#125; public void clear() &#123; HashMap.this.clear(); &#125;&#125; HashMap是通过拉链法实现的散列表。表现在HashMap包括许多的Entry，而每一个Entry本质上又是一个单向链表。那么HashMap遍历key-value键值对的时候，是如何逐个去遍历的呢？ 下面我们就看看HashMap是如何通过entrySet()遍历的。entrySet()实际上是通过newEntryIterator()实现的。 下面我们看看它的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273// 返回一个“entry迭代器”Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator() &#123; return new EntryIterator();&#125;// Entry的迭代器private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public Map.Entry&lt;K,V&gt; next() &#123; return nextEntry(); &#125;&#125;// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; &#123; // 下一个元素 Entry&lt;K,V&gt; next; // expectedModCount用于实现fast-fail机制。 int expectedModCount; // 当前索引 int index; // 当前元素 Entry&lt;K,V&gt; current; HashIterator() &#123; expectedModCount = modCount; if (size &gt; 0) &#123; // advance to first entry Entry[] t = table; // 将next指向table中第一个不为null的元素。 // 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。 while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; // 获取下一个元素 final Entry&lt;K,V&gt; nextEntry() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); Entry&lt;K,V&gt; e = next; if (e == null) throw new NoSuchElementException(); // 注意！！！ // 一个Entry就是一个单向链表 // 若该Entry的下一个节点不为空，就将next指向下一个节点; // 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。 if ((next = e.next) == null) &#123; Entry[] t = table; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null) ; &#125; current = e; return e; &#125; // 删除当前元素 public void remove() &#123; if (current == null) throw new IllegalStateException(); if (modCount != expectedModCount) throw new ConcurrentModificationException(); Object k = current.key; current = null; HashMap.this.removeEntryForKey(k); expectedModCount = modCount; &#125;&#125; 当我们通过entrySet()获取到的Iterator的next()方法去遍历HashMap时，实际上调用的是 nextEntry() 。而nextEntry()的实现方式，先遍历Entry(根据Entry在table中的序号，从小到大的遍历)；然后对每个Entry(即每个单向链表)，逐个遍历。 get()get() 的作用是获取key对应的value，它的实现代码如下： 123456789101112131415public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null;&#125; put()put() 的作用是对外提供接口，让HashMap对象可以通过put()将“key-value”添加到HashMap中。 1234567891011121314151617181920212223public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; addEntry(hash, key, value, i); return null;&#125; 若要添加到HashMap中的键值对对应的key已经存在HashMap中，则找到该键值对；然后新的value取代旧的value，并退出！若要添加到HashMap中的键值对对应的key不在HashMap中，则将其添加到该哈希值对应的链表中，并调用addEntry()。下面看看addEntry()的代码： 12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length);&#125; addEntry() 的作用是新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 说到addEntry()，就不得不说另一个函数createEntry()。createEntry()的代码如下： 12345678void createEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K,V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K,V&gt;(hash, key, value, e); size++;&#125; 它们的作用都是将key、value添加到HashMap中。而且，比较addEntry()和createEntry()的代码，我们发现addEntry()多了两句： 12if (size++ &gt;= threshold) resize(2 * table.length); 那它们的区别到底是什么呢？阅读代码，我们可以发现，它们的使用情景不同。 addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。 例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；put()是通过addEntry()新增Entry的。 在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”； 因此，需要调用addEntry() createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。 例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中； 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中的全部元素添加到HashMap中，都不会超过HashMap的阈值”。 此时，调用createEntry()即可。 putAll()putAll() 的作用是将”m”的全部元素都添加到HashMap中，它的代码如下： 12345678910111213141516171819202122232425public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123; // 有效性判断 int numKeysToBeAdded = m.size(); if (numKeysToBeAdded == 0) return; // 计算容量是否足够， // 若“当前实际容量 &lt; 需要的容量”，则将容量x2。 if (numKeysToBeAdded &gt; threshold) &#123; int targetCapacity = (int)(numKeysToBeAdded / loadFactor + 1); if (targetCapacity &gt; MAXIMUM_CAPACITY) targetCapacity = MAXIMUM_CAPACITY; int newCapacity = table.length; while (newCapacity &lt; targetCapacity) newCapacity &lt;&lt;= 1; if (newCapacity &gt; table.length) resize(newCapacity); &#125; // 通过迭代器，将“m”中的元素逐个添加到HashMap中。 for (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123; Map.Entry&lt;? extends K, ? extends V&gt; e = i.next(); put(e.getKey(), e.getValue()); &#125;&#125; remove()remove() 的作用是删除“键为key”元素 123456789101112131415161718192021222324252627282930313233343536public V remove(Object key) &#123; Entry&lt;K,V&gt; e = removeEntryForKey(key); return (e == null ? null : e.value);&#125;// 删除“键为key”的元素final Entry&lt;K,V&gt; removeEntryForKey(Object key) &#123; // 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算 int hash = (key == null) ? 0 : hash(key.hashCode()); int i = indexFor(hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; e = prev; // 删除链表中“键为key”的元素 // 本质是“删除单向链表中的节点” while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; modCount++; size--; if (prev == e) table[i] = next; else prev.next = next; e.recordRemoval(this); return e; &#125; prev = e; e = next; &#125; return e;&#125; HashMap实现的Cloneable接口HashMap实现了Cloneable接口，即实现了clone()方法。clone()方法的作用很简单，就是克隆一个HashMap对象并返回。 123456789101112131415161718// 克隆一个HashMap，并返回Object对象public Object clone() &#123; HashMap&lt;K,V&gt; result = null; try &#123; result = (HashMap&lt;K,V&gt;)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; // assert false; &#125; result.table = new Entry[table.length]; result.entrySet = null; result.modCount = 0; result.size = 0; result.init(); // 调用putAllForCreate()将全部元素添加到HashMap中 result.putAllForCreate(this); return result;&#125; HashMap实现的Serializable接口HashMap实现java.io.Serializable，分别实现了串行读取、写入功能。串行写入函数是writeObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中。而串行读取函数是readObject()，它的作用是将HashMap的“总的容量，实际容量，所有的Entry”依次读出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// java.io.Serializable的写入函数// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中private void writeObject(java.io.ObjectOutputStream s) throws IOException&#123; Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = (size &gt; 0) ? entrySet0().iterator() : null; // Write out the threshold, loadfactor, and any hidden stuff s.defaultWriteObject(); // Write out number of buckets s.writeInt(table.length); // Write out size (number of Mappings) s.writeInt(size); // Write out keys and values (alternating) if (i != null) &#123; while (i.hasNext()) &#123; Map.Entry&lt;K,V&gt; e = i.next(); s.writeObject(e.getKey()); s.writeObject(e.getValue()); &#125; &#125;&#125;// java.io.Serializable的读取函数：根据写入方式读出// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException&#123; // Read in the threshold, loadfactor, and any hidden stuff s.defaultReadObject(); // Read in number of buckets and allocate the bucket array; int numBuckets = s.readInt(); table = new Entry[numBuckets]; init(); // Give subclass a chance to do its thing. // Read in size (number of Mappings) int size = s.readInt(); // Read the keys and values, and put the mappings in the HashMap for (int i=0; i&lt;size; i++) &#123; K key = (K) s.readObject(); V value = (V) s.readObject(); putForCreate(key, value); &#125;&#125; HashMap遍历方式遍历HashMap的键值对第一步：根据entrySet()获取HashMap的“键值对”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer integ = null;Iterator iter = map.entrySet().iterator();while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); // 获取key key = (String)entry.getKey(); // 获取value integ = (Integer)entry.getValue();&#125; 遍历HashMap的键第一步：根据keySet()获取HashMap的“键”的Set集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 1234567891011// 假设map是HashMap对象// map中的key是String类型，value是Integer类型String key = null;Integer integ = null;Iterator iter = map.keySet().iterator();while (iter.hasNext()) &#123; // 获取key key = (String)iter.next(); // 根据key，获取value integ = (Integer)map.get(key);&#125; 遍历HashMap的值第一步：根据value()获取HashMap的“值”的集合。第二步：通过Iterator迭代器遍历“第一步”得到的集合。 12345678// 假设map是HashMap对象// map中的key是String类型，value是Integer类型Integer value = null;Collection c = map.values();Iterator iter= c.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 遍历测试程序如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.HashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc 遍历HashMap的测试程序。 * (01) 通过entrySet()去遍历key、value，参考实现函数： * iteratorHashMapByEntryset() * (02) 通过keySet()去遍历key、value，参考实现函数： * iteratorHashMapByKeyset() * (03) 通过values()去遍历value，参考实现函数： * iteratorHashMapJustValues() * * @author skywang */public class HashMapIteratorTest &#123; public static void main(String[] args) &#123; int val = 0; String key = null; Integer value = null; Random r = new Random(); HashMap map = new HashMap(); for (int i=0; i&lt;12; i++) &#123; // 随机获取一个[0,100)之间的数字 val = r.nextInt(100); key = String.valueOf(val); value = r.nextInt(5); // 添加到HashMap中 map.put(key, value); System.out.println(" key:"+key+" value:"+value); &#125; // 通过entrySet()遍历HashMap的key-value iteratorHashMapByEntryset(map) ; // 通过keySet()遍历HashMap的key-value iteratorHashMapByKeyset(map) ; // 单单遍历HashMap的value iteratorHashMapJustValues(map); &#125; /* * 通过entry set遍历HashMap * 效率高! */ private static void iteratorHashMapByEntryset(HashMap map) &#123; if (map == null) return ; System.out.println("\niterator HashMap By entryset"); String key = null; Integer integ = null; Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); key = (String)entry.getKey(); integ = (Integer)entry.getValue(); System.out.println(key+" -- "+integ.intValue()); &#125; &#125; /* * 通过keyset来遍历HashMap * 效率低! */ private static void iteratorHashMapByKeyset(HashMap map) &#123; if (map == null) return ; System.out.println("\niterator HashMap By keyset"); String key = null; Integer integ = null; Iterator iter = map.keySet().iterator(); while (iter.hasNext()) &#123; key = (String)iter.next(); integ = (Integer)map.get(key); System.out.println(key+" -- "+integ.intValue()); &#125; &#125; /* * 遍历HashMap的values */ private static void iteratorHashMapJustValues(HashMap map) &#123; if (map == null) return ; Collection c = map.values(); Iterator iter= c.iterator(); while (iter.hasNext()) &#123; System.out.println(iter.next()); &#125; &#125;&#125; HashMap示例下面通过一个实例学习如何使用HashMap 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.Map;import java.util.Random;import java.util.Iterator;import java.util.HashMap;import java.util.HashSet;import java.util.Map.Entry;import java.util.Collection;/* * @desc HashMap测试程序 * * @author skywang */public class HashMapTest &#123; public static void main(String[] args) &#123; testHashMapAPIs(); &#125; private static void testHashMapAPIs() &#123; // 初始化随机种子 Random r = new Random(); // 新建HashMap HashMap map = new HashMap(); // 添加操作 map.put("one", r.nextInt(10)); map.put("two", r.nextInt(10)); map.put("three", r.nextInt(10)); // 打印出map System.out.println("map:"+map ); // 通过Iterator遍历key-value Iterator iter = map.entrySet().iterator(); while(iter.hasNext()) &#123; Map.Entry entry = (Map.Entry)iter.next(); System.out.println("next : "+ entry.getKey() +" - "+entry.getValue()); &#125; // HashMap的键值对个数 System.out.println("size:"+map.size()); // containsKey(Object key) :是否包含键key System.out.println("contains key two : "+map.containsKey("two")); System.out.println("contains key five : "+map.containsKey("five")); // containsValue(Object value) :是否包含值value System.out.println("contains value 0 : "+map.containsValue(new Integer(0))); // remove(Object key) ： 删除键key对应的键值对 map.remove("three"); System.out.println("map:"+map ); // clear() ： 清空HashMap map.clear(); // isEmpty() : HashMap是否为空 System.out.println((map.isEmpty()?"map is empty":"map is not empty") ); &#125;&#125; (某一次)运行结果： 12345678910map:&#123;two=7, one=9, three=6&#125;next : two - 7next : one - 9next : three - 6size:3contains key two : truecontains key five : falsecontains value 0 : falsemap:&#123;two=7, one=9&#125;map is empty]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Map]]></title>
    <url>%2F2015%2F07%2F08%2F8-Collection-Map%2F9-Map%2F</url>
    <content type="text"><![CDATA[Map前面，我们已经系统的对List进行了学习。接下来，我们先学习Map，然后再学习Set；因为Set的实现类都是基于Map来实现的(如，HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的)。 首先，我们看看Map架构。 如上图： Map 是映射接口，Map中存储的内容是键值对(key-value)。 AbstractMap 是继承于Map的抽象类，它实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。 SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。 NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。 TreeMap 继承于AbstractMap，且实现了NavigableMap接口；因此，TreeMap中的内容是“有序的键值对”！ HashMap 继承于AbstractMap，但没实现NavigableMap接口；因此，HashMap的内容是“键值对，但不保证次序”！ Hashtable 虽然不是继承于AbstractMap，但它继承于Dictionary(Dictionary也是键值对的接口)，而且也实现Map接口；因此，Hashtable的内容也是“键值对，也不保证次序”。但和HashMap相比，Hashtable是线程安全的，而且它支持通过Enumeration去遍历。 WeakHashMap 继承于AbstractMap。它和HashMap的键类型不同，WeakHashMap的键是“弱键”。 1、MapMap的定义如下： 1public interface Map&lt;K,V&gt; &#123; &#125; Map 是一个键值对(key-value)映射接口。Map映射中不能包含重复的键；每个键最多只能映射到一个值。 Map 接口提供三种 collection 视图，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。 Map 映射顺序。有些实现类，可以明确保证其顺序，如 TreeMap；另一些映射实现则不保证顺序，如 HashMap 类。 Map 的实现类应该提供2个“标准的”构造方法：第一个，void（无参数）构造方法，用于创建空映射；第二个，带有单个 Map 类型参数的构造方法，用于创建一个与其参数具有相同键-值映射关系的新映射。实际上，后一个构造方法允许用户复制任意映射，生成所需类的一个等价映射。尽管无法强制执行此建议（因为接口不能包含构造方法），但是 JDK 中所有通用的映射实现都遵从它。 Map的API1234567891011121314abstract void clear()abstract boolean containsKey(Object key)abstract boolean containsValue(Object value)abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet()abstract boolean equals(Object object)abstract V get(Object key)abstract int hashCode()abstract boolean isEmpty()abstract Set&lt;K&gt; keySet()abstract V put(K key, V value)abstract void putAll(Map&lt;? extends K, ? extends V&gt; map)abstract V remove(Object key)abstract int size()abstract Collection&lt;V&gt; values() 说明： Map提供接口分别用于返回 键集、值集或键-值映射关系集。 1. entrySet()用于返回键-值集的Set集合 2. keySet()用于返回键集的Set集合 3. values()用户返回值集的Collection集合 4. 因为Map中不能包含重复的键；每个键最多只能映射到一个值。所以，键-值集、键集都是Set，值集时Collection。 Map提供了“键-值对”、“根据键获取值”、“删除键”、“获取容量大小”等方法。 2、Map.EntryMap.Entry的定义：1interface Entry&lt;K,V&gt; &#123; &#125; Map.Entry是Map中内部的一个接口，Map.Entry是键值对，Map通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。 Map.Entry的API12345abstract boolean equals(Object object)abstract K getKey()abstract V getValue()abstract int hashCode()abstract V setValue(V object) 3、AbstractMapAbstractMap的定义：1public abstract class AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123;&#125; AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作。 要实现不可修改的映射，编程人员只需扩展此类并提供 entrySet 方法的实现即可，该方法将返回映射的映射关系 set 视图。通常，返回的 set 将依次在 AbstractSet 上实现。此 set 不支持 add() 或 remove() 方法，其迭代器也不支持 remove() 方法。 要实现可修改的映射，编程人员必须另外重写此类的 put 方法（否则将抛出 UnsupportedOperationException），entrySet().iterator() 返回的迭代器也必须另外实现其 remove 方法。 AbstractMap的API12345678910111213141516abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet() void clear() boolean containsKey(Object key) boolean containsValue(Object value) boolean equals(Object object) V get(Object key) int hashCode() boolean isEmpty() Set&lt;K&gt; keySet() V put(K key, V value) void putAll(Map&lt;? extends K, ? extends V&gt; map) V remove(Object key) int size() String toString() Collection&lt;V&gt; values() Object clone() 4、SortedMapSortedMap的定义：1public interface SortedMap&lt;K,V&gt; extends Map&lt;K,V&gt; &#123; &#125; SortedMap是一个继承于Map接口的接口。它是一个有序的SortedMap键值映射。SortedMap 的排序方式有两种：自然排序 或者 用户指定比较器。 插入有序 SortedMap 的所有元素都必须实现 Comparable 接口（或者被指定的比较器所接受）。 另外，所有SortedMap 实现类都应该提供 4 个“标准”构造方法： void（无参数）构造方法，它创建一个空的有序映射，按照键的自然顺序进行排序。 带有一个 Comparator 类型参数的构造方法，它创建一个空的有序映射，根据指定的比较器进行排序。 带有一个 Map 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系与参数相同，按照键的自然顺序进行排序。 带有一个 SortedMap 类型参数的构造方法，它创建一个新的有序映射，其键-值映射关系和排序方法与输入的有序映射相同。无法保证强制实施此建议，因为接口不能包含构造方法。 SortedMap的API12345678910111213141516171819202122// 继承于Map的APIabstract void clear()abstract boolean containsKey(Object key)abstract boolean containsValue(Object value)abstract Set&lt;Entry&lt;K, V&gt;&gt; entrySet()abstract boolean equals(Object object)abstract V get(Object key)abstract int hashCode()abstract boolean isEmpty()abstract Set&lt;K&gt; keySet()abstract V put(K key, V value)abstract void putAll(Map&lt;? extends K, ? extends V&gt; map)abstract V remove(Object key)abstract int size()abstract Collection&lt;V&gt; values()// SortedMap新增的API abstract Comparator&lt;? super K&gt; comparator()abstract K firstKey()abstract SortedMap&lt;K, V&gt; headMap(K endKey)abstract K lastKey()abstract SortedMap&lt;K, V&gt; subMap(K startKey, K endKey)abstract SortedMap&lt;K, V&gt; tailMap(K startKey) 5、NavigableMapNavigableMap的定义：1public interface NavigableMap&lt;K,V&gt; extends SortedMap&lt;K,V&gt; &#123; &#125; NavigableMap是继承于SortedMap的接口。它是一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。NavigableMap分别提供了获取“键”、“键-值对”、“键集”、“键-值对集”的相关方法。 NavigableMap的API123456789101112131415161718192021abstract Entry&lt;K, V&gt; ceilingEntry(K key)abstract Entry&lt;K, V&gt; firstEntry()abstract Entry&lt;K, V&gt; floorEntry(K key)abstract Entry&lt;K, V&gt; higherEntry(K key)abstract Entry&lt;K, V&gt; lastEntry()abstract Entry&lt;K, V&gt; lowerEntry(K key)abstract Entry&lt;K, V&gt; pollFirstEntry()abstract Entry&lt;K, V&gt; pollLastEntry()abstract K ceilingKey(K key)abstract K floorKey(K key)abstract K higherKey(K key)abstract K lowerKey(K key)abstract NavigableSet&lt;K&gt; descendingKeySet()abstract NavigableSet&lt;K&gt; navigableKeySet()abstract NavigableMap&lt;K, V&gt; descendingMap()abstract NavigableMap&lt;K, V&gt; headMap(K toKey, boolean inclusive)abstract SortedMap&lt;K, V&gt; headMap(K toKey)abstract SortedMap&lt;K, V&gt; subMap(K fromKey, K toKey)abstract NavigableMap&lt;K, V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive)abstract SortedMap&lt;K, V&gt; tailMap(K fromKey)abstract NavigableMap&lt;K, V&gt; tailMap(K fromKey, boolean inclusive) 说明： NavigableMap除了继承SortedMap的特性外，它的提供的功能可以分为4类： 提供操作键-值对的方法。 lowerEntry、floorEntry、ceilingEntry 和 higherEntry 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键关联的 Map.Entry 对象。 firstEntry、pollFirstEntry、lastEntry 和 pollLastEntry 方法，它们返回和/或移除最小和最大的映射关系（如果存在），否则返回 null。 提供操作键的方法。这个和第1类比较类似 lowerKey、floorKey、ceilingKey 和 higherKey 方法，它们分别返回与小于、小于等于、大于等于、大于给定键的键。 获取键集。 navigableKeySet、descendingKeySet分别获取正序/反序的键集。 获取键-值对的子集。 6、DictionaryDictionary的定义如下：1public abstract class Dictionary&lt;K,V&gt; &#123;&#125; NavigableMap是JDK 1.0定义的键值对的接口，它也包括了操作键值对的基本函数。 Dictionary的API1234567abstract Enumeration&lt;V&gt; elements()abstract V get(Object key)abstract boolean isEmpty()abstract Enumeration&lt;K&gt; keys()abstract V put(K key, V value)abstract V remove(Object key)abstract int size()]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 List总结]]></title>
    <url>%2F2015%2F07%2F02%2F8-Collection-Map%2F8-List%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[List 总结先回顾一下List的框架图 List 是一个接口，它继承于Collection的接口。它代表着有序的队列。 AbstractList 是一个抽象类，它继承于AbstractCollection。AbstractList实现List接口中除size()、get(int location)之外的函数。 AbstractSequentialList 是一个抽象类，它继承于AbstractList。AbstractSequentialList 实现了“链表中，根据index索引值操作链表的全部函数”。 ArrayList, LinkedList, Vector, Stack是List的4个实现类。 1. ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。 2. LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。 3. Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。 4. Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。 List使用场景学东西的最终目的是为了能够理解、使用它。下面先概括的说明一下各个List的使用场景，后面再分析原因。 如果涉及到“栈”、“队列”、“链表”等操作，应该考虑用List，具体的选择哪个List，根据下面的标准来取舍。 对于需要快速插入，删除元素，应该使用LinkedList。 对于需要快速随机访问元素，应该使用ArrayList。 对于“单线程环境” 或者 “多线程环境，但List仅仅只会被单个线程操作”，此时应该使用非同步的类(如ArrayList)。 对于“多线程环境，且List可能同时被多个线程操作”，此时，应该使用同步的类(如Vector)。 通过下面的测试程序，我们来验证上面的(01)和(02)结论。参考代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import java.util.*;import java.lang.Class;/* * @desc 对比ArrayList和LinkedList的插入、随机读取效率、删除的效率 */public class ListCompareTest &#123; private static final int COUNT = 100000; private static LinkedList linkedList = new LinkedList(); private static ArrayList arrayList = new ArrayList(); private static Vector vector = new Vector(); private static Stack stack = new Stack(); public static void main(String[] args) &#123; // 换行符 System.out.println(); // 插入 insertByPosition(stack) ; insertByPosition(vector) ; insertByPosition(linkedList) ; insertByPosition(arrayList) ; // 换行符 System.out.println(); // 随机读取 readByPosition(stack); readByPosition(vector); readByPosition(linkedList); readByPosition(arrayList); // 换行符 System.out.println(); // 删除 deleteByPosition(stack); deleteByPosition(vector); deleteByPosition(linkedList); deleteByPosition(arrayList); &#125; // 获取list的名称 private static String getListName(List list) &#123; if (list instanceof LinkedList) &#123; return "LinkedList"; &#125; else if (list instanceof ArrayList) &#123; return "ArrayList"; &#125; else if (list instanceof Stack) &#123; return "Stack"; &#125; else if (list instanceof Vector) &#123; return "Vector"; &#125; else &#123; return "List"; &#125; &#125; // 向list的指定位置插入COUNT个元素，并统计时间 private static void insertByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 向list的位置0插入COUNT个数 for (int i=0; i&lt;COUNT; i++) list.add(0, i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + " : insert "+COUNT+" elements into the 1st position use time：" + interval+" ms"); &#125; // 从list的指定位置删除COUNT个元素，并统计时间 private static void deleteByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 删除list第一个位置元素 for (int i=0; i&lt;COUNT; i++) list.remove(0); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + " : delete "+COUNT+" elements from the 1st position use time：" + interval+" ms"); &#125; // 根据position，不断从list中读取元素，并统计时间 private static void readByPosition(List list) &#123; long startTime = System.currentTimeMillis(); // 读取list元素 for (int i=0; i&lt;COUNT; i++) list.get(i); long endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println(getListName(list) + " : read "+COUNT+" elements by position use time：" + interval+" ms"); &#125;&#125; 运行结果如下： 1234567891011121314Stack : insert 100000 elements into the 1st position use time：1640 msVector : insert 100000 elements into the 1st position use time：1607 msLinkedList : insert 100000 elements into the 1st position use time：29 msArrayList : insert 100000 elements into the 1st position use time：1617 msStack : read 100000 elements by position use time：9 msVector : read 100000 elements by position use time：6 msLinkedList : read 100000 elements by position use time：10809 msArrayList : read 100000 elements by position use time：5 msStack : delete 100000 elements from the 1st position use time：1916 msVector : delete 100000 elements from the 1st position use time：1910 msLinkedList : delete 100000 elements from the 1st position use time：15 msArrayList : delete 100000 elements from the 1st position use time：1909 ms 从中，我们可以发现：插入10万个元素，LinkedList所花时间最短：29ms。删除10万个元素，LinkedList所花时间最短：15ms。遍历10万个元素，LinkedList所花时间最长：10809 ms；而ArrayList、Stack和Vector则相差不多，都只用了几秒。 LinkedList和ArrayList性能差异分析为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢！LinkedList.java中向指定位置插入元素的代码如下： 1234567891011121314151617181920212223242526272829303132333435// 在index前添加节点，且节点的值为elementpublic void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index)));&#125;// 获取双向链表中指定位置的节点private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前向后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e;&#125;// 将节点(节点数据是e)添加到entry节点之前。private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); // 插入newEntry到链表中 newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; size++; modCount++; return newEntry;&#125; 从中，我们可以看出：通过add(int index, E element)向LinkedList插入元素时。先是在双向链表中找到要插入节点的位置index；找到之后，再插入一个新节点。 双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 接着，我们看看ArrayList.java中向指定位置插入元素的代码。如下： 123456789101112// 将e添加到ArrayList的指定位置public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 耗时的操作是 : 1System.arraycopy(elementData, index, elementData, index + 1, size - index); Sun JDK包的java/lang/System.java中的arraycopy()声明如下： 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); arraycopy()是个JNI函数，它是在JVM中实现的。sunJDK中看不到源码，不过可以在OpenJDK包中看到的源码。网上有对arraycopy()的分析说明，请参考：System.arraycopy源码分析 。 实际上，我们只需要了解： 1System.arraycopy(elementData, index, elementData, index + 1, size - index); 会移动index之后所有元素即可。这就意味着，ArrayList的add(int index, E element)函数，会引起index之后所有元素的改变！ 通过上面的分析，我们就能理解为什么LinkedList中插入元素很快，而ArrayList中插入元素很慢。 “删除元素”与“插入元素”的原理类似，这里就不再过多说明。 为什么LinkedList中随机访问很慢，而ArrayList中随机访问很快先看看LinkedList随机访问的代码 1234567891011121314151617181920212223// 返回LinkedList指定位置的元素public E get(int index) &#123; return entry(index).element;&#125;// 获取双向链表中指定位置的节点private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e;&#125; 从中，我们可以看出：通过get(int index)获取LinkedList第index个元素时。先是在双向链表中找到要index位置的元素；找到之后再返回。双向链表查找index位置的节点时，有一个加速动作：若index &lt; 双向链表长度的1/2，则从前向后查找; 否则，从后向前查找。 下面看看ArrayList随机访问的代码 123456789101112// 获取index位置的元素值public E get(int index) &#123; RangeCheck(index); return (E) elementData[index];&#125;private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size);&#125; 从中，我们可以看出：通过get(int index)获取ArrayList第index个元素时。直接返回数组中index位置的元素，而不需要像LinkedList一样进行查找。 Vector和ArrayList比较相同之处它们都是List它们都继承于AbstractList，并且实现List接口。ArrayList和Vector的类定义如下： 1234567// ArrayList的定义public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable// Vector的定义public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; 它们都实现了RandomAccess和Cloneable接口 实现RandomAccess接口，意味着它们都支持快速随机访问； 实现Cloneable接口，意味着它们能克隆自己。 它们都是通过数组实现的，本质上都是动态数组ArrayList.java中定义数组elementData用于保存元素 123456// 保存ArrayList中数据的数组private transient Object[] elementData;Vector.java中也定义了数组elementData用于保存元素// 保存Vector中数据的数组protected Object[] elementData; 它们的默认数组容量是10若创建ArrayList或Vector时，没指定容量大小；则使用默认容量大小10。 123456789// ArrayList构造函数。默认容量是10。public ArrayList() &#123; this(10);&#125;// Vector构造函数。默认容量是10。public Vector() &#123; this(10);&#125; 它们都支持Iterator和listIterator遍历它们都继承于AbstractList，而AbstractList中分别实现了 “iterator()接口返回Iterator迭代器” 和 “listIterator()返回ListIterator迭代器”。 不同之处线程安全性不一样ArrayList是非线程安全；而Vector是线程安全的，它的函数都是synchronized的，即都是支持同步的。ArrayList适用于单线程，Vector适用于多线程。 对序列化支持不同ArrayList支持序列化，而Vector不支持；即ArrayList有实现java.io.Serializable接口，而Vector没有实现该接口。 构造函数个数不同ArrayList有3个构造函数，而Vector有4个构造函数。Vector除了包括和ArrayList类似的3个构造函数之外，另外的一个构造函数可以指定容量增加系数。 ArrayList的构造函数如下： 12345678// 默认构造函数ArrayList()// capacity是ArrayList的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含collection的ArrayListArrayList(Collection&lt;? extends E&gt; collection) Vector的构造函数如下： 1234567891011// 默认构造函数Vector()// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity)// 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement) 4、容量增加方式不同逐个添加元素时，若ArrayList容量不足时，“新的容量”=“(原始容量x3)/2 + 1”。 而Vector的容量增长与“增长系数有关”，若指定了“增长系数”，且“增长系数有效(即，大于0)”；那么，每次容量不足时，“新的容量”=“原始容量+增长系数”。若增长系数无效(即，小于/等于0)，则“新的容量”=“原始容量 x 2”。 ArrayList中容量增长的主要函数如下： 12345678910111213public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; Vector中容量增长的主要函数如下： 123456789101112131415private void ensureCapacityHelper(int minCapacity) &#123; int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) &#123; Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) &#123; newCapacity = minCapacity; &#125; elementData = Arrays.copyOf(elementData, newCapacity); &#125;&#125; 5、对Enumeration的支持不同。Vector支持通过Enumeration去遍历，而List不支持Vector中实现Enumeration的代码如下： 123456789101112131415161718192021public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return (E)elementData[count++]; &#125; &#125; throw new NoSuchElementException("Vector Enumeration"); &#125; &#125;;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Stack]]></title>
    <url>%2F2015%2F05%2F21%2F8-Collection-Map%2F7-Stack%2F</url>
    <content type="text"><![CDATA[Stack简介Stack是栈。它的特性是：先进后出(FILO, First In Last Out)。 Java工具包中的Stack是继承于Vector(矢量队列)的，由于Vector是通过数组实现的，这就意味着，Stack也是通过数组实现的，而非链表。当然，我们也可以将LinkedList当作栈来使用！在 Vector 中，已经详细介绍过Vector的数据结构，这里就不再对Stack的数据结构进行说明了。 Stack的继承关系1234567java.lang.Object↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt; ↳ java.util.Stack&lt;E&gt;public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123;&#125; Stack和Collection的关系如下图： Stack的构造函数Stack只有一个默认构造函数，如下： 1Stack() Stack的APIStack是栈，它常用的API如下： 12345 boolean empty()synchronized E peek()synchronized E pop() E push(E object)synchronized int search(Object o) 由于Stack和继承于Vector，因此它也包含Vector中的全部API。 Stack源码解析(基于JDK1.6.0_45)Stack的源码非常简单，下面我们对它进行学习。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package java.util;public class Stack&lt;E&gt; extends Vector&lt;E&gt; &#123; // 版本ID。这个用于版本升级控制，这里不须理会！ private static final long serialVersionUID = 1224463164541339165L; // 构造函数 public Stack() &#123; &#125; // push函数：将元素存入栈顶 public E push(E item) &#123; // 将元素存入栈顶。 // addElement()的实现在Vector.java中 addElement(item); return item; &#125; // pop函数：返回栈顶元素，并将其从栈中删除 public synchronized E pop() &#123; E obj; int len = size(); obj = peek(); // 删除栈顶元素，removeElementAt()的实现在Vector.java中 removeElementAt(len - 1); return obj; &#125; // peek函数：返回栈顶元素，不执行删除操作 public synchronized E peek() &#123; int len = size(); if (len == 0) throw new EmptyStackException(); // 返回栈顶元素，elementAt()具体实现在Vector.java中 return elementAt(len - 1); &#125; // 栈是否为空 public boolean empty() &#123; return size() == 0; &#125; // 查找“元素o”在栈中的位置：由栈底向栈顶方向数 public synchronized int search(Object o) &#123; // 获取元素索引，elementAt()具体实现在Vector.java中 int i = lastIndexOf(o); if (i &gt;= 0) &#123; return size() - i; &#125; return -1; &#125;&#125; 总结： Stack实际上也是通过数组去实现的。1. 执行push时(即，将元素推入栈中)，是通过将元素追加的数组的末尾中。 2. 执行peek时(即，取出栈顶元素，不执行删除)，是返回数组末尾的元素。 3. 执行pop时(即，取出栈顶元素，并将该元素从栈中删除)，是取出数组末尾的元素，然后将该元素从数组中删除。 Stack继承于Vector，意味着Vector拥有的属性和功能，Stack都拥有。 Stack示例下面我们通过实例学习如何使用Stack 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import java.util.Stack;import java.util.Iterator;import java.util.List;/** * @desc Stack的测试程序。测试常用API的用法 */public class StackTest &#123; public static void main(String[] args) &#123; Stack stack = new Stack(); // 将1,2,3,4,5添加到栈中 for(int i=1; i&lt;6; i++) &#123; stack.push(String.valueOf(i)); &#125; // 遍历并打印出该栈 iteratorThroughRandomAccess(stack) ; // 查找“2”在栈中的位置，并输出 int pos = stack.search("2"); System.out.println("the postion of 2 is:"+pos); // pop栈顶元素之后，遍历栈 stack.pop(); iteratorThroughRandomAccess(stack) ; // peek栈顶元素之后，遍历栈 String val = (String)stack.peek(); System.out.println("peek:"+val); iteratorThroughRandomAccess(stack) ; // 通过Iterator去遍历Stack iteratorThroughIterator(stack) ; &#125; /** * 通过快速访问遍历Stack */ public static void iteratorThroughRandomAccess(List list) &#123; String val = null; for (int i=0; i&lt;list.size(); i++) &#123; val = (String)list.get(i); System.out.print(val+" "); &#125; System.out.println(); &#125; /** * 通过迭代器遍历Stack */ public static void iteratorThroughIterator(List list) &#123; String val = null; for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; val = (String)iter.next(); System.out.print(val+" "); &#125; System.out.println(); &#125;&#125; 运行结果： 1234561 2 3 4 5 the postion of 2 is:41 2 3 4 peek:41 2 3 4 1 2 3 4]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 LinkedList]]></title>
    <url>%2F2015%2F05%2F20%2F8-Collection-Map%2F5-LinkedList%2F</url>
    <content type="text"><![CDATA[LinkedList 简介 LinkedList 是一个继承于 AbstractSequentialList 的双向链表。它也可以被当作堆栈、队列或双端队列进行操作。 LinkedList 实现 List 接口，能对它进行队列操作。 LinkedList 实现 Deque 接口，即能将 LinkedList 当作双端队列使用。 LinkedList 实现了 Cloneable 接口，即覆盖了函数 clone()，能克隆。 LinkedList 实现java.io.Serializable接口，这意味着 LinkedList 支持序列化，能通过序列化去传输。 LinkedList 是非同步的。 LinkedList构造函数12345// 默认构造函数LinkedList()// 创建一个 LinkedList，保护 Collection 中的全部元素。LinkedList(Collection&lt;? extends E&gt; collection) LinkedList的API12345678910111213141516171819202122232425262728293031323334353637383940// LinkedList 的APIboolean add(E object)void add(int location, E object)boolean addAll(Collection&lt;? extends E&gt; collection)boolean addAll(int location, Collection&lt;? extends E&gt; collection)void addFirst(E object)void addLast(E object)void clear()Object clone()boolean contains(Object object)Iterator&lt;E&gt; descendingIterator()E element()E get(int location)E getFirst()E getLast()int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)boolean offer(E o)boolean offerFirst(E e)boolean offerLast(E e)E peek()E peekFirst()E peekLast()E poll()E pollFirst()E pollLast()E pop()void push(E e)E remove()E remove(int location)boolean remove(Object object)E removeFirst()boolean removeFirstOccurrence(Object o)E removeLast()boolean removeLastOccurrence(Object o)E set(int location, E object)int size()&lt;T&gt; T[] toArray(T[] contents)Object[] toArray() AbstractSequentialList 简介在介绍 LinkedList 的源码之前，先介绍一下 AbstractSequentialList。毕竟，LinkedList 是AbstractSequentialList 的子类。 AbstractSequentialList 实现了 get(int index)、set(int index, E element)、add(int index, E element)和remove(int index) 这些函数。这些接口都是随机访问List的，LinkedList是双向链表；既然它继承于AbstractSequentialList，就相当于已经实现了 get(int index) 这些接口。 此外，我们若需要通过 AbstractSequentialList 自己实现一个列表，只需要扩展此类，并提供 listIterator() 和 size() 方法的实现即可。若要实现不可修改的列表，则需要实现列表迭代器的 hasNext、next、hasPrevious、previous 和 index 方法即可。 LinkedList 数据结构LinkedList 的继承关系12345java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.AbstractSequentialList&lt;E&gt; ↳ java.util.LinkedList&lt;E&gt; 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable &#123;&#125; LinkedList 与 Collection 关系图： LinkedList的本质是双向链表。 LinkedList 继承于 AbstractSequentialList，并且实现了 Dequeue 接口。 LinkedList 包含两个重要的成员：header 和 size。 header是双向链表的表头，它是双向链表节点所对应的类Entry的实例。Entry中包含成员变量： previous, next, element。其中，previous是该节点的上一个节点，next是该节点的下一个节点，element是该节点所包含的值。size是双向链表中节点的个数。 LinkedList 源码解析 (基于JDK1.6.0_45)为了更了解 LinkedList 的原理，下面对 LinkedList 源码代码作出分析。 在阅读源码之前，我们先对 LinkedList 的整体实现进行大致说明： LinkedList 实际上是通过双向链表去实现的。既然是双向链表，那么它的顺序访问会非常高效，而随机访问效率比较低。 既然 LinkedList 是通过双向链表的，但是它也实现了 List 接口 {也就是说，它实现了get(int location)、remove(int location) 等“根据索引值来获取、删除节点的函数”}。 LinkedList 是如何实现 List 的这些接口的，如何将“双向链表和索引值联系起来的”？ 实际原理非常简单，它就是通过一个计数索引值来实现的。例如，当我们调用get(int location)时，首先会比较“location”和“双向链表长度的1/2”；若前者大，则从链表头开始往后查找，直到 location 位置；否则，从链表末尾开始先前查找，直到 location 位置。这就是“双线链表和索引值联系起来”的方法。 好了，接下来开始阅读源码（只要理解双向链表，那么LinkedList的源码很容易理解的）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641package java.util;public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; // 链表的表头，表头不包含任何数据。Entry是个链表类数据结构。 // transient声明一个实例变量，当对象存储时，它的值不需要维持。 // 换句话来说就是，用transient关键字标记的成员变量不参与序列化过程。 private transient Entry&lt;E&gt; header = new Entry&lt;E&gt;(null, null, null); // LinkedList中元素个数 private transient int size = 0; // 默认构造函数：创建一个空的链表 public LinkedList() &#123; header.next = header.previous = header; &#125; // 包含“集合”的构造函数:创建一个包含“集合”的LinkedList public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c); &#125; // 获取LinkedList的第一个元素 public E getFirst() &#123; if (size==0) throw new NoSuchElementException(); // 链表的表头header中不包含数据。 // 这里返回header所指下一个节点所包含的数据。 return header.next.element; &#125; // 获取LinkedList的最后一个元素 public E getLast() &#123; if (size==0) throw new NoSuchElementException(); // 由于LinkedList是双向链表；而表头header不包含数据。 // 因而，这里返回表头header的前一个节点所包含的数据。 return header.previous.element; &#125; // 删除LinkedList的第一个元素 public E removeFirst() &#123; return remove(header.next); &#125; // 删除LinkedList的最后一个元素 public E removeLast() &#123; return remove(header.previous); &#125; // 将元素添加到LinkedList的起始位置 public void addFirst(E e) &#123; addBefore(e, header.next); &#125; // 将元素添加到LinkedList的结束位置 public void addLast(E e) &#123; addBefore(e, header); &#125; // 判断LinkedList是否包含元素(o) public boolean contains(Object o) &#123; return indexOf(o) != -1; &#125; // 返回LinkedList的大小 public int size() &#123; return size; &#125; // 将元素(E)添加到LinkedList中 public boolean add(E e) &#123; // 将节点(节点数据是e)添加到表头(header)之前。 // 即，将节点添加到双向链表的末端。 addBefore(e, header); return true; &#125; // 从LinkedList中删除元素(o) // 从链表开始查找，如存在元素(o)则删除该元素并返回true； // 否则，返回false。 public boolean remove(Object o) &#123; if (o==null) &#123; // 若o为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; // 若o不为null的删除情况 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 将“集合(c)”添加到LinkedList中。 // 实际上，是从双向链表的末尾开始，将“集合(c)”添加到双向链表中。 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; // 从双向链表的index开始，将“集合(c)”添加到双向链表中。 public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Object[] a = c.toArray(); // 获取集合的长度 int numNew = a.length; if (numNew==0) return false; modCount++; // 设置“当前要插入节点的后一个节点” Entry&lt;E&gt; successor = (index==size ? header : entry(index)); // 设置“当前要插入节点的前一个节点” Entry&lt;E&gt; predecessor = successor.previous; // 将集合(c)全部插入双向链表中 for (int i=0; i&lt;numNew; i++) &#123; Entry&lt;E&gt; e = new Entry&lt;E&gt;((E)a[i], successor, predecessor); predecessor.next = e; predecessor = e; &#125; successor.previous = predecessor; // 调整LinkedList的实际大小 size += numNew; return true; &#125; // 清空双向链表 public void clear() &#123; Entry&lt;E&gt; e = header.next; // 从表头开始，逐个向后遍历；对遍历到的节点执行一下操作： // (01) 设置前一个节点为null // (02) 设置当前节点的内容为null // (03) 设置后一个节点为“新的当前节点” while (e != header) &#123; Entry&lt;E&gt; next = e.next; e.next = e.previous = null; e.element = null; e = next; &#125; header.next = header.previous = header; // 设置大小为0 size = 0; modCount++; &#125; // 返回LinkedList指定位置的元素 public E get(int index) &#123; return entry(index).element; &#125; // 设置index位置对应的节点的值为element public E set(int index, E element) &#123; Entry&lt;E&gt; e = entry(index); E oldVal = e.element; e.element = element; return oldVal; &#125; // 在index前添加节点，且节点的值为element public void add(int index, E element) &#123; addBefore(element, (index==size ? header : entry(index))); &#125; // 删除index位置的节点 public E remove(int index) &#123; return remove(entry(index)); &#125; // 获取双向链表中指定位置的节点 private Entry&lt;E&gt; entry(int index) &#123; if (index &lt; 0 || index &gt;= size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); Entry&lt;E&gt; e = header; // 获取index处的节点。 // 若index &lt; 双向链表长度的1/2,则从前先后查找; // 否则，从后向前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; for (int i = 0; i &lt;= index; i++) e = e.next; &#125; else &#123; for (int i = size; i &gt; index; i--) e = e.previous; &#125; return e; &#125; // 从前向后查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int indexOf(Object o) &#123; int index = 0; if (o==null) &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (e.element==null) return index; index++; &#125; &#125; else &#123; for (Entry e = header.next; e != header; e = e.next) &#123; if (o.equals(e.element)) return index; index++; &#125; &#125; return -1; &#125; // 从后向前查找，返回“值为对象(o)的节点对应的索引” // 不存在就返回-1 public int lastIndexOf(Object o) &#123; int index = size; if (o==null) &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (e.element==null) return index; &#125; &#125; else &#123; for (Entry e = header.previous; e != header; e = e.previous) &#123; index--; if (o.equals(e.element)) return index; &#125; &#125; return -1; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peek() &#123; if (size==0) return null; return getFirst(); &#125; // 返回第一个节点 // 若LinkedList的大小为0,则抛出异常 public E element() &#123; return getFirst(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E poll() &#123; if (size==0) return null; return removeFirst(); &#125; // 将e添加双向链表末尾 public boolean offer(E e) &#123; return add(e); &#125; // 将e添加双向链表开头 public boolean offerFirst(E e) &#123; addFirst(e); return true; &#125; // 将e添加双向链表末尾 public boolean offerLast(E e) &#123; addLast(e); return true; &#125; // 返回第一个节点 // 若LinkedList的大小为0,则返回null public E peekFirst() &#123; if (size==0) return null; return getFirst(); &#125; // 返回最后一个节点 // 若LinkedList的大小为0,则返回null public E peekLast() &#123; if (size==0) return null; return getLast(); &#125; // 删除并返回第一个节点 // 若LinkedList的大小为0,则返回null public E pollFirst() &#123; if (size==0) return null; return removeFirst(); &#125; // 删除并返回最后一个节点 // 若LinkedList的大小为0,则返回null public E pollLast() &#123; if (size==0) return null; return removeLast(); &#125; // 将e插入到双向链表开头 public void push(E e) &#123; addFirst(e); &#125; // 删除并返回第一个节点 public E pop() &#123; return removeFirst(); &#125; // 从LinkedList开始向后查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeFirstOccurrence(Object o) &#123; return remove(o); &#125; // 从LinkedList末尾向前查找，删除第一个值为元素(o)的节点 // 从链表开始查找，如存在节点的值为元素(o)的节点，则删除该节点 public boolean removeLastOccurrence(Object o) &#123; if (o==null) &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (e.element==null) &#123; remove(e); return true; &#125; &#125; &#125; else &#123; for (Entry&lt;E&gt; e = header.previous; e != header; e = e.previous) &#123; if (o.equals(e.element)) &#123; remove(e); return true; &#125; &#125; &#125; return false; &#125; // 返回“index到末尾的全部节点”对应的ListIterator对象(List迭代器) public ListIterator&lt;E&gt; listIterator(int index) &#123; return new ListItr(index); &#125; // List迭代器 private class ListItr implements ListIterator&lt;E&gt; &#123; // 上一次返回的节点 private Entry&lt;E&gt; lastReturned = header; // 下一个节点 private Entry&lt;E&gt; next; // 下一个节点对应的索引值 private int nextIndex; // 期望的改变计数。用来实现fail-fast机制。 private int expectedModCount = modCount; // 构造函数。 // 从index位置开始进行迭代 ListItr(int index) &#123; // index的有效性处理 if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+size); // 若 “index 小于 ‘双向链表长度的一半’”，则从第一个元素开始往后查找； // 否则，从最后一个元素往前查找。 if (index &lt; (size &gt;&gt; 1)) &#123; next = header.next; for (nextIndex=0; nextIndex&lt;index; nextIndex++) next = next.next; &#125; else &#123; next = header; for (nextIndex=size; nextIndex&gt;index; nextIndex--) next = next.previous; &#125; &#125; // 是否存在下一个元素 public boolean hasNext() &#123; // 通过元素索引是否等于“双向链表大小”来判断是否达到最后。 return nextIndex != size; &#125; // 获取下一个元素 public E next() &#123; checkForComodification(); if (nextIndex == size) throw new NoSuchElementException(); lastReturned = next; // next指向链表的下一个元素 next = next.next; nextIndex++; return lastReturned.element; &#125; // 是否存在上一个元素 public boolean hasPrevious() &#123; // 通过元素索引是否等于0，来判断是否达到开头。 return nextIndex != 0; &#125; // 获取上一个元素 public E previous() &#123; if (nextIndex == 0) throw new NoSuchElementException(); // next指向链表的上一个元素 lastReturned = next = next.previous; nextIndex--; checkForComodification(); return lastReturned.element; &#125; // 获取下一个元素的索引 public int nextIndex() &#123; return nextIndex; &#125; // 获取上一个元素的索引 public int previousIndex() &#123; return nextIndex-1; &#125; // 删除当前元素。 // 删除双向链表中的当前节点 public void remove() &#123; checkForComodification(); Entry&lt;E&gt; lastNext = lastReturned.next; try &#123; LinkedList.this.remove(lastReturned); &#125; catch (NoSuchElementException e) &#123; throw new IllegalStateException(); &#125; if (next==lastReturned) next = lastNext; else nextIndex--; lastReturned = header; expectedModCount++; &#125; // 设置当前节点为e public void set(E e) &#123; if (lastReturned == header) throw new IllegalStateException(); checkForComodification(); lastReturned.element = e; &#125; // 将e添加到当前节点的前面 public void add(E e) &#123; checkForComodification(); lastReturned = header; addBefore(e, next); nextIndex++; expectedModCount++; &#125; // 判断 “modCount和expectedModCount是否相等”，依次来实现fail-fast机制。 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; // 双向链表的节点所对应的数据结构。 // 包含3部分：上一节点，下一节点，当前节点值。 private static class Entry&lt;E&gt; &#123; // 当前节点所包含的值 E element; // 下一个节点 Entry&lt;E&gt; next; // 上一个节点 Entry&lt;E&gt; previous; /** * 链表节点的构造函数。 * 参数说明： * element —— 节点所包含的数据 * next —— 下一个节点 * previous —— 上一个节点 */ Entry(E element, Entry&lt;E&gt; next, Entry&lt;E&gt; previous) &#123; this.element = element; this.next = next; this.previous = previous; &#125; &#125; // 将节点(节点数据是e)添加到entry节点之前。 private Entry&lt;E&gt; addBefore(E e, Entry&lt;E&gt; entry) &#123; // 新建节点newEntry，将newEntry插入到节点e之前；并且设置newEntry的数据是e Entry&lt;E&gt; newEntry = new Entry&lt;E&gt;(e, entry, entry.previous); newEntry.previous.next = newEntry; newEntry.next.previous = newEntry; // 修改LinkedList大小 size++; // 修改LinkedList的修改统计数：用来实现fail-fast机制。 modCount++; return newEntry; &#125; // 将节点从链表中删除 private E remove(Entry&lt;E&gt; e) &#123; if (e == header) throw new NoSuchElementException(); E result = e.element; e.previous.next = e.next; e.next.previous = e.previous; e.next = e.previous = null; e.element = null; size--; modCount++; return result; &#125; // 反向迭代器 public Iterator&lt;E&gt; descendingIterator() &#123; return new DescendingIterator(); &#125; // 反向迭代器实现类。 private class DescendingIterator implements Iterator &#123; final ListItr itr = new ListItr(size()); // 反向迭代器是否下一个元素。 // 实际上是判断双向链表的当前节点是否达到开头 public boolean hasNext() &#123; return itr.hasPrevious(); &#125; // 反向迭代器获取下一个元素。 // 实际上是获取双向链表的前一个节点 public E next() &#123; return itr.previous(); &#125; // 删除当前节点 public void remove() &#123; itr.remove(); &#125; &#125; // 返回LinkedList的Object[]数组 public Object[] toArray() &#123; // 新建Object[]数组 Object[] result = new Object[size]; int i = 0; // 将链表中所有节点的数据都添加到Object[]数组中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; return result; &#125; // 返回LinkedList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; LinkedList的元素个数(意味着数组a不能容纳LinkedList中全部元素) // 则新建一个T[]数组，T[]的大小为LinkedList大小，并将该T[]赋值给a。 if (a.length &lt; size) a = (T[])java.lang.reflect.Array.newInstance( a.getClass().getComponentType(), size); // 将链表中所有节点的数据都添加到数组a中 int i = 0; Object[] result = a; for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) result[i++] = e.element; if (a.length &gt; size) a[size] = null; return a; &#125; // 克隆函数。返回LinkedList的克隆对象。 public Object clone() &#123; LinkedList&lt;E&gt; clone = null; // 克隆一个LinkedList克隆对象 try &#123; clone = (LinkedList&lt;E&gt;) super.clone(); &#125; catch (CloneNotSupportedException e) &#123; throw new InternalError(); &#125; // 新建LinkedList表头节点 clone.header = new Entry&lt;E&gt;(null, null, null); clone.header.next = clone.header.previous = clone.header; clone.size = 0; clone.modCount = 0; // 将链表中所有节点的数据都添加到克隆对象中 for (Entry&lt;E&gt; e = header.next; e != header; e = e.next) clone.add(e.element); return clone; &#125; // java.io.Serializable的写入函数 // 将LinkedList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; // Write out any hidden serialization magic s.defaultWriteObject(); // 写入“容量” s.writeInt(size); // 将链表中所有节点的数据都写入到输出流中 for (Entry e = header.next; e != header; e = e.next) s.writeObject(e.element); &#125; // java.io.Serializable的读取函数：根据写入方式反向读出 // 先将LinkedList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in any hidden serialization magic s.defaultReadObject(); // 从输入流中读取“容量” int size = s.readInt(); // 新建链表表头节点 header = new Entry&lt;E&gt;(null, null, null); header.next = header.previous = header; // 从输入流中将“所有的元素值”并逐个添加到链表中 for (int i=0; i&lt;size; i++) addBefore((E)s.readObject(), header); &#125;&#125; 总结： 1、LinkedList 实际上是通过双向链表去实现的。它包含一个非常重要的内部类：Entry。Entry是双向链表节点所对应的数据结构，它包括的属性有：当前节点所包含的值，上一个节点，下一个节点。 2、从LinkedList的实现方式中可以发现，它不存在LinkedList容量不足的问题。 3、LinkedList的克隆函数，即是将全部元素克隆到一个新的LinkedList对象中。 4、LinkedList实现java.io.Serializable。当写入到输出流时，先写入“容量”，再依次写入“每一个节点保护的值”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 5、由于LinkedList实现了Deque，而Deque接口定义了在双端队列两端访问元素的方法。提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）。 总结起来如下表格： 第一个元素 第一个元素 最后一个元素 最后一个元素 抛出异常 特殊值 抛出异常 特殊值 插入 addFirst(e) offerFirst(e) addLast(e) offerLast(e) 移除 removeFirst() pollFirst() removeLast() pollLast() 检查 getFirst() peekFirst() getLast() peekLast() 6、LinkedList可以作为FIFO(先进先出)的队列，作为FIFO的队列时，下表的方法等价： 队列方法 等效方法 add(e) addLast(e) offer(e) offerLast(e) remove() removeFirst() poll() pollFirst() element() getFirst() peek() peekFirst() 7、LinkedList可以作为LIFO(后进先出)的栈，作为LIFO的栈时，下表的方法等价： 栈方法 等效方法 push(e) addFirst(e) pop() removeFirst() peek() peekFirst() LinkedList遍历方式LinkedList遍历方式 LinkedList支持多种遍历方式。建议不要采用随机访问的方式去遍历LinkedList，而采用逐个遍历的方式。 第一种，通过迭代器遍历。即通过Iterator去遍历。12for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); 第二种，通过快速随机访问遍历LinkedList1234int size = list.size();for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; 第三种，通过另外一种for循环来遍历LinkedList12for (Integer integ:list) ; 通过pollFirst()来遍历LinkedList12while(list.pollFirst() != null) ; 通过pollLast()来遍历LinkedList12while(list.pollLast() != null) ; 通过removeFirst()来遍历LinkedList12345try &#123; while(list.removeFirst() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; 通过removeLast()来遍历LinkedList12345try &#123; while(list.removeLast() != null) ;&#125; catch (NoSuchElementException e) &#123;&#125; 测试这些遍历方式效率的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc 测试LinkedList的几种遍历方式和效率 * * @author skywang */public class LinkedListThruTest &#123; public static void main(String[] args) &#123; // 通过Iterator遍历LinkedList iteratorLinkedListThruIterator(getLinkedList()) ; // 通过快速随机访问遍历LinkedList iteratorLinkedListThruForeach(getLinkedList()) ; // 通过for循环的变种来访问遍历LinkedList iteratorThroughFor2(getLinkedList()) ; // 通过PollFirst()遍历LinkedList iteratorThroughPollFirst(getLinkedList()) ; // 通过PollLast()遍历LinkedList iteratorThroughPollLast(getLinkedList()) ; // 通过removeFirst()遍历LinkedList iteratorThroughRemoveFirst(getLinkedList()) ; // 通过removeLast()遍历LinkedList iteratorThroughRemoveLast(getLinkedList()) ; &#125; private static LinkedList getLinkedList() &#123; LinkedList llist = new LinkedList(); for (int i=0; i&lt;100000; i++) llist.addLast(i); return llist; &#125; /** * 通过快迭代器遍历LinkedList */ private static void iteratorLinkedListThruIterator(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext();) iter.next(); // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorLinkedListThruIterator：" + interval+" ms"); &#125; /** * 通过快速随机访问遍历LinkedList */ private static void iteratorLinkedListThruForeach(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); int size = list.size(); for (int i=0; i&lt;size; i++) &#123; list.get(i); &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorLinkedListThruForeach：" + interval+" ms"); &#125; /** * 通过另外一种for循环来遍历LinkedList */ private static void iteratorThroughFor2(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); for (Integer integ:list) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughFor2：" + interval+" ms"); &#125; /** * 通过pollFirst()来遍历LinkedList */ private static void iteratorThroughPollFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollFirst() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughPollFirst：" + interval+" ms"); &#125; /** * 通过pollLast()来遍历LinkedList */ private static void iteratorThroughPollLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); while(list.pollLast() != null) ; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughPollLast：" + interval+" ms"); &#125; /** * 通过removeFirst()来遍历LinkedList */ private static void iteratorThroughRemoveFirst(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeFirst() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughRemoveFirst：" + interval+" ms"); &#125; /** * 通过removeLast()来遍历LinkedList */ private static void iteratorThroughRemoveLast(LinkedList&lt;Integer&gt; list) &#123; if (list == null) return ; // 记录开始时间 long start = System.currentTimeMillis(); try &#123; while(list.removeLast() != null) ; &#125; catch (NoSuchElementException e) &#123; &#125; // 记录结束时间 long end = System.currentTimeMillis(); long interval = end - start; System.out.println("iteratorThroughRemoveLast：" + interval+" ms"); &#125;&#125; 执行结果： 1234567iteratorLinkedListThruIterator：8 msiteratorLinkedListThruForeach：3724 msiteratorThroughFor2：5 msiteratorThroughPollFirst：8 msiteratorThroughPollLast：6 msiteratorThroughRemoveFirst：2 msiteratorThroughRemoveLast：2 ms 由此可见，遍历LinkedList时，使用removeFist()或removeLast()效率最高。但用它们遍历时，会删除原始数据；若单纯只读取，而不删除，应该使用第3种 (增强 for循环) 遍历方式。无论如何，千万不要通过随机访问去遍历LinkedList！ LinkedList示例下面通过一个示例来学习如何使用LinkedList的常用API 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158import java.util.List;import java.util.Iterator;import java.util.LinkedList;import java.util.NoSuchElementException;/* * @desc LinkedList测试程序。 * */public class LinkedListTest &#123; public static void main(String[] args) &#123; // 测试LinkedList的API testLinkedListAPIs() ; // 将LinkedList当作 LIFO(后进先出)的堆栈 useLinkedListAsLIFO(); // 将LinkedList当作 FIFO(先进先出)的队列 useLinkedListAsFIFO(); &#125; /* * 测试LinkedList中部分API */ private static void testLinkedListAPIs() &#123; String val = null; //LinkedList llist; //llist.offer("10"); // 新建一个LinkedList LinkedList llist = new LinkedList(); //---- 添加操作 ---- // 依次添加1,2,3 llist.add("1"); llist.add("2"); llist.add("3"); // 将“4”添加到第一个位置 llist.add(1, "4"); System.out.println("\nTest \"addFirst(), removeFirst(), getFirst()\""); // (01) 将“10”添加到第一个位置。 失败的话，抛出异常！ llist.addFirst("10"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，抛出异常！ System.out.println("llist.removeFirst():"+llist.removeFirst()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，抛出异常！ System.out.println("llist.getFirst():"+llist.getFirst()); System.out.println("\nTest \"offerFirst(), pollFirst(), peekFirst()\""); // (01) 将“10”添加到第一个位置。 返回true。 llist.offerFirst("10"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println("llist.pollFirst():"+llist.pollFirst()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println("llist.peekFirst():"+llist.peekFirst()); System.out.println("\nTest \"addLast(), removeLast(), getLast()\""); // (01) 将“20”添加到最后一个位置。 失败的话，抛出异常！ llist.addLast("20"); System.out.println("llist:"+llist); // (02) 将最后一个元素删除。 失败的话，抛出异常！ System.out.println("llist.removeLast():"+llist.removeLast()); System.out.println("llist:"+llist); // (03) 获取最后一个元素。 失败的话，抛出异常！ System.out.println("llist.getLast():"+llist.getLast()); System.out.println("\nTest \"offerLast(), pollLast(), peekLast()\""); // (01) 将“20”添加到第一个位置。 返回true。 llist.offerLast("20"); System.out.println("llist:"+llist); // (02) 将第一个元素删除。 失败的话，返回null。 System.out.println("llist.pollLast():"+llist.pollLast()); System.out.println("llist:"+llist); // (03) 获取第一个元素。 失败的话，返回null。 System.out.println("llist.peekLast():"+llist.peekLast()); // 将第3个元素设置300。不建议在LinkedList中使用此操作，因为效率低！ llist.set(2, "300"); // 获取第3个元素。不建议在LinkedList中使用此操作，因为效率低！ System.out.println("\nget(3):"+llist.get(2)); // ---- toArray(T[] a) ---- // 将LinkedList转行为数组 String[] arr = (String[])llist.toArray(new String[0]); for (String str:arr) System.out.println("str:"+str); // 输出大小 System.out.println("size:"+llist.size()); // 清空LinkedList llist.clear(); // 判断LinkedList是否为空 System.out.println("isEmpty():"+llist.isEmpty()+"\n"); &#125; /** * 将LinkedList当作 LIFO(后进先出)的堆栈 */ private static void useLinkedListAsLIFO() &#123; System.out.println("\nuseLinkedListAsLIFO"); // 新建一个LinkedList LinkedList stack = new LinkedList(); // 将1,2,3,4添加到堆栈中 stack.push("1"); stack.push("2"); stack.push("3"); stack.push("4"); // 打印“栈” System.out.println("stack:"+stack); // 删除“栈顶元素” System.out.println("stack.pop():"+stack.pop()); // 取出“栈顶元素” System.out.println("stack.peek():"+stack.peek()); // 打印“栈” System.out.println("stack:"+stack); &#125; /** * 将LinkedList当作 FIFO(先进先出)的队列 */ private static void useLinkedListAsFIFO() &#123; System.out.println("\nuseLinkedListAsFIFO"); // 新建一个LinkedList LinkedList queue = new LinkedList(); // 将10,20,30,40添加到队列。每次都是插入到末尾 queue.add("10"); queue.add("20"); queue.add("30"); queue.add("40"); // 打印“队列” System.out.println("queue:"+queue); // 删除(队列的第一个元素) System.out.println("queue.remove():"+queue.remove()); // 读取(队列的第一个元素) System.out.println("queue.element():"+queue.element()); // 打印“队列” System.out.println("queue:"+queue); &#125;&#125; 运行结果 1234567891011121314151617181920212223242526272829303132333435363738394041424344Test "addFirst(), removeFirst(), getFirst()"llist:[10, 1, 4, 2, 3]llist.removeFirst():10llist:[1, 4, 2, 3]llist.getFirst():1Test "offerFirst(), pollFirst(), peekFirst()"llist:[10, 1, 4, 2, 3]llist.pollFirst():10llist:[1, 4, 2, 3]llist.peekFirst():1Test "addLast(), removeLast(), getLast()"llist:[1, 4, 2, 3, 20]llist.removeLast():20llist:[1, 4, 2, 3]llist.getLast():3Test "offerLast(), pollLast(), peekLast()"llist:[1, 4, 2, 3, 20]llist.pollLast():20llist:[1, 4, 2, 3]llist.peekLast():3get(3):300str:1str:4str:300str:3size:4isEmpty():trueuseLinkedListAsLIFOstack:[4, 3, 2, 1]stack.pop():4stack.peek():3stack:[3, 2, 1]useLinkedListAsFIFOqueue:[10, 20, 30, 40]queue.remove():10queue.element():20queue:[20, 30, 40]]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>LinkedList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Ventor]]></title>
    <url>%2F2015%2F05%2F20%2F8-Collection-Map%2F6-Vector%2F</url>
    <content type="text"><![CDATA[Vector简介Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。 Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是Java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了Cloneable 接口，即实现clone()函数。它能被克隆。 和ArrayList不同，Vector中的操作是线程安全的。 Vector的构造函数Vector共有4个构造函数 1234567891011// 默认构造函数Vector()// capacity是Vector的默认容量大小。当由于增加数据导致容量增加时，每次容量会增加一倍。Vector(int capacity)// capacity是Vector的默认容量大小，capacityIncrement是每次Vector容量增加时的增量值。Vector(int capacity, int capacityIncrement)// 创建一个包含collection的VectorVector(Collection&lt;? extends E&gt; collection) Vector的API1234567891011121314151617181920212223242526272829303132333435363738394041synchronized boolean add(E object) void add(int location, E object)synchronized boolean addAll(Collection&lt;? extends E&gt; collection)synchronized boolean addAll(int location, Collection&lt;? extends E&gt; collection)synchronized void addElement(E object)synchronized int capacity() void clear()synchronized Object clone() boolean contains(Object object)synchronized boolean containsAll(Collection&lt;?&gt; collection)synchronized void copyInto(Object[] elements)synchronized E elementAt(int location) Enumeration&lt;E&gt; elements()synchronized void ensureCapacity(int minimumCapacity)synchronized boolean equals(Object object)synchronized E firstElement() E get(int location)synchronized int hashCode()synchronized int indexOf(Object object, int location) int indexOf(Object object)synchronized void insertElementAt(E object, int location)synchronized boolean isEmpty()synchronized E lastElement()synchronized int lastIndexOf(Object object, int location)synchronized int lastIndexOf(Object object)synchronized E remove(int location) boolean remove(Object object)synchronized boolean removeAll(Collection&lt;?&gt; collection)synchronized void removeAllElements()synchronized boolean removeElement(Object object)synchronized void removeElementAt(int location)synchronized boolean retainAll(Collection&lt;?&gt; collection)synchronized E set(int location, E object)synchronized void setElementAt(E object, int location)synchronized void setSize(int length)synchronized int size()synchronized List&lt;E&gt; subList(int start, int end)synchronized &lt;T&gt; T[] toArray(T[] contents)synchronized Object[] toArray()synchronized String toString()synchronized void trimToSize() Vector数据结构Vector的继承关系123456789java.lang.Object ↳ java.util.AbstractCollection&lt;E&gt; ↳ java.util.AbstractList&lt;E&gt; ↳ java.util.Vector&lt;E&gt;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; Vector与Collection关系图： Vector的数据结构和ArrayList差不多，它包含了3个成员变量：elementData , elementCount， capacityIncrement。 elementData 是”Object[]类型的数组”，它保存了添加到Vector中的元素。elementData是个动态数组，如果初始化Vector时，没指定动态数组的&gt;大小，则使用默认大小10。随着Vector中元素的增加，Vector的容量也会动态增长，capacityIncrement是与容量增长相关的增长系数，具体的增长方式，请参考源码分析中的ensureCapacity()函数。 elementCount 是动态数组的实际大小。 capacityIncrement 是动态数组的增长系数。如果在创建Vector时，指定了capacityIncrement的大小；则，每次当Vector中动态数组容量增加时，增加的大小都是capacityIncrement。 Vector源码解析(基于JDK1.6.0_45)为了更了解Vector的原理，下面对Vector源码代码作出分析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471package java.util;public class Vector&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 保存Vector中数据的数组 protected Object[] elementData; // 实际数据的数量 protected int elementCount; // 容量增长系数 protected int capacityIncrement; // Vector的序列版本号 private static final long serialVersionUID = -2767605614048989439L; // Vector构造函数。默认容量是10。 public Vector() &#123; this(10); &#125; // 指定Vector容量大小的构造函数 public Vector(int initialCapacity) &#123; this(initialCapacity, 0); &#125; // 指定Vector"容量大小"和"增长系数"的构造函数 public Vector(int initialCapacity, int capacityIncrement) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); // 新建一个数组，数组容量是initialCapacity this.elementData = new Object[initialCapacity]; // 设置容量增长系数 this.capacityIncrement = capacityIncrement; &#125; // 指定集合的Vector构造函数。 public Vector(Collection&lt;? extends E&gt; c) &#123; // 获取“集合(c)”的数组，并将其赋值给elementData elementData = c.toArray(); // 设置数组长度 elementCount = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, elementCount, Object[].class); &#125; // 将数组Vector的全部元素都拷贝到数组anArray中 public synchronized void copyInto(Object[] anArray) &#123; System.arraycopy(elementData, 0, anArray, 0, elementCount); &#125; // 将当前容量值设为 =实际元素个数 public synchronized void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (elementCount &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, elementCount); &#125; &#125; // 确认“Vector容量”的帮助函数 private void ensureCapacityHelper(int minCapacity) &#123; int oldCapacity = elementData.length; // 当Vector的容量不足以容纳当前的全部元素，增加容量大小。 // 若 容量增量系数&gt;0(即capacityIncrement&gt;0)，则将容量增大当capacityIncrement // 否则，将容量增大一倍。 if (minCapacity &gt; oldCapacity) &#123; Object[] oldData = elementData; int newCapacity = (capacityIncrement &gt; 0) ? (oldCapacity + capacityIncrement) : (oldCapacity * 2); if (newCapacity &lt; minCapacity) &#123; newCapacity = minCapacity; &#125; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 确定Vector的容量。 public synchronized void ensureCapacity(int minCapacity) &#123; // 将Vector的改变统计数+1 modCount++; ensureCapacityHelper(minCapacity); &#125; // 设置容量值为 newSize public synchronized void setSize(int newSize) &#123; modCount++; if (newSize &gt; elementCount) &#123; // 若 "newSize 大于 Vector容量"，则调整Vector的大小。 ensureCapacityHelper(newSize); &#125; else &#123; // 若 "newSize 小于/等于 Vector容量"，则将newSize位置开始的元素都设置为null for (int i = newSize ; i &lt; elementCount ; i++) &#123; elementData[i] = null; &#125; &#125; elementCount = newSize; &#125; // 返回“Vector的总的容量” public synchronized int capacity() &#123; return elementData.length; &#125; // 返回“Vector的实际大小”，即Vector中元素个数 public synchronized int size() &#123; return elementCount; &#125; // 判断Vector是否为空 public synchronized boolean isEmpty() &#123; return elementCount == 0; &#125; // 返回“Vector中全部元素对应的Enumeration” public Enumeration&lt;E&gt; elements() &#123; // 通过匿名类实现Enumeration return new Enumeration&lt;E&gt;() &#123; int count = 0; // 是否存在下一个元素 public boolean hasMoreElements() &#123; return count &lt; elementCount; &#125; // 获取下一个元素 public E nextElement() &#123; synchronized (Vector.this) &#123; if (count &lt; elementCount) &#123; return (E)elementData[count++]; &#125; &#125; throw new NoSuchElementException("Vector Enumeration"); &#125; &#125;; &#125; // 返回Vector中是否包含对象(o) public boolean contains(Object o) &#123; return indexOf(o, 0) &gt;= 0; &#125; // 从index位置开始向后查找元素(o)。 // 若找到，则返回元素的索引值；否则，返回-1 public synchronized int indexOf(Object o, int index) &#123; if (o == null) &#123; // 若查找元素为null，则正向找出null元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则正向找出该元素，并返回它对应的序号 for (int i = index ; i &lt; elementCount ; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 查找并返回元素(o)在Vector中的索引值 public int indexOf(Object o) &#123; return indexOf(o, 0); &#125; // 从后向前查找元素(o)。并返回元素的索引 public synchronized int lastIndexOf(Object o) &#123; return lastIndexOf(o, elementCount-1); &#125; // 从后向前查找元素(o)。开始位置是从前向后的第index个数； // 若找到，则返回元素的“索引值”；否则，返回-1。 public synchronized int lastIndexOf(Object o, int index) &#123; if (index &gt;= elementCount) throw new IndexOutOfBoundsException(index + " &gt;= "+ elementCount); if (o == null) &#123; // 若查找元素为null，则反向找出null元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; // 若查找元素不为null，则反向找出该元素，并返回它对应的序号 for (int i = index; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回Vector中index位置的元素。 // 若index月结，则抛出异常 public synchronized E elementAt(int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; return (E)elementData[index]; &#125; // 获取Vector中的第一个元素。 // 若失败，则抛出异常！ public synchronized E firstElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return (E)elementData[0]; &#125; // 获取Vector中的最后一个元素。 // 若失败，则抛出异常！ public synchronized E lastElement() &#123; if (elementCount == 0) &#123; throw new NoSuchElementException(); &#125; return (E)elementData[elementCount - 1]; &#125; // 设置index位置的元素值为obj public synchronized void setElementAt(E obj, int index) &#123; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; elementData[index] = obj; &#125; // 删除index位置的元素 public synchronized void removeElementAt(int index) &#123; modCount++; if (index &gt;= elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt;= " + elementCount); &#125; else if (index &lt; 0) &#123; throw new ArrayIndexOutOfBoundsException(index); &#125; int j = elementCount - index - 1; if (j &gt; 0) &#123; System.arraycopy(elementData, index + 1, elementData, index, j); &#125; elementCount--; elementData[elementCount] = null; /* to let gc do its work */ &#125; // 在index位置处插入元素(obj) public synchronized void insertElementAt(E obj, int index) &#123; modCount++; if (index &gt; elementCount) &#123; throw new ArrayIndexOutOfBoundsException(index + " &gt; " + elementCount); &#125; ensureCapacityHelper(elementCount + 1); System.arraycopy(elementData, index, elementData, index + 1, elementCount - index); elementData[index] = obj; elementCount++; &#125; // 将“元素obj”添加到Vector末尾 public synchronized void addElement(E obj) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = obj; &#125; // 在Vector中查找并删除元素obj。 // 成功的话，返回true；否则，返回false。 public synchronized boolean removeElement(Object obj) &#123; modCount++; int i = indexOf(obj); if (i &gt;= 0) &#123; removeElementAt(i); return true; &#125; return false; &#125; // 删除Vector中的全部元素 public synchronized void removeAllElements() &#123; modCount++; // 将Vector中的全部元素设为null for (int i = 0; i &lt; elementCount; i++) elementData[i] = null; elementCount = 0; &#125; // 克隆函数 public synchronized Object clone() &#123; try &#123; Vector&lt;E&gt; v = (Vector&lt;E&gt;) super.clone(); // 将当前Vector的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, elementCount); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // 返回Object数组 public synchronized Object[] toArray() &#123; return Arrays.copyOf(elementData, elementCount); &#125; // 返回Vector的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public synchronized &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; Vector的元素个数； // 则新建一个T[]数组，数组大小是“Vector的元素个数”，并将“Vector”全部拷贝到新数组中 if (a.length &lt; elementCount) return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass()); // 若数组a的大小 &gt;= Vector的元素个数； // 则将Vector的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, elementCount); if (a.length &gt; elementCount) a[elementCount] = null; return a; &#125; // 获取index位置的元素 public synchronized E get(int index) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return (E)elementData[index]; &#125; // 设置index位置的值为element。并返回index位置的原始值 public synchronized E set(int index, E element) &#123; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; elementData[index] = element; return (E)oldValue; &#125; // 将“元素e”添加到Vector最后。 public synchronized boolean add(E e) &#123; modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; &#125; // 删除Vector中的元素o public boolean remove(Object o) &#123; return removeElement(o); &#125; // 在index位置添加元素element public void add(int index, E element) &#123; insertElementAt(element, index); &#125; // 删除index位置的元素，并返回index位置的原始值 public synchronized E remove(int index) &#123; modCount++; if (index &gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); Object oldValue = elementData[index]; int numMoved = elementCount - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--elementCount] = null; // Let gc do its work return (E)oldValue; &#125; // 清空Vector public void clear() &#123; removeAllElements(); &#125; // 返回Vector是否包含集合c public synchronized boolean containsAll(Collection&lt;?&gt; c) &#123; return super.containsAll(c); &#125; // 将集合c添加到Vector中 public synchronized boolean addAll(Collection&lt;? extends E&gt; c) &#123; modCount++; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); // 将集合c的全部元素拷贝到数组elementData中 System.arraycopy(a, 0, elementData, elementCount, numNew); elementCount += numNew; return numNew != 0; &#125; // 删除集合c的全部元素 public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123; return super.removeAll(c); &#125; // 删除“非集合c中的元素” public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123; return super.retainAll(c); &#125; // 从index位置开始，将集合c添加到Vector中 public synchronized boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; modCount++; if (index &lt; 0 || index &gt; elementCount) throw new ArrayIndexOutOfBoundsException(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityHelper(elementCount + numNew); int numMoved = elementCount - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); elementCount += numNew; return numNew != 0; &#125; // 返回两个对象是否相等 public synchronized boolean equals(Object o) &#123; return super.equals(o); &#125; // 计算哈希值 public synchronized int hashCode() &#123; return super.hashCode(); &#125; // 调用父类的toString() public synchronized String toString() &#123; return super.toString(); &#125; // 获取Vector中fromIndex(包括)到toIndex(不包括)的子集 public synchronized List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; return Collections.synchronizedList(super.subList(fromIndex, toIndex), this); &#125; // 删除Vector中fromIndex到toIndex的元素 protected synchronized void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = elementCount - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newElementCount = elementCount - (toIndex-fromIndex); while (elementCount != newElementCount) elementData[--elementCount] = null; &#125; // java.io.Serializable的写入函数 private synchronized void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException &#123; s.defaultWriteObject(); &#125;&#125; 总结： Vector实际上是通过一个数组去保存数据的。当我们构造Vecotr时；若使用默认构造函数，则Vector的默认容量大小是10。 当Vector容量不足以容纳全部元素时，Vector的容量会增加。若容量增加系数 &gt; 0，则将容量的值增加“容量增加系数”；否则，将容量大小增加一倍。 Vector的克隆函数，即是将全部元素克隆到一个数组中。 Vector遍历方式Vector支持4种遍历方式。建议使用下面的第二种去遍历Vector，因为效率问题。 第一种，通过迭代器遍历。即通过Iterator去遍历。12345Integer value = null;int size = vec.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)vec.get(i); &#125; 第二种，随机访问，通过索引值去遍历。由于Vector实现了RandomAccess接口，它支持通过索引值去随机访问元素。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108Integer value = null;int size = vec.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)vec.get(i); &#125;``` ## 第三种，另一种for循环。如下：```javaInteger value = null;for (Integer integ:vec) &#123; value = integ;&#125;``` ## 第四种，Enumeration遍历。如下： ```javaInteger value = null;Enumeration enu = vec.elements();while (enu.hasMoreElements()) &#123; value = (Integer)enu.nextElement();&#125;``` 测试这些遍历方式效率的代码如下：```javaimport java.util.*;/* * @desc Vector遍历方式和效率的测试程序。 * * @author skywang */public class VectorRandomAccessTest &#123; public static void main(String[] args) &#123; Vector vec= new Vector(); for (int i=0; i&lt;100000; i++) vec.add(i); iteratorThroughRandomAccess(vec) ; iteratorThroughIterator(vec) ; iteratorThroughFor2(vec) ; iteratorThroughEnumeration(vec) ; &#125; private static void isRandomAccessSupported(List list) &#123; if (list instanceof RandomAccess) &#123; System.out.println("RandomAccess implemented!"); &#125; else &#123; System.out.println("RandomAccess not implemented!"); &#125; &#125; public static void iteratorThroughRandomAccess(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughRandomAccess：" + interval+" ms"); &#125; public static void iteratorThroughIterator(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; iter.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughIterator：" + interval+" ms"); &#125; public static void iteratorThroughFor2(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughFor2：" + interval+" ms"); &#125; public static void iteratorThroughEnumeration(Vector vec) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Enumeration enu = vec.elements(); enu.hasMoreElements(); ) &#123; enu.nextElement(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughEnumeration：" + interval+" ms"); &#125;&#125; 运行结果： 1234iteratorThroughRandomAccess：6 msiteratorThroughIterator：9 msiteratorThroughFor2：8 msiteratorThroughEnumeration：7 ms 总结：遍历Vector，使用索引的随机访问方式最快，使用迭代器最慢。 Vector示例下面通过示例学习如何使用Vector 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.util.Vector;import java.util.List;import java.util.Iterator;import java.util.Enumeration;/** * @desc Vector测试函数：遍历Vector和常用API * * @author skywang */public class VectorTest &#123; public static void main(String[] args) &#123; // 新建Vector Vector vec = new Vector(); // 添加元素 vec.add("1"); vec.add("2"); vec.add("3"); vec.add("4"); vec.add("5"); // 设置第一个元素为100 vec.set(0, "100"); // 将“500”插入到第3个位置 vec.add(2, "300"); System.out.println("vec:"+vec); // (顺序查找)获取100的索引 System.out.println("vec.indexOf(100):"+vec.indexOf("100")); // (倒序查找)获取100的索引 System.out.println("vec.lastIndexOf(100):"+vec.lastIndexOf("100")); // 获取第一个元素 System.out.println("vec.firstElement():"+vec.firstElement()); // 获取第3个元素 System.out.println("vec.elementAt(2):"+vec.elementAt(2)); // 获取最后一个元素 System.out.println("vec.lastElement():"+vec.lastElement()); // 获取Vector的大小 System.out.println("size:"+vec.size()); // 获取Vector的总的容量 System.out.println("capacity:"+vec.capacity()); // 获取vector的“第2”到“第4”个元素 System.out.println("vec 2 to 4:"+vec.subList(1, 4)); // 通过Enumeration遍历Vector Enumeration enu = vec.elements(); while(enu.hasMoreElements()) System.out.println("nextElement():"+enu.nextElement()); Vector retainVec = new Vector(); retainVec.add("100"); retainVec.add("300"); // 获取“vec”中包含在“retainVec中的元素”的集合 System.out.println("vec.retain():"+vec.retainAll(retainVec)); System.out.println("vec:"+vec); // 获取vec对应的String数组 String[] arr = (String[]) vec.toArray(new String[0]); for (String str:arr) System.out.println("str:"+str); // 清空Vector。clear()和removeAllElements()一样！ vec.clear();// vec.removeAllElements(); // 判断Vector是否为空 System.out.println("vec.isEmpty():"+vec.isEmpty()); &#125; &#125; 运行结果： 1234567891011121314151617181920vec:[100, 2, 300, 3, 4, 5]vec.indexOf(100):0vec.lastIndexOf(100):0vec.firstElement():100vec.elementAt(2):300vec.lastElement():5size:6capacity:10vec 2 to 4:[2, 300, 3]nextElement():100nextElement():2nextElement():300nextElement():3nextElement():4nextElement():5vec.retain():truevec:[100, 300]str:100str:300vec.isEmpty():true]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>Ventor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Fail-Fast]]></title>
    <url>%2F2015%2F05%2F08%2F8-Collection-Map%2F4-fail-fast%2F</url>
    <content type="text"><![CDATA[1、fail-fast简介fail-fast 机制是 Java 集合 (Collection) 中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。 例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。 在详细介绍 fail-fast机制的原理之前，先通过一个示例来认识 fail-fast。 2、fail-fast示 例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;import java.util.concurrent.*;/* * @desc java集合中Fast-Fail的测试程序。 * * fast-fail事件产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过iterator去遍历集合时，该集合的内容被其他线程所改变；则会抛出ConcurrentModificationException异常。 * fast-fail解决办法：通过java.util.concurrent集合包下的相应类去处理，则不会产生fast-fail事件。 * * 本例中，分别测试ArrayList和CopyOnWriteArrayList这两种情况。ArrayList会产生fast-fail事件，而CopyOnWriteArrayList不会产生fast-fail事件。 * (01) 使用ArrayList时，会产生fast-fail事件，抛出ConcurrentModificationException异常；定义如下： * private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); * (02) 使用时CopyOnWriteArrayList，不会产生fast-fail事件；定义如下： * private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); * */public class FastFailTest &#123; private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); //private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); public static void main(String[] args) &#123; // 同时启动两个线程对list进行操作！ new ThreadOne().start(); new ThreadTwo().start(); &#125; private static void printAll() &#123; System.out.println(""); String value = null; Iterator iter = list.iterator(); while(iter.hasNext()) &#123; value = (String)iter.next(); System.out.print(value+", "); &#125; &#125; /** * 向list中依次添加0,1,2,3,4,5，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadOne extends Thread &#123; public void run() &#123; int i = 0; while (i&lt;6) &#123; list.add(String.valueOf(i)); printAll(); i++; &#125; &#125; &#125; /** * 向list中依次添加10,11,12,13,14,15，每添加一个数之后，就通过printAll()遍历整个list */ private static class ThreadTwo extends Thread &#123; public void run() &#123; int i = 10; while (i&lt;16) &#123; list.add(String.valueOf(i)); printAll(); i++; &#125; &#125; &#125;&#125; 运行结果：运行该代码，抛出异常java.util.ConcurrentModificationException！即，产生fail-fast事件！ 结果说明：(01) FastFailTest中通过 new ThreadOne().start() 和 new ThreadTwo().start() 同时启动两个线程去操作list。 ThreadOne线程：向list中依次添加0,1,2,3,4,5。每添加一个数之后，就通过printAll()遍历整个list。 ThreadTwo线程：向list中依次添加10,11,12,13,14,15。每添加一个数之后，就通过printAll()遍历整个list。(02) 当某一个线程遍历list的过程中，list的内容被另外一个线程所改变了；就会抛出ConcurrentModificationException异常，产生fail-fast事件。 3、fail-fast 解决办法fail-fast 机制，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证 fail-fast 机制一定会发生。若在多线程环境下使用 fail-fast 机制的集合，建议使用 “java.util.concurrent包下的类”去取代“java.util包下的类”。所以，本例中只需要将 ArrayList 替换成 java.util.concurrent 包下对应的类即可。即，将代码 1private static List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 替换为 1private static List&lt;String&gt; list = new CopyOnWriteArrayList&lt;String&gt;(); 则可以解决该办法。 fail-fast原理产生fail-fast事件，是通过抛出ConcurrentModificationException异常来触发的。那么，ArrayList是如何抛出ConcurrentModificationException异常的呢? 我们知道，ConcurrentModificationException 是在操作 Iterator 时抛出的异常。我们先看看 Iterator 的源码。ArrayList 的 Iterator 是在父类 AbstractList.java 中实现的。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package java.util;public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123; ... // AbstractList中唯一的属性 // 用来记录List修改的次数：每修改一次(添加/删除等操作)，将modCount+1 protected transient int modCount = 0; // 返回List对应迭代器。实际上，是返回Itr对象。 public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; // Itr是Iterator(迭代器)的实现类 private class Itr implements Iterator&lt;E&gt; &#123; int cursor = 0; int lastRet = -1; // 修改数的记录值。 // 每次新建Itr()对象时，都会保存新建该对象时对应的modCount； // 以后每次遍历List中的元素的时候，都会比较expectedModCount和modCount是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 int expectedModCount = modCount; public boolean hasNext() &#123; return cursor != size(); &#125; public E next() &#123; // 获取下一个元素之前，都会判断“新建Itr对象时保存的modCount”和“当前的modCount”是否相等； // 若不相等，则抛出ConcurrentModificationException异常，产生fail-fast事件。 checkForComodification(); try &#123; E next = get(cursor); lastRet = cursor++; return next; &#125; catch (IndexOutOfBoundsException e) &#123; checkForComodification(); throw new NoSuchElementException(); &#125; &#125; public void remove() &#123; if (lastRet == -1) throw new IllegalStateException(); checkForComodification(); try &#123; AbstractList.this.remove(lastRet); if (lastRet &lt; cursor) cursor--; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException e) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; ...&#125; 从中，我们可以发现在调用 next() 和 remove() 时，都会执行 checkForComodification()。若 “modCount 不等于 expectedModCount”，则抛出ConcurrentModificationException异常，产生fail-fast事件。 要搞明白 fail-fast机制，我们就要需要理解什么时候 “modCount 不等于 expectedModCount”！从 Itr 类中，我们知道 expectedModCount 在创建 Itr 时，被赋值为 modCount。通过 Itr，我们知道：expectedModCount 不可能被修改为不等于 modCount。所以，需要考证的就是 modCount 何时会被修改。 接下来，我们查看 ArrayList 的源码，来看看 modCount 是如何被修改的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; ... // list中容量变化时，对应的同步函数 public void ensureCapacity(int minCapacity) &#123; modCount++; int oldCapacity = elementData.length; if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素到队列最后 public boolean add(E e) &#123; // 修改modCount ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 添加元素到指定的位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); // 修改modCount ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 添加集合 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; // 修改modCount ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 删除指定位置的元素 public E remove(int index) &#123; RangeCheck(index); // 修改modCount modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 快速删除指定位置的元素 private void fastRemove(int index) &#123; // 修改modCount modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work &#125; // 清空集合 public void clear() &#123; // 修改modCount modCount++; // Let gc do its work for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; ...&#125; 从中，我们发现：无论是add()、remove()，还是clear()，只要涉及到修改集合中的元素个数时，都会改变modCount的值。 接下来，我们再系统的梳理一下fail-fast是怎么产生的。步骤如下： 新建了一个ArrayList，名称为arrayList。 向arrayList中添加内容。 新建一个“线程a”，并在“线程a”中通过Iterator反复的读取arrayList的值。 新建一个“线程b”，在“线程b”中删除arrayList中的一个“节点A”。 这时，就会产生有趣的事件了。 在某一时刻，“线程a”创建了arrayList的Iterator。此时“节点A”仍然存在于arrayList中，创建arrayList时，expectedModCount = modCount(假设它们此时的值为N)。 在“线程a”在遍历arrayList过程中的某一时刻，“线程b”执行了，并且“线程b”删除了arrayList中的“节点A”。“线程b”执行remove()进行删除操作时，在remove()中执行了“modCount++”，此时modCount变成了N+1！“线程a”接着遍历，当它执行到next()函数时，调用checkForComodification()比较“expectedModCount”和“modCount”的大小；而“expectedModCount=N”，“modCount=N+1”,这样，便抛出ConcurrentModificationException异常，产生fail-fast事件。 至此，我们就完全了解了fail-fast是如何产生的！即，当多个线程对同一个集合进行操作的时候，某线程访问集合的过程中，该集合的内容被其他线程所改变(即其它线程通过add、remove、clear等方法，改变了modCount的值)；这时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。 5、解决fail-fast的原理上面，说明了“解决fail-fast机制的办法”，也知道了“fail-fast产生的根本原因”。接下来，我们再进一步谈谈java.util.concurrent包中是如何解决fail-fast事件的。还是以和 ArrayList 对应的 CopyOnWriteArrayList 进行说明。我们先看看 CopyOnWriteArrayList 的源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package java.util.concurrent;import java.util.*;import java.util.concurrent.locks.*;import sun.misc.Unsafe;public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; ... // 返回集合对应的迭代器 public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0); &#125; ... private static class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot; private int cursor; private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; // 新建COWIterator时，将集合中的元素保存到一个新的拷贝数组中。 // 这样，当原始集合的数据改变，拷贝数据中的值也不会变化。 snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public boolean hasPrevious() &#123; return cursor &gt; 0; &#125; public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; public E previous() &#123; if (! hasPrevious()) throw new NoSuchElementException(); return (E) snapshot[--cursor]; &#125; public int nextIndex() &#123; return cursor; &#125; public int previousIndex() &#123; return cursor-1; &#125; public void remove() &#123; throw new UnsupportedOperationException(); &#125; public void set(E e) &#123; throw new UnsupportedOperationException(); &#125; public void add(E e) &#123; throw new UnsupportedOperationException(); &#125; &#125; ...&#125; 从中，我们可以看出: 和 ArrayList 继承于 AbstractList 不同，CopyOnWriteArrayList 没有继承于 AbstractList，它仅仅只是实现了 List 接口。 ArrayList 的 iterator() 函数返回的 Iterator 是在 AbstractList 中实现的；而 CopyOnWriteArrayList 是自己实现 Iterator。 ArrayList 的 Iterator 实现类中调用 next() 时，会“调用 checkForComodification() 比较 ‘expectedModCount’ 和 ‘modCount’ 的大小”；但是，CopyOnWriteArrayList 的 Iterator 实现类中，没有所谓的 checkForComodification()，更不会抛出 ConcurrentModificationException 异常！ 为什么 CopyOnWriteArrayList 可以不比较 modCount 也能保证数据一致性？因为 getArray() 返回的 array 的类型是 volatile 的（强制内存一致性）]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>Fail-Fast</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 ArrayList]]></title>
    <url>%2F2015%2F04%2F09%2F8-Collection-Map%2F3-ArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList 简介123public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;&#125; ArrayList 是一个数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。它继承于 AbstractList，实现了 List, RandomAccess, Cloneable, java.io.Serializable 这些接口。ArrayList 继承了 AbstractList，实现了 List 接口。它是一个数组队列，提供了相关的添加、删除、修改、遍历等功能。 ArrayList 实现了 RandmoAccess 接口，即提供了随机访问功能。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在 ArrayList 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。稍后，我们会比较 List 的“快速随机访问”和“通过Iterator迭代器访问”的效率。 ArrayList 实现了 Cloneable 接口，即覆盖了函数 clone()，能被克隆。 ArrayList 实现 java.io.Serializable 接口，这意味着ArrayList支持序列化，能通过序列化去传输。 和 Vector 不同，ArrayList中的操作不是线程安全的！所以，建议在单线程中才使用 ArrayList，而在多线程中可以选择 Vector 或者 CopyOnWriteArrayList。 ArrayList 构造函数12345678// 默认构造函数ArrayList()// capacity 是 ArrayList 的默认容量大小。当由于增加数据导致容量不足时，容量会添加上一次容量大小的一半。ArrayList(int capacity)// 创建一个包含 collection 的ArrayListArrayList(Collection&lt;? extends E&gt; collection) ArrayList的API12345678910111213141516171819202122232425262728293031323334// Collection 中定义的APIboolean add(E object)boolean addAll(Collection&lt;? extends E&gt; collection)void clear()boolean contains(Object object)boolean containsAll(Collection&lt;?&gt; collection)boolean equals(Object object)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object object)boolean removeAll(Collection&lt;?&gt; collection)boolean retainAll(Collection&lt;?&gt; collection)int size()&lt;T&gt; T[] toArray(T[] array)Object[] toArray()// AbstractCollection中定义的APIvoid add(int location, E object)boolean addAll(int location, Collection&lt;? extends E&gt; collection)E get(int location)int indexOf(Object object)int lastIndexOf(Object object)ListIterator&lt;E&gt; listIterator(int location)ListIterator&lt;E&gt; listIterator()E remove(int location)E set(int location, E object)List&lt;E&gt; subList(int start, int end)// ArrayList新增的APIObject clone()void ensureCapacity(int minimumCapacity)void trimToSize()void removeRange(int fromIndex, int toIndex) ArrayList数据结构ArrayList的继承关系 1234567java.lang.Object |___ java.util.AbstractCollection&lt;E&gt; |___ java.util.AbstractList&lt;E&gt; |___ java.util.ArrayList&lt;E&gt;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;&#125; ArrayList 与 Collection 关系如下图： ArrayList 包含了两个重要的对象：elementData 和 size。 elementData 是” Object[] 类型的数组”，它保存了添加到ArrayList中的元素。实际上，elementData 是个动态数组，我们能通过构造函数 ArrayList(int initialCapacity) 来执行它的初始容量为 initialCapacity；如果通过不含参数的构造函数 ArrayList() 来创建 ArrayList，则 elementData 的容量默认是10。elementData 数组的大小会根据 ArrayList 容量的增长而动态的增长，具体的增长方式，请参考源码分析中的 ensureCapacity() 函数。 size 则是动态数组的实际大小。 ArrayList源码解析(基于JDK1.6.0_45)为了更了解 ArrayList 的原理，下面对 ArrayList 源码代码作出分析。ArrayList 是通过数组实现的，源码比较容易理解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353package java.util;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; // 序列版本号 private static final long serialVersionUID = 8683452581122892189L; // 保存ArrayList中数据的数组 private transient Object[] elementData; // ArrayList中实际数据的数量 private int size; // ArrayList带容量大小的构造函数。 public ArrayList(int initialCapacity) &#123; super(); if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); // 新建一个数组 this.elementData = new Object[initialCapacity]; &#125; // ArrayList构造函数。默认容量是10。 public ArrayList() &#123; this(10); &#125; // 创建一个包含collection的ArrayList public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); size = elementData.length; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; // 将当前容量值设为 =实际元素个数 public void trimToSize() &#123; modCount++; int oldCapacity = elementData.length; if (size &lt; oldCapacity) &#123; elementData = Arrays.copyOf(elementData, size); &#125; &#125; // 确定 ArrarList 的容量。 // 若ArrayList的容量不足以容纳当前的全部元素，设置 新的容量=“(原始容量x3)/2 + 1” public void ensureCapacity(int minCapacity) &#123; // 将“修改统计数”+1 modCount++; int oldCapacity = elementData.length; // 若当前容量不足以容纳当前的元素个数，设置 新的容量=“(原始容量x3)/2 + 1” if (minCapacity &gt; oldCapacity) &#123; Object oldData[] = elementData; int newCapacity = (oldCapacity * 3)/2 + 1; if (newCapacity &lt; minCapacity) newCapacity = minCapacity; elementData = Arrays.copyOf(elementData, newCapacity); &#125; &#125; // 添加元素e public boolean add(E e) &#123; // 确定ArrayList的容量大小 ensureCapacity(size + 1); // Increments modCount!! // 添加e到ArrayList中 elementData[size++] = e; return true; &#125; // 返回ArrayList的实际大小 public int size() &#123; return size; &#125; // 返回ArrayList是否包含Object(o) public boolean contains(Object o) &#123; return indexOf(o) &gt;= 0; &#125; // 返回ArrayList是否为空 public boolean isEmpty() &#123; return size == 0; &#125; // 正向查找，返回元素的索引值 public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 反向查找(从数组末尾向开始查找)，返回元素(o)的索引值 public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; // 返回ArrayList的Object数组 public Object[] toArray() &#123; return Arrays.copyOf(elementData, size); &#125; // 返回ArrayList的模板数组。所谓模板数组，即可以将T设为任意的数据类型 public &lt;T&gt; T[] toArray(T[] a) &#123; // 若数组a的大小 &lt; ArrayList的元素个数； // 则新建一个T[]数组，数组大小是“ArrayList的元素个数”，并将“ArrayList”全部拷贝到新数组中 if (a.length &lt; size) return (T[]) Arrays.copyOf(elementData, size, a.getClass()); // 若数组a的大小 &gt;= ArrayList的元素个数； // 则将ArrayList的全部元素都拷贝到数组a中。 System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a; &#125; // 获取index位置的元素值 public E get(int index) &#123; RangeCheck(index); return (E) elementData[index]; &#125; // 设置index位置的值为element public E set(int index, E element) &#123; RangeCheck(index); E oldValue = (E) elementData[index]; elementData[index] = element; return oldValue; &#125; // 将e添加到ArrayList中 public boolean add(E e) &#123; ensureCapacity(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; // 将e添加到ArrayList的指定位置 public void add(int index, E element) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); ensureCapacity(size+1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; // 删除ArrayList指定位置的元素 public E remove(int index) &#123; RangeCheck(index); modCount++; E oldValue = (E) elementData[index]; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // Let gc do its work return oldValue; &#125; // 删除ArrayList的指定元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 快速删除第index个元素 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; // 从"index+1"开始，用后面的元素替换前面的元素。 if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将最后一个元素设为null elementData[--size] = null; // Let gc do its work &#125; // 删除元素 public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; // 便利ArrayList，找到“元素o”，则删除，并返回true。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125; // 清空ArrayList，将全部的元素设为null public void clear() &#123; modCount++; for (int i = 0; i &lt; size; i++) elementData[i] = null; size = 0; &#125; // 将集合c追加到ArrayList中 public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; // 从index位置开始，将集合c添加到ArrayList public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException( "Index: " + index + ", Size: " + size); Object[] a = c.toArray(); int numNew = a.length; ensureCapacity(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; // 删除fromIndex到toIndex之间的全部元素。 protected void removeRange(int fromIndex, int toIndex) &#123; modCount++; int numMoved = size - toIndex; System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved); // Let gc do its work int newSize = size - (toIndex-fromIndex); while (size != newSize) elementData[--size] = null; &#125; private void RangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException( "Index: "+index+", Size: "+size); &#125; // 克隆函数 public Object clone() &#123; try &#123; ArrayList&lt;E&gt; v = (ArrayList&lt;E&gt;) super.clone(); // 将当前ArrayList的全部元素拷贝到v中 v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; &#125; catch (CloneNotSupportedException e) &#123; // this shouldn't happen, since we are Cloneable throw new InternalError(); &#125; &#125; // java.io.Serializable的写入函数 // 将ArrayList的“容量，所有的元素值”都写入到输出流中 private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException&#123; // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // 写入“数组的容量” s.writeInt(elementData.length); // 写入“数组的每一个元素” for (int i=0; i&lt;size; i++) s.writeObject(elementData[i]); if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125; &#125; // java.io.Serializable的读取函数：根据写入方式读出 // 先将ArrayList的“容量”读出，然后将“所有的元素值”读出 private void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException &#123; // Read in size, and any hidden stuff s.defaultReadObject(); // 从输入流中读取ArrayList的“容量” int arrayLength = s.readInt(); Object[] a = elementData = new Object[arrayLength]; // 从输入流中将“所有的元素值”读出 for (int i=0; i&lt;size; i++) a[i] = s.readObject(); &#125;&#125; 总结： ArrayList 实际上是通过一个数组去保存数据的。当我们构造 ArrayList 时；若使用默认构造函数，则ArrayList 的默认容量大小是10。 当 ArrayList 容量不足以容纳全部元素时，ArrayList 会重新设置容量：新的容量=“(原始容量x3)/2 + 1”。 ArrayList 的克隆函数，即是将全部元素克隆到一个数组中。 ArrayList 实现 java.io.Serializable 的方式。当写入到输出流时，先写入“容量”，再依次写入“每一个元素”；当读出输入流时，先读取“容量”，再依次读取“每一个元素”。 ArrayList遍历方式ArrayList支持3种遍历方式 第一种，通过迭代器遍历。即通过Iterator去遍历。12345Integer value = null;Iterator iter = list.iterator();while (iter.hasNext()) &#123; value = (Integer)iter.next();&#125; 第二种，随机访问，通过索引值去遍历。由于ArrayList实现了RandomAccess接口，它支持通过索引值去随机访问元素。 12345Integer value = null;int size = list.size();for (int i=0; i&lt;size; i++) &#123; value = (Integer)list.get(i); &#125; 第三种，for循环遍历。如下：1234Integer value = null;for (Integer integ:list) &#123; value = integ;&#125; 下面通过一个实例，比较这3种方式的效率，实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import java.util.*;import java.util.concurrent.*;/** * @desc ArrayList遍历方式和效率的测试程序。 */public class ArrayListRandomAccessTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); for (int i=0; i&lt;100000; i++) list.add(i); //isRandomAccessSupported(list); iteratorThroughRandomAccess(list) ; iteratorThroughIterator(list) ; iteratorThroughFor2(list) ; &#125; private static void isRandomAccessSupported(List list) &#123; if (list instanceof RandomAccess) &#123; System.out.println("RandomAccess implemented!"); &#125; else &#123; System.out.println("RandomAccess not implemented!"); &#125; &#125; public static void iteratorThroughRandomAccess(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for (int i=0; i&lt;list.size(); i++) &#123; list.get(i); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughRandomAccess：" + interval+" ms"); &#125; public static void iteratorThroughIterator(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Iterator iter = list.iterator(); iter.hasNext(); ) &#123; iter.next(); &#125; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughIterator：" + interval+" ms"); &#125; public static void iteratorThroughFor2(List list) &#123; long startTime; long endTime; startTime = System.currentTimeMillis(); for(Object obj:list) ; endTime = System.currentTimeMillis(); long interval = endTime - startTime; System.out.println("iteratorThroughFor2：" + interval+" ms"); &#125;&#125; 运行结果： 123iteratorThroughRandomAccess：3 msiteratorThroughIterator：8 msiteratorThroughFor2：5 ms 由此可见，遍历ArrayList时，使用随机访问(即，通过索引序号访问)效率最高，而使用迭代器的效率最低！ toArray() 异常当我们调用 ArrayList 中的 toArray()，可能遇到过出 “java.lang.ClassCastException” 异常的情况。下面我们说说这是怎么回事。 ArrayList 提供了2个 toArray() 函数： 12Object[] toArray()&lt;T&gt; T[] toArray(T[] contents) 调用 toArray() 函数会抛出“java.lang.ClassCastException”异常，但是调用 toArray(T[] contents) 能正常返回 T[]。 toArray() 会抛出异常是因为 toArray() 返回的是 Object[] 数组，将 Object[] 转换为其它类型(如将Object[]转换为的Integer[])则会抛出“java.lang.ClassCastException”异常，因为Java不支持向下转型。具体的可以参考前面ArrayList.java的源码介绍部分的toArray()。 解决该问题的办法是调用 T[] toArray(T[] contents) ， 而不是 Object[] toArray()。 调用 toArray(T[] contents) 返回T[]的可以通过以下几种方式实现。 12345678910111213141516171819 // toArray(T[] contents)调用方式一public static Integer[] vectorToArray1(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = new Integer[v.size()]; v.toArray(newText); return newText;&#125;// toArray(T[] contents)调用方式二。最常用！public static Integer[] vectorToArray2(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = (Integer[])v.toArray(new Integer[0]); return newText;&#125;// toArray(T[] contents)调用方式三public static Integer[] vectorToArray3(ArrayList&lt;Integer&gt; v) &#123; Integer[] newText = new Integer[v.size()]; Integer[] newStrings = (Integer[])v.toArray(newText); return newStrings;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>ArrayList</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之 Collection]]></title>
    <url>%2F2015%2F04%2F08%2F8-Collection-Map%2F2-Collection%2F</url>
    <content type="text"><![CDATA[CollectionCollection 框架类的关系图： Collection 是一个接口，它主要的两个分支是：List 和 Set。List 和 Set 都是接口，它们继承于 Collection。List 是有序的队列，List 中可以有重复的元素；而 Set 是数学概念中的集合，Set 中没有重复元素！List 和 Set 都有它们各自的实现类。 为了方便，我们抽象出了 AbstractCollection 抽象类，它实现了 Collection 中的绝大部分函数；这样，在Collection 的实现类中，我们就可以通过继承 AbstractCollection 省去重复编码。AbstractList 和AbstractSet 都继承于 AbstractCollection，具体的 List 实现类继承于 AbstractList，而 Set 的实现类则继承于 AbstractSet。 另外，Collection 中有一个 iterator() 函数，它的作用是返回一个 Iterator 接口。通常，我们通过 Iterator 迭代器来遍历集合。ListIterator 是 List 接口所特有的，在 List 接口中，通过 ListIterator() 返回一个 ListIterator 对象。 1、Collection 接口简介Collection 定义如下： 1public interface Collection&lt;E&gt; extends Iterable&lt;E&gt; &#123;&#125; 它是一个接口，是高度抽象出来的集合，它包含了集合的基本操作：添加、删除、清空、遍历(读取)、是否为空、获取大小、是否保护某元素等等。 Collection 接口的所有子类（直接子类和间接子类）都必须实现2种构造函数：不带参数的构造函数和参数为 Collection 的构造函数。带参数的构造函数，可以用来转换 Collection 的类型。 12345678910111213141516171819202122// JDK 1.8 Collection 的APIboolean add(E e)boolean addAll(Collection&lt;? extends E&gt; c)void clear()boolean contains(Object o)boolean containsAll(Collection&lt;?&gt; c)boolean equals(Object o)int hashCode()boolean isEmpty()Iterator&lt;E&gt; iterator()boolean remove(Object o)boolean removeAll(Collection&lt;?&gt; c)boolean retainAll(Collection&lt;?&gt; c)int size()Object[] toArray()&lt;T&gt; T[] toArray(T[] a)// 相对 JDK 1.6 新增的 API default Stream&lt;E&gt; parallelStream()default boolean removeIf(Predicate&lt;? super E&gt; filter)default Spliterator&lt;E&gt; spliterator()default Stream&lt;E&gt; stream() 2、List 接口简介List 的定义如下： 1public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; List 是一个继承于 Collection 的接口，即 List 是集合中的一种。List 是有序的队列，List 中的每一个元素都有一个索引；第一个元素的索引值是0，往后的元素的索引值依次+1。和 Set 不同，List 中允许有重复的元素。 List 继承于 Collection 接口，它包含了 Collection 中的全部函数接口；由于 List 是有序队列，它也额外的有自己的API接口。主要有“添加、删除、获取、修改指定位置的元素”、“获取 List 中的子队列”等。 12345678910111213141516171819202122232425262728// Collection的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator&lt;E&gt; iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract &lt;T&gt; T[] toArray(T[] array)abstract Object[] toArray()// 相比与Collection，List新增的API：abstract void add(int location, E object)abstract boolean addAll(int location, Collection&lt;? extends E&gt; collection)abstract E get(int location)abstract int indexOf(Object object)abstract int lastIndexOf(Object object)abstract ListIterator&lt;E&gt; listIterator(int location)abstract ListIterator&lt;E&gt; listIterator()abstract E remove(int location)abstract E set(int location, E object)abstract List&lt;E&gt; subList(int start, int end) 3、Set 接口简介Set的定义如下： 1public interface Set&lt;E&gt; extends Collection&lt;E&gt; &#123;&#125; Set 是一个继承于 Collection 的接口，即 Set 也是集合中的一种。Set 是没有重复元素的集合。 关于 API 方面。Set 的 API 和 Collection 完全一样。 12345678910111213141516// Set 的APIabstract boolean add(E object)abstract boolean addAll(Collection&lt;? extends E&gt; collection)abstract void clear()abstract boolean contains(Object object)abstract boolean containsAll(Collection&lt;?&gt; collection)abstract boolean equals(Object object)abstract int hashCode()abstract boolean isEmpty()abstract Iterator&lt;E&gt; iterator()abstract boolean remove(Object object)abstract boolean removeAll(Collection&lt;?&gt; collection)abstract boolean retainAll(Collection&lt;?&gt; collection)abstract int size()abstract &lt;T&gt; T[] toArray(T[] array)abstract Object[] toArray() 4、AbstractCollection 抽象类AbstractCollection 的定义如下： 1public abstract class AbstractCollection&lt;E&gt; implements Collection&lt;E&gt; &#123;&#125; AbstractCollection 是一个抽象类，它实现了 Collection 中除iterator()和size()之外的函数。AbstractCollection 的主要作用：它实现了 Collection 接口中的大部分函数。从而方便其它类实现 Collection，比如 ArrayList、LinkedList 等，它们这些类想要实现 Collection 接口，通过继承AbstractCollection 就已经实现了大部分的接口了。 5、AbstractList 抽象类AbstractList 的定义如下： 1public abstract class AbstractList&lt;E&gt; extends AbstractCollection&lt;E&gt; implements List&lt;E&gt; &#123;&#125; AbstractList 是一个继承于 AbstractCollection，并且实现 List 接口的抽象类。它实现了 List 中除 size()、get(int location) 之外的函数。AbstractList 的主要作用：它实现了 List 接口中的大部分函数。从而方便其它类继承 List。另外，和 AbstractCollection 相比，AbstractList 抽象类中，实现了 iterator() 接口。 6、AbstractSet 抽象类AbstractSet 的定义如下： 1public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; &#123;&#125; AbstractSet 是一个继承于 AbstractCollection，并且实现 Set 接口的抽象类。由于 Set 接口和 Collection 接口中的 API 完全一样，Set也就没有自己单独的API。和 AbstractCollection 一样，它实现了 List 中除iterator() 和 size() 之外的函数。 AbstractSet 的主要作用：它实现了 Set 接口中的大部分函数。从而方便其它类实现 Set 接口。 7、Iterator 接口Iterator 的定义如下： 1public interface Iterator&lt;E&gt; &#123;&#125; Iterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合中的元素。Iterator 提供的 API 接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。 注意：Iterator 遍历 Collection 时，是 fail-fast 机制的。即，当某一个线程A通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程 A 访问集合时，就会抛出ConcurrentModificationException 异常，产生 fail-fast 事件。关于 fail-fast 的详细内容，我们会在后面专门进行说明。 1234// Iterator的APIabstract boolean hasNext()abstract E next()abstract void remove() 8、ListIterator 接口ListIterator 定义如下： 1public interface ListIterator&lt;E&gt; extends Iterator&lt;E&gt; &#123;&#125; ListIterator 是一个继承于 Iterator 的接口，它是队列迭代器。专门用于遍历 List，能提供向前/向后遍历。相比于 Iterator，它新增了添加、是否存在上一个元素、获取上一个元素等等 API 接口。 123456789101112// ListIterator 的API// 继承于 Iterator 的接口abstract boolean hasNext()abstract E next()abstract void remove()// 新增 API 接口abstract void add(E object)abstract boolean hasPrevious()abstract int nextIndex()abstract E previous()abstract int previousIndex()abstract void set(E object)]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
        <tag>Collection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合框架之集合框架概览]]></title>
    <url>%2F2015%2F04%2F08%2F8-Collection-Map%2F1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[集合与数组都是对象的存储： 数组（基本数据类型 &amp; 引用数据类型） 集合（引用数据类型） 引用数据类型数组的元素是对象引用，初值为空，必须实例化；而基本类型数组元素都有默认初值。 数组存储数据的弊端： 一旦创建，其长度不可变。 真实的数组存放的对象的个数是不可知。 为什么集合不能存储基本数据类型？集合中存放的可都是对象的引用，实际内容都在堆上面或者方法区里面，而基本数据类型都是在栈上分配空间的，随时就被收回。但通过自动包装类就可以把基本类型转为对象类型，存放引用就解决了这个问题。 总体框架 Collection是一个高度抽象出来的接口，包含了集合的基本操作和属性。Collection 包含了 List 和 Set 两大分支。 List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。 List的实现类有 LinkedList, ArrayList, Vector, Stack。 Set 是一个不允许有重复元素的集合。 Set 的实现类有 HastSet 和 TreeSet 。HashSet 依赖于 HashMap，它实际上是通过 HashMap 实现的；TreeSet 依赖于 TreeMap，它实际上是通过 TreeMap 实现的。 Map是一个映射接口，即 key-value 键值对。Map 中的每一个元素包含 “一个key” 和 “key对应的value”。 AbstractMap 是个抽象类，它实现了 Map 接口中的大部分 API。而 HashMap，TreeMap，WeakHashMap都是继承于 AbstractMap。 Hashtable 虽然继承于 Dictionary ，但它实现了 Map 接口。 接下来，再看 Iterator。它是遍历集合的工具，即我们通常通过 Iterator 迭代器来遍历集合。我们说Collection 依赖于 Iterator，是因为 Collection 的实现类都要实现 iterator() 函数，返回一个 Iterator 对象。 ListIterator 是专门为遍历 List 而存在的。 再看 Enumeration，它是JDK 1.0引入的抽象类。作用和 Iterator 一样，也是遍历集合；但是 Enumeration 的功能要比 Iterator 少。在上面的框图中，Enumeration只能在 Hashtable, Vector, Stack 中使用。 Arrays 和 Collections。它们是操作数组、集合的两个工具类。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>集合框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 网络编程]]></title>
    <url>%2F2015%2F03%2F15%2F7-Http-Socket%2F3-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[经典例子说明有一个夜店（ServerSocket）,你是嫖客(socket)，晚上6点夜店进入营业状态，夜店正在阻塞等客户，你一进来，夜店马上安排一个小姐（server.accept()的client）与你激情对接，你向小姐输出就是你调用（outputStream）, 你吸入小姐精华是你调用（inputStream）,你吸入小姐精华的时候得有小姐在向你输出（outputStream）. Java最初是作为网络编程语言出现的，其对网络提供了高度的支持，使得客户端和服务器的沟通变成了现实，而在网络编程中，使用最多的就是Socket。像大家熟悉的QQ、MSN都使用了Socket相关的技术。下面就让我们一起揭开Socket的神秘面纱。 一、网络基础知识（参考计算机网络）1、两台计算机间进行通讯需要以下三个条件：IP地址、协议、端口号 2、TCP/IP协议：是目前世界上应用最为广泛的协议，是以TCP和IP为基础的不同层次上多个协议的集合，也成TCP/IP协议族、或TCP/IP协议栈TCP：Transmission Control Protocol 传输控制协议IP：Internet Protocol 互联网协议 3、TCP/IP 五层模型应用层：HTTP、FTP、SMTP、Telnet等传输层：TCP/IP 、UDP网络层 : IP 、 ICMP数据链路层：Mac 地址物理层：网线、双绞线、网卡等 4、IP地址为实现网络中不同计算机之间的通信，每台计算机都必须有一个唯一的标识—IP地址。 32位二进制 5、端口区分一台主机的多个不同应用程序，端口号范围为0-65535，其中0-1023位为系统保留。如：HTTP：80 FTP：21 Telnet：23IP地址+端口号组成了所谓的Socket，Socket是网络上运行的程序之间双向通信链路的终结点，是TCP和UDP的基础 6、Socket套接字：网络上具有唯一标识的IP地址和端口组合在一起才能构成唯一能识别的标识符套接字。Socket原理机制：通信的两端都有Socket网络通信其实就是Socket间的通信数据在两个Socket间通过IO传输 7、Java中的网络支持针对网络通信的不同层次，Java提供了不同的API，其提供的网络功能有四大类：InetAddress: 用于标识网络上的硬件资源，主要是IP地址URL： 统一资源定位符，通过URL可以直接读取或写入网络上的数据Sockets： 使用TCP协议实现的网络通信Socket相关的类Datagram : 使用UDP协议，将数据保存在用户数据报中，通过网络进行通信。 二、InetAddressInetAddress类用于标识网络上的硬件资源，标识互联网协议(IP)地址。 该类没有构造方法 123456789//获取本机的InetAddress实例InetAddress address =InetAddress.getLocalHost();address.getHostName(); //获取计算机名address.getHostAddress(); //获取IP地址byte[] bytes = address.getAddress();//获取字节数组形式的IP地址,以点分隔的四部分//获取其他主机的InetAddress实例InetAddress address2 = InetAddress.getByName("其他主机名");InetAddress address3 = InetAddress.getByName("IP地址"); 三、URL类12345678910//创建一个URL的实例URL baidu = new URL("http://www.baidu.com");URL url = new URL(baidu,"/index.html?username=tom#test");// ？表示参数，#表示锚点url.getProtocol(); //获取协议url.getHost(); //获取主机url.getPort(); //如果没有指定端口号，根据协议不同使用默认端口。此时getPort()方法的返回值为 -1url.getPath(); //获取文件路径url.getFile(); //文件名，包括文件路径+参数url.getRef(); //相对路径，就是锚点，即#号后面的内容url.getQuery(); //查询字符串，即参数 通过URL对象的openStream()方法可以得到指定资源的输入流，通过流能够读取或访问网页上的资源 1234567891011121314//使用URL读取网页内容//创建一个URL实例URL url = new URL("http://www.baidu.com");InputStream is = url.openStream(); //通过openStream方法获取资源的字节输入流InputStreamReader isr = newInputStreamReader(is,"UTF-8");//将字节输入流转换为字符输入流,如果不指定编码，中文可能会出现乱码BufferedReader br = newBufferedReader(isr); //为字符输入流添加缓冲，提高读取效率String data = br.readLine(); //读取数据while(data!=null)&#123; System.out.println(data);//输出数据 data = br.readerLine();&#125;br.close();isr.colose();is.close(); 四、TCP编程1、TCP协议是面向连接的、可靠的、有序的、以字节流的方式发送数据，通过三次握手方式建立连接，形成传输数据的通道，在连接中进行大量数据的传输，效率会稍低。2、Java中基于TCP协议实现网络通信的类客户端的Socket类服务器端的ServerSocket类 3、Socket通信的步骤① 创建ServerSocket和Socket② 打开连接到Socket的输入/输出流③ 按照协议对Socket进行读/写操作④ 关闭输入输出流、关闭Socket 4、服务器端：① 创建ServerSocket对象，绑定监听端口② 通过accept()方法监听客户端请求③ 连接建立后，通过输入流读取客户端发送的请求信息④ 通过输出流向客户端发送乡音信息⑤ 关闭相关资源 123456789101112131415161718192021222324252627282930313233/*** 基于TCP协议的Socket通信，实现用户登录，服务端*///1、创建一个服务器端Socket，即ServerSocket，指定绑定的端口，并监听此端口ServerSocket serverSocket = new ServerSocket(10086); //1024-65535的某个端口//2、调用accept()方法开始监听，等待客户端的连接Socket socket = serverSocket.accept();//3、获取输入流，并读取客户端信息InputStream is = socket.getInputStream();InputStreamReader isr = new InputStreamReader(is);BufferedReader br = new BufferedReader(isr);String info = null;while((info = br.readLine()) != null)&#123; System.out.println("我是服务器，客户端说："+info);&#125;socket.shutdownInput();//关闭输入流//4、获取输出流，响应客户端的请求OutputStream os = socket.getOutputStream();PrintWriter pw = new PrintWriter(os);pw.write("欢迎您！");pw.flush();//5、关闭资源pw.close();os.close();br.close();isr.close();is.close();socket.close();serverSocket.close(); 5、客户端：① 创建Socket对象，指明需要连接的服务器的地址和端口号② 连接建立后，通过输出流想服务器端发送请求信息③ 通过输入流获取服务器响应的信息④ 关闭响应资源 1234567891011121314151617181920212223242526//客户端//1、创建客户端Socket，指定服务器地址和端口Socket socket =new Socket("localhost",10086);//2、获取输出流，向服务器端发送信息OutputStream os = socket.getOutputStream(); //字节输出流PrintWriter pw = new PrintWriter(os); //将输出流包装成打印流pw.write("用户名：admin；密码：123");pw.flush();socket.shutdownOutput();//3、获取输入流，并读取服务器端的响应信息InputStream is = socket.getInputStream();BufferedReader br = new BufferedReader(new InputStreamReader(is));String info = null;while((info = br.readLine())!null) ????&#123; System.out.println("我是客户端，服务器说："+info);&#125;//4、关闭资源br.close();is.close();pw.close();os.close();socket.close(); 6、应用多线程实现服务器与多客户端之间的通信① 服务器端创建ServerSocket，循环调用accept()等待客户端连接② 客户端创建一个socket并请求和服务器端连接③ 服务器端接受苦读段请求，创建socket与该客户建立专线连接④ 建立连接的两个socket在一个单独的线程上对话⑤ 服务器端继续等待新的连接 123456789101112131415161718192021222324//服务器线程处理//和本线程相关的socketSocket socket = null;//public serverThread(Socket socket)&#123; this.socket = socket;&#125;publicvoid run()&#123;//服务器处理代码&#125;//============================================//服务器代码ServerSocket serverSocket = new ServerSocket(10086);Socket socket = null;int count = 0;//记录客户端的数量while(true)&#123; socket = serverScoket.accept(); ServerThread serverThread = new ServerThread(socket); serverThread.start(); count++; System.out.println("客户端连接的数量："+count);&#125; 五、UDP编程UDP协议（用户数据报协议）是无连接的、不可靠的、无序的,速度快进行数据传输时，首先将要传输的数据定义成数据报（Datagram），大小限制在64k，在数据报中指明数据索要达到的Socket（主机地址和端口号），然后再将数据报发送出去 DatagramPacket类 : 表示数据报包DatagramSocket类：进行端到端通信的类 1、服务器端实现步骤① 创建DatagramSocket，指定端口号② 创建DatagramPacket③ 接受客户端发送的数据信息④ 读取数据 123456789101112131415161718192021222324//服务器端，实现基于UDP的用户登录//1、创建服务器端DatagramSocket，指定端口DatagramSocket socket = new datagramSocket(10010);//2、创建数据报，用于接受客户端发送的数据byte[] data =newbyte[1024];//DatagramPacket packet = new DatagramPacket(data,data.length);//3、接受客户端发送的数据socket.receive(packet);//此方法在接受数据报之前会一致阻塞//4、读取数据String info = new String(data,o,data.length);System.out.println("我是服务器，客户端告诉我"+info);//=========================================================//向客户端响应数据//1、定义客户端的地址、端口号、数据InetAddress address = packet.getAddress();int port = packet.getPort();byte[] data2 = "欢迎您！".geyBytes();//2、创建数据报，包含响应的数据信息DatagramPacket packet2 = new DatagramPacket(data2,data2.length,address,port);//3、响应客户端socket.send(packet2);//4、关闭资源socket.close(); 2、客户端实现步骤 定义发送信息 创建DatagramPacket，包含将要发送的信息 创建DatagramSocket 发送数据 123456789101112131415161718192021222324//客户端//1、定义服务器的地址、端口号、数据InetAddress address =InetAddress.getByName("localhost");int port =10010;byte[] data ="用户名：admin;密码：123".getBytes();//2、创建数据报，包含发送的数据信息DatagramPacket packet = newDatagramPacket(data,data,length,address,port);//3、创建DatagramSocket对象DatagramSocket socket =newDatagramSocket();//4、向服务器发送数据socket.send(packet);//接受服务器端响应数据//======================================//1、创建数据报，用于接受服务器端响应数据byte[] data2 = new byte[1024];DatagramPacket packet2 = new DatagramPacket(data2,data2.length);//2、接受服务器响应的数据socket.receive(packet2);String raply = new String(data2,0,packet2.getLenth());System.out.println("我是客户端，服务器说："+reply);//4、关闭资源socket.close(); 六、注意问题：1、多线程的优先级问题：根据实际的经验，适当的降低优先级，否侧可能会有程序运行效率低的情况?????? 2、是否关闭输出流和输入流：对于同一个socket，如果关闭了输出流，则与该输出流关联的socket也会被关闭，所以一般不用关闭流，直接关闭socket即可 3、使用TCP通信传输对象，IO中序列化部分4、socket编程传递文件，IO流部分]]></content>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议]]></title>
    <url>%2F2015%2F03%2F14%2F7-Http-Socket%2F1-HTTP%2F</url>
    <content type="text"><![CDATA[HTTP本篇总结关于http的相关知识，主要内容参考如下导图： 常见关键词概念平时会经常接触到URL，他就是我们访问web的一个字符串地址，那么URI是什么呢？他们是什么关系呢？ 先看看官方的解释： URL：uniform resource location 统一资源定位符 URI：uniform resource identifier 统一资源标识符 这也就是说，URI是一种资源的标识；而URL也是一种URI，也是一种资源的标识，但它也指明了如何定位Locate到这个资源。 URI是一种抽象的资源标识，既可以是绝对的，也可以是相对的。但是URL是一种URI，它指明了定位的信息，必须是绝对的。 而我们平时所说的相对地址，仅仅是相对于另一个绝对地址而言。 RFC：reqeust for comments 征求修正意见书 RFC素有网络知识圣经之称，规定了网络中协议的基本内容。因此许多的不同系统的应用程序才可以互相访问。 报文格式首先报文的格式如下： 其中空行用于区分报文首部和报文主体内容，是由一个回车符和一个换行符组成。 无论是请求报文还是响应报文都需要有报文首部，当然报文主体有的请求报文是没有的。 可以看到，差别就在于请求行中指定的是HTTP版本和请求的方式（GET\POST等）。状态行中指定了HTTP版本和返回的状态码以及短语。 请求报文格式： 其中请求首部还包括其他的内容，不一一列举了。 响应报文格式： 下面我们看一下在不同的浏览器中http报文的内容： 上图是chrome中http的内容，其中request headers描述了请求报文头部的内容，response headers描述了响应报文头部的内容。 常使用的属性： URL, 即http访问的地址 request method, 报文的请求方式 status code, 状态码以及状态短语 Accept Encoding, 内容编码 Connection, 连接方式 Cookie, 添加的cookie内容 Host, 目标主机 User-Agent, 客户端浏览器的相关信息 Set-Cookie, 指定想要在Cookie中保存的内容 常用的属性内容就是上面这些。 在IE中捕获到的显示方式不同，但是内容都是相同的： http请求方式如何发送http有很多种方式，但是最常用的就是POST和GET。 其他的有些出于安全性的考虑一般都不建议使用。 POST与GET的区别 使用目标不同：POST与GET都用于获取信息，但是GET方式仅仅是查询，并不对服务器上的内容产生任何作用结果；每次GET的内容都是相同的。POST则常用于发送一定的内容进行某些修改操作。 大小不同：由于不同的浏览器对URL的长度大小有一定的字符限制，因此由于GET方式放在URL的首部中，自然也跟着首先，但是具体的大小要依浏览器而定。POST方式则是把内容放在报文内容中，因此只要报文的内容没有限制，它的大小就没有限制。 安全性不同：上面也说了GET是直接添加到URL后面的，直接就可以在URL中看到内容。而POST是放在报文内部的，用户无法直接看到。 总的来说，GET用于获取某个内容，POST用于提交某种数据请求。 按照使用场景来说，一般用户注册的内容属于私密的，这应该使用POST方式；而针对某一内容的查询，为了快速的响应，可以使用GET方式。 Cookies由于http是一种无状态的协议，因此无论是客户端还是服务器都不记录http的相关信息。 这样设计一方面减轻了服务器端的负载，另一方面减小了http请求的开销。 但是针对某些特殊的场景，需要时刻记录用户的相关信息，这该如何处理呢? Cookie恰好可以解决这个问题,Cookie的运行机制如下： Cookie是一种由服务器端确定，并保存在客户端浏览器中的内容。这样，就不需要每次都添加用户的相关信息，请求会自动添加cookie中对应的内容。 正常在发送http时，都需要建立TCP的连接，再发送报文。 如果每次想要发送http报文都需要经过这个过程，那么时间大部分都会消耗在建立和断开连接的过程中。 因此http中使用了connection属性，用于指定连接的方式。 当设置成keep-alive，如上面所示的www.baidu.com的http头部信息所示，就会建立一条持久化的连接。不需要每次都建立连接，再中断。 如果一个http请求，请求了大量的图片等大文件，那么其他的http请求怎么办呢？ 不用怕，http可以一次发送多个http请求，然后等待响应连接。不需要排队等候，这样就加快了http的响应时间。 由于某些报文的内容过大，因此在传输时，为了减少传输的时间，会采取一些压缩的措施。 例如上面的报文信息中，Accept-Encoding就定义了内容编码的格式：gzip 有下面几种方式： gzip：GNU压缩格式 compress：UNIX系统的标准压缩格式 deflate：是一种同时使用了LZ77和哈弗曼编码的无损压缩格式 identity：不进行压缩 多部分对象集合有的时候传输的内容，不仅仅是一些字符串，还有可能是一些图片，字符，音乐二进制等混杂的内容。这就需要使用多部分对象集合，multipart，例如在使用java编写web上传文件的代码时，需要在form中指定form的编码格式。 设置form的enctype属性的值为multipart/form-data。这是因为默认的情况下form使用的编码格式是：applicatin/x-www-form-urlencoded，这种编码格式会把所有的内容进行编码，不适合上传文件这种情况。 这两种编码格式的区别主要是： multipart/form-data 会以控件为基准，编码form中的内容。 application/x-www-form-urlencoded 会把form中的内容编码成键值对的形式。 状态码 报文首部 HTTPSHTTP+加密+认证+完整性保护 = HTTPS 为什么会出现https呢，多个s又有什么用呢！ HTTP的缺点： 传输的时候使用明文，这显然会被不法者截取干一些见不得人的勾当。 没有认证机制，这样我们就可以伪造一些http访问，这显然会造成一些困扰。比如Jmeter就是典型的例子，伪造一大堆的http URL然后压力测试，这也就是DOS攻击的一种。 无法验证报文的完整性，比如一个http的报文已经被不法者截取并且篡改，服务器端也无法验证。 而HTTPS相当于套上SSL的HTTP。 但是HTTPS也有它自身的缺点。 HTTPS的缺点： 通信的速度变慢，由于需要加密，一个握手就多了好几个往返 对用户端的机器负载的增加。 因此，如果不是像金融支付这种需要高强度的安全性的场景，还是http比较好。 HTTP中认证的概念有一些网址或者服务需要用户的身份信息，因此需要随时知道这些消息，但是肯定不能每次都让用户输入用户密码，因此关于认证就有下面几种方式： BASIC认证BASIC认证是最简单的认证，大致过程如下： 客户端访问某URL。 服务器端返回401状态码，提示用户输入用户名密码。 用户输入用户名密码，通过BASE64编码传输。 服务器通过认证，返回状态码200 通过上面的过程，就可以发现BASIC的问题： 仅仅通过BASE64编码，其实还是属于明文传输，安全性不高 有的浏览器不支持注销 DIGEST认证鉴于上面BASIC的问题，DIGEST做了补充，它的过程与上面类似： 客户端访问 服务器端返回质询码 客户端发送响应码 这里通过随机的生成质询码来作为计算的一种方式，客户端依据这个质询码生成响应码，进行验证。 这样就弥补了明文传输用户密码的风险。 SSL客户端验证这个比较普遍了！ 像支付宝啊，邮政网银啊之类的，在登录时，都需要下载一个数字认证的东西，这个东西就属于一种SSL客户端的验证。 很显然它的缺点就是需要客户去手动的安装，这个对于一般的用户来说，代价有点高。 cookie \ session最后一种是应用最普遍的，通过表单记录用户的身份信息，可以使用cookie或者session的方式保存用户信息。]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射之动态代理]]></title>
    <url>%2F2015%2F03%2F07%2F6-Reflection%2F2-%E6%9C%BA%E5%88%B6%E4%B9%8B%E9%9D%99%E5%8A%A8%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[代理代理模式：代理模式的作用=为其他对象提供一种代理以控制对这个对象的访问。 代理模式的角色： 抽象角色：声明真实对象和代理对象的共同接口 代理角色：代理角色内部包含有真实对象的引用，从而可以操作真实对象。 真实角色：代理角色所代表的真实对象，是我们最终要引用的对象。 动态代理：java.lang.reflect.ProxyProxy 提供用于创建动态代理类和实例的静态方法，它还是由这些方法创建的所有动态代理类的超类 InvocationHandler是代理实例的调用处理程序 实现的接口，每个代理实例都具有一个关联的调用处理程序。对代理实例调用方法时，将对方法调用进行编码并将其指派到它的调用处理程序的 invoke 方法。 动态Proxy是这样的一种类:它是在运行生成的类，在生成时你必须提供一组Interface给它，然后该class就宣称它实现了这些interface。你可以把该class的实例当作这些interface中的任何一个来用。当然，这个Dynamic Proxy其实就是一个Proxy，它不会替你作实质性的工作，在生成它的实例时你必须提供一个handler，由它接管实际的工作。 在使用动态代理类时，我们必须实现InvocationHandler接口步骤： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//1、定义抽象角色 [共同的接口] :动态代理的使用，体会反射是动态语言的关键interface Subject &#123; void action();&#125;//2、定义真实角色 :被代理类 class RealSubject implements Subject &#123; public void action() &#123; System.out.println( "我是被代理类，记得要执行我！" ); &#125;&#125;//3、定义代理角色 :定义代理类class MyInvocationHandler implements InvocationHandler &#123; Object obj;// 实现了接口的被代理类的对象的声明 // 作用：①给被代理的对象实例化②返回一个代理类的对象 public Object blind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; //当通过代理类的对象发起对被重写的方法的调用时，都会转换为对如下的invoke方法的调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //method方法的返回值时returnVal Object returnVal = method.invoke(obj, args); return returnVal; &#125;&#125;//测试类public class TestProxy &#123; public static void main(String[] args) &#123; //1.被代理类的对象 RealSubject real = new RealSubject(); //2.创建一个实现了InvacationHandler接口的代理类的对象 MyInvocationHandler handler = new MyInvocationHandler(); //3.调用blind()方法，动态的返回一个同样实现了real所在类实现的接口Subject的代理类的对象。 Object obj = handler.blind(real); Subject sub = (Subject)obj; //此时sub就是代理类的对象 sub.action(); //转到对InvacationHandler接口的实现类的invoke()方法的调用 &#125;&#125; 静态代理12345678910111213141516171819202122232425262728293031323334353637package utils;//静态代理模式//接口interface ClothFactory&#123; void productCloth();&#125;//被代理类class NikeClothFactory implements ClothFactory&#123; @Override public void productCloth() &#123; System.out.println( "Nike工厂生产一批衣服" ); &#125; &#125;//代理类class ProxyFactory implements ClothFactory&#123; ClothFactory cf; //创建代理类的对象时，实际传入一个被代理类的对象 public ProxyFactory(ClothFactory cf)&#123; this. cf = cf; &#125; @Override public void productCloth() &#123; System.out.println( "代理类开始执行，收代理费$1000" ); cf.productCloth(); &#125;&#125;public class TestClothProduct &#123; public static void main(String[] args) &#123; NikeClothFactory nike = new NikeClothFactory(); //创建被代理类的对象 ProxyFactory proxy = new ProxyFactory(nike); //创建代理类的对象 proxy.productCloth(); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射机制]]></title>
    <url>%2F2015%2F03%2F06%2F6-Reflection%2F1-%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[1、如何创建Class的实例(重点) 过程： 源文件经过编译javac.exe以后，得到一个或多个.class文件。.class文件经过运行java.exe这步，就需要进行类的加载（通过JVM的类的加载器），记载到内存中的缓存。每一个放入缓存中的.class文件就是一个Class的实例！ Class的一个对象，对应着一个运行时类。相当于一个运行时类本身充当了Class的一个实例。 java.lang.Class是反射的源头。 接下来涉及到反射的类都在java.lang.reflect子包下。 如：Field 、 Method 、Constructor 、 Type 、Package.. 当通过Class的实例调用getMethods() ---&gt;Method, getConstructors() ----&gt;Constructor 实例化Class的方法(五种):(1) 调用运行时类的.class属性 12Class clazz1 = Person.class;System.out.println(clazz1); // me.cuijing.java.Person (2)通过运行时类的对象，调用其getClass()方法 12Class clazz2 = new Person().getClass();System.out.println(clazz3); // me.cuijing.java.Person (3)调用Class的静态方法forName(String className)。此方法报ClassNotFoundException 12Class clazz3 = Class.forName(com.atguigu.java.Person );System.out.println(clazz4); // me.cuijing.java.Person (4)运用primitive wrapper classes的TYPE 语法这里返回的是原生类型，和Person.class返回的不同 12Class clazz4 = Person.TYPE;System.out.println(clazz4) //Person (5)利用反序列化 2、有了Class实例以后，可以做什么？应用一：可以创建对应的运行时类的对象(重点)12345678910111213141516171819 获取方法一 @Test public void test1( ) throws Exception&#123; Class clazz = Class.forName("com.atguigu.review.Animal"); Object obj = clazz.newInstance( ); Animal a = (Animal)obj; System.out.println(a); &#125;获取方法二 调用指定的构造器创建运行时类的对象 @Test public void test2( ) throws Exception&#123; Class clazz = Animal.class; Constructor cons = clazz.getDeclaredConstructor(String.class,int.class); cons.setAccessible(true); Animal a = (Animal)cons.newInstance("Tom",10); System.out.println(a); &#125; 应用二：获取对应的运行时类的完整的类的结构：属性、方法、构造器、包、父类、接口、泛型、注解、异常、内部类。。。 如：Method[] m1 = clazz.getMethods() :获取到对应的运行时类中声明的权限为public的方法（包含其父类中的声明的public） Method[] m2 = clazz.getDeclaredMethods()：获取到对应的运行时类中声明的所有的方法（①任何权限修饰符修饰的都能获取②不含父类中的） 应用三：调用对应的运行时类中指定的结构（某个指定的属性、方法、构造器）(重点)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//调用指定属性@Testpublic void test3( ) throws Exception&#123; Class clazz = Class.forName("com.atguigu.review.Animal"); Object obj = clazz.newInstance(); Animal a = (Animal)obj; //调用非public的属性 Field f1 = clazz.getDeclaredField("name"); f1.setAccessible(true); f1.set(a, "Jerry"); //调用public的属性 Field f2 = clazz.getField("age"); f2.set(a, 9); System.out.println(f2.get(a)); System.out.println(a); //调用static的属性 Field f3 = clazz.getDeclaredField("desc"); System.out.println(f3.get(null));&#125;//调用指定的方法@Testpublic void test4 ( ) throws Exception&#123; Class clazz = Class.forName("com.atguigu.review.Animal"); Object obj = clazz.newInstance(); Animal a = (Animal)obj; //调用非public的方法 Method m1 = clazz.getDeclaredMethod("getAge"); m1.setAccessible(true); // 暴力破解权限 int age = (Integer)m1.invoke(a); System.out.println(age); //调用public的方法 Method m2 = clazz.getMethod("show", String.class); Object returnVal = m2.invoke(a,"金毛"); System.out.println(returnVal); //调用static的方法 Method m3 = clazz.getDeclaredMethod("info"); m3.setAccessible(true);// m3.invoke(Animal.class); m3.invoke(null); //调用形参是数组的方法 比如是main方法 Method m4 = clazz.getMethod("main" , String[].class); m4.invoke(null , (object)String[]("aa","22")); 或者 m4.invoke(null , new object[]( String[]( "aa","22") ) );// public static void main(String[] args)&#123; @Test public void test5() throws Exception &#123; Class clazz = Class.forName("com.gplayo.reflect.Person" ); Method method = clazz.getMethod("main",String[].class); method.invoke( null, new Object[]&#123; new String[]&#123; "1", "2"&#125;&#125;); method.invoke( null, (Object) new String[]&#123; "1", "2"&#125;); &#125;&#125; 3.动态代理—反射的应用。体会反射的动态性代理设计模式的原理: 使用一个代理将对象包装起来, 然后用该代理对象取代原始对象. 任何对原始对象的调用都要通过代理. 代理对象决定是否以及何时将方法调用转到原始对象上 静态代理：要求被代理类和代理类同时实现相应的一套接口；通过代理类的对象调用重写接口的方法时，实际上执行的是被代理类的同样的方法的调用。 动态代理：在程序运行时，根据被代理类及其实现的接口，动态的创建一个代理类。当调用代理类的实现的抽象方法时，就发起对被代理类同样方法的调用。 涉及到的技术点： 提供一个实现了InvocationHandler接口实现类，并重写其invoke()方法 Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(), h);//注：obj：被代理类对象 ； h:实现了InvocationHandler接口的实现类的对象 动态代理与AOP]]></content>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
        <tag>Reflection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线程间的通信]]></title>
    <url>%2F2015%2F03%2F04%2F5-Multithreaded%2F4-%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[线程间的通信Java的进程同步是通过synchronized()来实现的，Java的synchronized()方法类似于操作系统概念中的互斥内存块，在Java中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现Java中简单的同步、互斥操作。 但如果需要在线程间相互唤醒的话就需要借助Obj.wait(), Obj.nofity()了。 Obj.wait()，Obj.notify() 必须要与 synchronized(Obj) 一起使用，也就是wait(),与notify()是针对已经获取了Obj锁进行操作 从语法角度来说就是Obj.wait()，Obj.notify() 必须在synchronized(Obj){...} 语句块内。 从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。 相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep() 与 Object.wait() 二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制。 单单在概念上理解清楚了还不够，需要在实际的例子中进行测试才能更好的理解。对Object.wait()，Object.notify()的应用最经典的例子，应该是三线程打印ABC的问题了吧，这是一道比较经典的面试题。 题目要求：建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。这个问题用Object的wait()，notify()就可以很方便的解决。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package me.cuijing.test.thread;/** * @author CuiJing * @date 2017/5/16 */public class ThreadTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。 Object a = new Object(); Object b = new Object(); Object c = new Object(); PrintChar A = new PrintChar("A", c, a); PrintChar B = new PrintChar("B", a, b); PrintChar C = new PrintChar("C", b, c); Thread ta = new Thread(A); Thread tb = new Thread(B); Thread tc = new Thread(C); ta.start(); tb.start(); tc.start(); &#125;&#125;class PrintChar implements Runnable &#123; private String name; private Object prev; private Object self; PrintChar(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.println("****" + name + "****"); count--; try&#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; // 表示当前线程 唤醒 之前执行过 wait() 方法且 需要此对象锁 self 的线程 // 继续执行 synchronized 区域的代码后会释放 self 锁。 self.notify(); &#125; try &#123; // 表示当前线程 释放 prev 的锁并等待(休眠 sleep) prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 主要的目的就是ThreadA-&gt;ThreadB-&gt;ThreadC-&gt;ThreadA循环执行三个线程。为了控制线程执行的顺序，那么就必须要确定唤醒、等待的顺序，所以每一个线程必须同时持有两个对象锁，才能继续执行。一个对象锁是prev，就是前一个线程所持有的对象锁。还有一个就是自身对象锁。 主要的思想就是，为了控制执行的顺序，必须要先持有prev锁，也就前一个线程要释放自身对象锁，再去申请自身对象锁，两者兼备时打印，之后首先调用 self.notify() 释放自身对象锁，唤醒下一个等待线程，再调用prev.wait()释放prev对象锁，终止当前线程，等待循环结束后再次被唤醒。运行上述代码，可以发现三个线程循环打印ABC，共10次。程序运行的主要过程就是A线程最先运行，持有C,A对象锁，后释放A,C锁，唤醒B。线程B等待A锁，再申请B锁，后打印B，再释放B，A锁，唤醒C，线程C等待B锁，再申请C锁，后打印C，再释放C,B锁，唤醒A。看起来似乎没什么问题，但如果你仔细想一下，就会发现有问题，就是初始条件，三个线程按照A,B,C的顺序来启动，按照前面的思考，A唤醒B，B唤醒C，C再唤醒A。但是这种假设依赖于JVM中线程调度、执行的顺序。具体来说就是，在main主线程启动ThreadA后，需要在ThreadA执行完，在prev.wait()等待时，再切回线程启动ThreadB，ThreadB执行完，在prev.wait()等待时，再切回主线程，启动ThreadC，只有JVM按照这个线程运行顺序执行，才能保证输出的结果是正确的。而这依赖于JVM的具体实现。考虑一种情况，如下：如果主线程在启动A后，执行A，过程中又切回主线程，启动了ThreadB,ThreadC，之后，由于A线程尚未释放self.notify，也就是B需要在synchronized(prev)处等待，而这时C却调用synchronized(prev)获取了对b的对象锁。这样，在A调用完后，同时ThreadB获取了prev也就是a的对象锁，ThreadC的执行条件就已经满足了，会打印C，之后释放c,及b的对象锁，这时ThreadB具备了运行条件，会打印B，也就是循环变成了ACBACB了。这种情况，可以通过在run中主动释放CPU，来进行模拟。代码如下： 1234567891011121314151617181920212223public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.print(name); count--; try&#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; self.notify(); &#125; try &#123; prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 运行后的打印结果就变成了ACBACB了。为了避免这种与JVM调度有关的不确定性。需要让A,B,C三个线程以确定的顺序启动，最终代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package me.cuijing.test.thread;/** * @author CuiJing * @date 2017/5/16 */public class ThreadTest &#123; public static void main(String[] args) throws InterruptedException &#123; // 建立三个线程，A线程打印10次A，B线程打印10次B,C线程打印10次C，要求线程同时运行，交替打印10次ABC。 Object a = new Object(); Object b = new Object(); Object c = new Object(); PrintChar A = new PrintChar("A", c, a); PrintChar B = new PrintChar("B", a, b); PrintChar C = new PrintChar("C", b, c); Thread ta = new Thread(A); Thread tb = new Thread(B); Thread tc = new Thread(C); ta.start(); Thread.sleep(1001); tb.start(); Thread.sleep(1001); tc.start(); Thread.sleep(1001); &#125;&#125;class PrintChar implements Runnable &#123; private String name; private Object prev; private Object self; PrintChar(String name, Object prev, Object self) &#123; this.name = name; this.prev = prev; this.self = self; &#125; @Override public void run() &#123; int count = 10; while (count &gt; 0) &#123; synchronized (prev) &#123; synchronized (self) &#123; System.out.println("****" + name + "****"); count--; try&#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; // 表示当前线程 唤醒 之前执行过 wait() 方法且 需要此对象锁 self 的线程 // 继续执行 synchronized 区域的代码后会释放 self 锁。 self.notify(); &#125; try &#123; // 表示当前线程 释放 prev 的锁并等待(休眠 sleep) prev.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 这样才可以完美的解决该问题。通过这个例子也是想说明一下，很多理论、概念如Obj.wait(),Obj.notify()等，理解起来，比较简单，但是在实际的应用当中，这里却是往往出现问题的地方。需要更加深入的理解。并在解决问题的过程中不断加深对概念的掌握。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程之生产者与消费者]]></title>
    <url>%2F2015%2F03%2F04%2F5-Multithreaded%2F3-%E7%BA%BF%E7%A8%8B%E7%BB%83%E4%B9%A0-%E7%94%9F%E4%BA%A7%E4%B8%8E%E6%B6%88%E8%B4%B9%2F</url>
    <content type="text"><![CDATA[生产者与消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * 生产者/消费者问题 * 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品， * 店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下， * 如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下， * 如果店中有产品了再通知消费者来取走产品。 分析： 1.是否涉及到多线程的问题？是！生产者、消费者 2.是否涉及到共享数据？有！考虑线程的安全 3.此共享数据是谁？即为产品的数量 4.是否涉及到线程的通信呢？存在生产者与消费者的通信 */&lt;!-- more --&gt;package me.cuijing.test.thread;/** * @author CuiJing * @date 2017/5/16 */public class ThreadPCC &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Productor p = new Productor(clerk); Consumer c = new Consumer(clerk); Thread p1 = new Thread(p); Thread p2 = new Thread(p); Thread c1 = new Thread(c); p1.setName( "生产者1"); p2.setName( "生产者2"); c1.setName( "消费者1"); p1.start(); p2.start(); c1.start(); &#125;&#125;class Clerk &#123; int productCount; void buyProduct() &#123; synchronized (this) &#123; if (productCount &gt;= 20) &#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; else &#123; notifyAll(); productCount++; //一开始没有产品 所有 先++ 后打印 System.out.println(Thread.currentThread().getName() + ":生产了第" + productCount + "个产品"); &#125; &#125; &#125; void sellProduct() &#123; synchronized (this) &#123; if(productCount &lt;= 0)&#123; try &#123; wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return; &#125; else &#123; notifyAll(); System.out.println(Thread.currentThread().getName() + ":卖出了第" + productCount + "个产品"); productCount--; // 先卖出去，再-- &#125; &#125; &#125;&#125;class Productor implements Runnable &#123; private Clerk clerk; public Productor(Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("生产者生产产品！"); while(true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.buyProduct(); &#125; &#125;&#125;class Consumer implements Runnable &#123; private Clerk clerk; public Consumer (Clerk clerk)&#123; this.clerk = clerk; &#125; @Override public void run() &#123; System.out.println("消费者消费产品！"); while (true)&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; clerk.sellProduct(); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP 概念小结]]></title>
    <url>%2F2015%2F03%2F03%2F7-Http-Socket%2F2-TCP%3AIP%2F</url>
    <content type="text"><![CDATA[为什么会有TCP/IP协议？在世界上各地，各种各样的电脑运行着各自不同的操作系统为大家服务，计算机使用者意识到，计算机只是单兵作战并不会发挥太大的作用。只有把它们联合起来，电脑才会发挥出它最大的潜力。于是人们就想方设法的用电线把电脑连接到了一起。 但是简单的连到一起是远远不够的，就好像语言不同的两个人互相见了面，完全不能交流信息。因而他们需要定义一些共通的东西来进行交流，TCP/IP就是为此而生。 TCP/IP不是一个协议，而是一个协议族的统称。里面包括了IP协议，IMCP协议，TCP协议，以及我们更加熟悉的http、ftp、pop3协议等等。电脑有了这些，就好像学会了外语一样，就可以和其他的计算机终端做自由的交流了。 TCP/IP协议分层提到协议分层，我们很容易联想到ISO-OSI的七层协议经典架构，但是TCP/IP协议族的结构则稍有不同。如图所示 TCP/IP协议族按照层次由上到下，层层包装。 最上面是应用层，这里面有http，ftp,等等我们熟悉的协议。 第二层则是传输层，著名的TCP和UDP协议就在这个层次。 第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据（后面会讲到）以确定传输的目标。 第四层是叫数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。 再往下则是硬件层次了，负责网络的传输，这个层次的定义包括网线的制式，网卡的定义等等（这些我们就不用关心了，我们也不做网卡），所以有些书并不把这个层次放在tcp/ip协议族里面，因为它几乎和tcp/ip协议的编写者没有任何的关系。 发送协议的主机从上自下将数据按照协议封装，而接收数据的主机则按照协议从得到的数据包解开，最后拿到需要的数据。这种结构非常有栈的味道，所以某些文章也把tcp/ip协议族称为tcp/ip协议栈。 基本常识在学习协议之前，我们应该具备一些基本知识。 互联网地址(ip地址)网络上每一个节点都必须有一个独立的Internet地址（也叫做IP地址）。现在，通常使用的IP地址是一个32bit的数字，也就是我们常说的IPv4标准，这32bit的数字分成四组，也就是常见的255.255.255.255的样式。IPv4标准上，地址被分为五类，我们常用的是B类地址。具体的分类请参考其他文档。需要注意的是IP地址是网络号+主机号的组合，这非常重要。 域名系统是一个分布的数据库，它提供将主机名（就是网址啦）转换成IP地址的服务。 RFC是什么？RFC就是tcp/ip协议的标准文档，在这里我们可以看到RFC那长长的定义列表，现在它一共有4000多个协议的定义，当然，我们所要学习的，也就是那么十几个协议而已。 端口号(port)注意，这个号码是用在TCP，UDP上的一个逻辑号码，并不是一个硬件端口，我们平时说把某某端口封掉了，也只是在IP层次把带有这个号码的IP包给过滤掉了而已。 应用编程接口现在常用的编程接口有socket和TLI。而前面的有时候也叫做“Berkeley socket”，可见Berkeley对于网络的发展有多大的贡献。 TCP 协议终于看到了TCP协议，这是TCP/IP详解里面最重要也是最精彩的部分，要花大力气来读。TCP和UDP处在同一层—传输层，但是TCP和UDP最不同的地方是，TCP提供了一种可靠的数据传输服务，TCP是面向连接的，也就是说，利用TCP通信的两台主机首先要经历一个“拨打电话”的过程，等到通信准备结束才开始传输数据，最后结束通话。所以TCP要比UDP可靠的多，UDP是把数据直接发出去，而不管对方是不是在收信，就算是UDP无法送达，也不会产生ICMP差错报文。 把TCP保证可靠性的简单工作原理摘抄如下 应用数据被分割成TCP认为最适合发送的数据块。这和UDP完全不同，UDP应用程序产生的数据报长度将保持不变。由TCP传递给IP的信息单位称为报文段或段（ segment）。 当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒。 TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错， TCP将丢弃这个报文段和不确认收到此报文段（希望发端超时并重发）。 既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。如果必要， TCP将对收到的数据进行重新排序，将收到的数据以正确的顺序交给应用层。 TCP还能提供流量控制。TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。 从这段话中可以看到，TCP中保持可靠性的方式就是超时重发，这是有道理的，虽然TCP也可以用各种各样的ICMP报文来处理这些，但是这也不是可靠的，最可靠的方式就是只要不得到确认，就重新发送数据报，直到得到对方的确认为止。 TCP的首部和UDP首部一样，都有发送端口号和接收端口号。但是显然，TCP的首部信息要比UDP的多，可以看到，TCP协议提供了发送和确认所需要的所有必要的信息。可以想象一个TCP数据的发送应该是如下的一个过程。 双方建立连接 发送方给接受方TCP数据报，然后等待对方的确认TCP数据报，如果没有，就重新发，如果有，就发送下一个数据报。 接受方等待发送方的数据报，如果得到数据报并检验无误，就发送ACK(确认)数据报，并等待下一个TCP数据报的到来。直到接收到FIN(发送完成数据报) 可以想见，为了建立一个TCP连接，系统可能会建立一个新的进程（最差也是一个线程），来进行数据的传送。 TCP连接的建立与中止TCP是一个面向连接的协议，所以在连接双方发送数据之前，都需要首先建立一条连接。这和前面讲到的协议完全不同。前面讲的所有协议都只是发送数据而已，大多数都不关心发送的数据是不是送到，UDP尤其明显，从编程的角度来说，UDP编程也要简单的多—-UDP都不用考虑数据分片。书中用telnet登陆退出来解释TCP协议连接的建立和中止的过程，可以看到，TCP连接的建立可以简单的称为三次握手，而连接的中止则可以叫做四次握手。 1、连接的建立在建立连接的时候，客户端首先向服务器申请打开某一个端口(用SYN段等于1的TCP报文)，然后服务器端发回一个ACK报文通知客户端请求报文收到，客户端收到确认报文以后再次发出确认报文确认刚才服务器端发出的确认报文（绕口么），至此，连接的建立完成。这就叫做三次握手。如果打算让双方都做好准备的话，一定要发送三次报文，而且只需要三次报文就可以了。 可以想见，如果再加上TCP的超时重传机制，那么TCP就完全可以保证一个数据包被送到目的地。 2、结束连接 TCP有一个特别的概念叫做half-close，这个概念是说，TCP的连接是全双工（可以同时发送和接收）连接，因此在关闭连接的时候，必须关闭传和送两个方向上的连接。客户机给服务器一个FIN为1的TCP报文，然后服务器返回给客户端一个确认ACK报文，并且发送一个FIN报文，当客户机回复ACK报文后（四次握手），连接就结束了。 3、最大报文长度在建立连接的时候，通信的双方要互相确认对方的最大报文长度(MSS)，以便通信。一般这个SYN长度是MTU减去固定IP首部和TCP首部长度。对于一个以太网，一般可以达到1460字节。当然如果对于非本地的IP，这个MSS可能就只有536字节，而且，如果中间的传输网络的MSS更佳的小的话，这个值还会变得更小。 4、为什么连接的时候是三次握手，关闭的时候却是四次握手？答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，”你发的FIN报文我收到了”。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。 5、为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程总结]]></title>
    <url>%2F2015%2F03%2F03%2F5-Multithreaded%2F5-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1、多线程有什么用？一个可能在很多人看来很扯淡的一个问题：我会用多线程就好了，还管它有什么用？在我看来，这个回答更扯淡。所谓”知其然知其所以然”，”会用”只是”知其然”，”为什么用”才是”知其所以然”，只有达到”知其然知其所以然”的程度才可以说是把一个知识点运用自如。OK，下面说说我对这个问题的看法： （1）发挥多核CPU的优势 随着工业的进步，现在的笔记本、台式机乃至商用的应用服务器至少也都是双核的，4核、8核甚至16核的也都不少见，如果是单线程的程序，那么在双核CPU上就浪费了50%，在4核CPU上就浪费了75%。单核CPU上所谓的”多线程”那是假的多线程，同一时间处理器只会处理一段逻辑，只不过线程之间切换得比较快，看着像多个线程”同时”运行罢了。多核CPU上的多线程才是真正的多线程，它能让你的多段逻辑同时工作，多线程，可以真正发挥出多核CPU的优势来，达到充分利用CPU的目的。 （2）防止阻塞 从程序运行效率的角度来看，单核CPU不但不会发挥出多线程的优势，反而会因为在单核CPU上运行多线程导致线程上下文的切换，而降低程序整体的效率。但是单核CPU我们还是要应用多线程，就是为了防止阻塞。试想，如果单核CPU使用单线程，那么只要这个线程阻塞了，比方说远程读取某个数据吧，对端迟迟未返回又没有设置超时时间，那么你的整个程序在数据返回回来之前就停止运行了。多线程可以防止这个问题，多条线程同时运行，哪怕一条线程的代码执行读取数据阻塞，也不会影响其它任务的执行。 （3）便于建模 这是另外一个没有这么明显的优点了。假设有一个大的任务A，单线程编程，那么就要考虑很多，建立整个程序模型比较麻烦。但是如果把这个大的任务A分解成几个小任务，任务B、任务C、任务D，分别建立程序模型，并通过多线程分别运行这几个任务，那就简单很多了。 2、创建线程的方式比较常见的一个问题了，一般就是两种： 继承Thread类 实现Runnable接口 至于哪个好，不用说肯定是后者好，因为实现接口的方式比继承类的方式更灵活，也能减少程序之间的耦合度，面向接口编程也是设计模式6大原则的核心。 3、start()方法和run()方法的区别只有调用了start()方法，才会表现出多线程的特性，不同线程的run()方法里面的代码交替执行。如果只是调用run()方法，那么代码还是同步执行的，必须等待一个线程的run()方法里面的代码全部执行完毕之后，另外一个线程才可以执行其run()方法里面的代码。 4、Runnable接口和Callable接口的区别有点深的问题了，也看出一个Java程序员学习知识的广度。 Runnable接口中的run()方法的返回值是void，它做的事情只是纯粹地去执行run()方法中的代码而已；Callable接口中的call()方法是有返回值的，是一个泛型，和Future、FutureTask配合可以用来获取异步执行的结果。 这其实是很有用的一个特性，因为多线程相比单线程更难、更复杂的一个重要原因就是因为多线程充满着未知性，某条线程是否执行了？某条线程执行了多久？某条线程执行的时候我们期望的数据是否已经赋值完毕？无法得知，我们能做的只是等待这条多线程的任务执行完毕而已。而Callable+Future/FutureTask却可以获取多线程运行的结果，可以在等待时间太长没获取到需要的数据的情况下取消该线程的任务，真的是非常有用。 5、CyclicBarrier和CountDownLatch的区别两个看上去有点像的类，都在java.util.concurrent下，都可以用来表示代码运行到某个点上，二者的区别在于： CyclicBarrier的某个线程运行到某个点上之后，该线程即停止运行，直到所有的线程都到达了这个点，所有线程才重新运行；CountDownLatch则不是，某线程运行到某个点上之后，只是给某个数值-1而已，该线程继续运行 CyclicBarrier只能唤起一个任务，CountDownLatch可以唤起多个任务 CyclicBarrier可重用，CountDownLatch不可重用，计数值为0该CountDownLatch就不可再用了 6、volatile关键字的作用一个非常重要的问题，是每个学习、应用多线程的Java程序员都必须掌握的。理解volatile关键字的作用的前提是要理解Java内存模型，这里就不讲Java内存模型了，可以参见第31点，volatile关键字的作用主要有两个： 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据 代码底层执行不像我们看到的高级语言—-Java程序这么简单，它的执行是Java代码–&gt;字节码–&gt;根据字节码执行对应的C/C++代码–&gt;C/C++代码被编译成汇编语言–&gt;和硬件电路交互，现实中，为了获取更好的性能JVM可能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止语义重排序，当然这也一定程度上降低了代码执行效率 从实践角度而言，volatile的一个重要作用就是和CAS结合，保证了原子性，详细的可以参见java.util.concurrent.atomic包下的类，比如AtomicInteger。 7、什么是线程安全又是一个理论的问题，各式各样的答案有很多，我给出一个个人认为解释地最好的：如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。 这个问题有值得一提的地方，就是线程安全也是有几个级别的： （1）不可变像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用 ##（2）绝对线程安全 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet ##（3）相对线程安全 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。 ##（4）线程非安全 这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类 8、Java中如何获取到线程dump文件死循环、死锁、阻塞、页面打开慢等问题，打线程dump是最好的解决问题的途径。所谓线程dump也就是线程堆栈，获取到线程堆栈有两步： （1）获取到线程的pid，可以通过使用jps命令，在Linux环境下还可以使用ps -ef | grep java （2）打印线程堆栈，可以通过使用jstack pid命令，在Linux环境下还可以使用kill -3 pid 另外提一点，Thread类提供了一个getStackTrace()方法也可以用于获取线程堆栈。这是一个实例方法，因此此方法是和具体线程实例绑定的，每次获取获取到的是具体某个线程当前运行的堆栈， 9、一个线程如果出现了运行时异常会怎么样如果这个异常没有被捕获的话，这个线程就停止执行了。另外重要的一点是：如果这个线程持有某个某个对象的监视器，那么这个对象监视器会被立即释放。 10、如何在两个线程之间共享数据通过在线程之间共享对象就可以了，然后通过wait/notify/notifyAll、await/signal/signalAll进行唤起和等待，比方说阻塞队列BlockingQueue就是为线程之间共享数据而设计的 11、sleep方法和wait方法有什么区别这个问题常问，sleep方法和wait方法都可以用来放弃CPU一定的时间，不同点在于如果线程持有某个对象的监视器，sleep方法不会放弃这个对象的监视器，wait方法会放弃这个对象的监视器。 12、生产者消费者模型的作用是什么这个问题很理论，但是很重要： （1）通过平衡生产者的生产能力和消费者的消费能力来提升整个系统的运行效率，这是生产者消费者模型最重要的作用 （2）解耦，这是生产者消费者模型附带的作用，解耦意味着生产者和消费者之间的联系少，联系越少越可以独自发展而不需要收到相互的制约 13、ThreadLocal有什么用简单说ThreadLocal就是一种以空间换时间的做法，在每个Thread里面维护了一个以开地址法实现的ThreadLocal.ThreadLocalMap，把数据进行隔离，数据不共享，自然就没有线程安全方面的问题了 14、为什么wait()方法和notify()/notifyAll()方法要在同步块中被调用这是JDK强制的，wait()方法和notify()/notifyAll()方法在调用前都必须先获得对象的锁 15、wait()方法和notify()/notifyAll()方法在放弃对象监视器时有什么区别wait()方法和notify()/notifyAll()方法在放弃对象监视器的时候的区别在于：wait()方法立即释放对象监视器，notify()/notifyAll()方法则会等待线程剩余代码执行完毕才会放弃对象监视器。 16、为什么要使用线程池避免频繁地创建和销毁线程，达到线程对象的重用。另外，使用线程池还可以根据项目灵活地控制并发的数目。 17、怎么检测一个线程是否持有对象监视器我也是在网上看到一道多线程面试题才知道有方法可以判断某个线程是否持有对象监视器：Thread类提供了一个holdsLock(Object obj)方法，当且仅当对象obj的监视器被某条线程持有的时候才会返回true，注意这是一个static方法，这意味着”某条线程”指的是当前线程。 18、synchronized和ReentrantLock的区别synchronized是和if、else、for、while一样的关键字，ReentrantLock是类，这是二者的本质区别。既然ReentrantLock是类，那么它就提供了比synchronized更多更灵活的特性，可以被继承、可以有方法、可以有各种各样的类变量，ReentrantLock比synchronized的扩展性体现在几点上： ReentrantLock可以对获取锁的等待时间进行设置，这样就避免了死锁 ReentrantLock可以获取各种锁的信息 ReentrantLock可以灵活地实现多路通知 另外，二者的锁机制其实也是不一样的。ReentrantLock底层调用的是Unsafe的park方法加锁，synchronized操作的应该是对象头中mark word，这点我不能确定。 19、ConcurrentHashMap的并发度是什么ConcurrentHashMap的并发度就是segment的大小，默认为16，这意味着最多同时可以有16条线程操作ConcurrentHashMap，这也是ConcurrentHashMap对Hashtable的最大优势，任何情况下，Hashtable能同时有两条线程获取Hashtable中的数据吗？ 20、ReadWriteLock是什么首先明确一下，不是说ReentrantLock不好，只是ReentrantLock某些时候有局限。如果使用ReentrantLock，可能本身是为了防止线程A在写数据、线程B在读数据造成的数据不一致，但这样，如果线程C在读数据、线程D也在读数据，读数据是不会改变数据的，没有必要加锁，但是还是加锁了，降低了程序的性能。 因为这个，才诞生了读写锁ReadWriteLock。ReadWriteLock是一个读写锁接口，ReentrantReadWriteLock是ReadWriteLock接口的一个具体实现，实现了读写的分离，读锁是共享的，写锁是独占的，读和读之间不会互斥，读和写、写和读、写和写之间才会互斥，提升了读写的性能。 21、FutureTask是什么这个其实前面有提到过，FutureTask表示一个异步运算的任务。FutureTask里面可以传入一个Callable的具体实现类，可以对这个异步运算的任务的结果进行等待获取、判断是否已经完成、取消任务等操作。当然，由于FutureTask也是Runnable接口的实现类，所以FutureTask也可以放入线程池中。 22、Linux环境下如何查找哪个线程使用CPU最长这是一个比较偏实践的问题，这种问题我觉得挺有意义的。可以这么做： （1）获取项目的pid，jps或者ps -ef | grep java，这个前面有讲过 （2）top -H -p pid，顺序不能改变 这样就可以打印出当前的项目，每条线程占用CPU时间的百分比。注意这里打出的是LWP，也就是操作系统原生线程的线程号，我笔记本上没有部署Linux环境下的Java工程，因此没有办法截图演示，网友朋友们如果公司是使用Linux环境部署项目的话，可以尝试一下。 使用”top -H -p pid”+”jps pid”可以很容易地找到某条占用CPU高的线程的线程堆栈，从而定位占用CPU高的原因，一般是因为不当的代码操作导致了死循环。 最后提一点，”top -H -p pid”打出来的LWP是十进制的，”jps pid”打出来的本地线程号是十六进制的，转换一下，就能定位到占用CPU高的线程的当前线程堆栈了。 23、Java编程写一个会导致死锁的程序第一次看到这个题目，觉得这是一个非常好的问题。很多人都知道死锁是怎么一回事儿：线程A和线程B相互等待对方持有的锁导致程序无限死循环下去。当然也仅限于此了，问一下怎么写一个死锁的程序就不知道了，这种情况说白了就是不懂什么是死锁，懂一个理论就完事儿了，实践中碰到死锁的问题基本上是看不出来的。 真正理解什么是死锁，这个问题其实不难，几个步骤： 两个线程里面分别持有两个Object对象：lock1和lock2。这两个lock作为同步代码块的锁； 线程1的run()方法中同步代码块先获取lock1的对象锁，Thread.sleep(xxx)，时间不需要太多，50毫秒差不多了，然后接着获取lock2的对象锁。这么做主要是为了防止线程1启动一下子就连续获得了lock1和lock2两个对象的对象锁 线程2的run)(方法中同步代码块先获取lock2的对象锁，接着获取lock1的对象锁，当然这时lock1的对象锁已经被线程1锁持有，线程2肯定是要等待线程1释放lock1的对象锁的 这样，线程1”睡觉”睡完，线程2已经获取了lock2的对象锁了，线程1此时尝试获取lock2的对象锁，便被阻塞，此时一个死锁就形成了。代码就不写了，占的篇幅有点多，Java多线程7：死锁这篇文章里面有，就是上面步骤的代码实现。 24、怎么唤醒一个阻塞的线程如果线程是因为调用了wait()、sleep()或者join()方法而导致的阻塞，可以中断线程，并且通过抛出InterruptedException来唤醒它；如果线程遇到了IO阻塞，无能为力，因为IO是操作系统实现的，Java代码并没有办法直接接触到操作系统。 25、不可变对象对多线程有什么帮助前面有提到过的一个问题，不可变对象保证了对象的内存可见性，对不可变对象的读取不需要进行额外的同步手段，提升了代码执行效率。 26、什么是多线程的上下文切换多线程的上下文切换是指CPU控制权由一个已经正在运行的线程切换到另外一个就绪并等待获取CPU执行权的线程的过程。 27、如果你提交任务时，线程池队列已满，这时会发生什么如果你使用的LinkedBlockingQueue，也就是无界队列的话，没关系，继续添加任务到阻塞队列中等待执行，因为LinkedBlockingQueue可以近乎认为是一个无穷大的队列，可以无限存放任务； 如果你使用的是有界队列比方说ArrayBlockingQueue的话，任务首先会被添加到ArrayBlockingQueue中，ArrayBlockingQueue满了，则会使用拒绝策略RejectedExecutionHandler处理满了的任务，默认是AbortPolicy。 28、Java中用到的线程调度算法是什么抢占式。一个线程用完CPU之后，操作系统会根据线程优先级、线程饥饿情况等数据算出一个总的优先级并分配下一个时间片给某个线程执行。 29、Thread.sleep(0)的作用是什么这个问题和上面那个问题是相关的，我就连在一起了。由于Java采用抢占式的线程调度算法，因此可能会出现某条线程常常获取到CPU控制权的情况，为了让某些优先级比较低的线程也能获取到CPU控制权，可以使用Thread.sleep(0)手动触发一次操作系统分配时间片的操作，这也是平衡CPU控制权的一种操作。 30、什么是自旋很多synchronized里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在synchronized的边界做忙循环，这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。 31、什么是Java内存模型Java内存模型定义了一种多线程访问Java内存的规范。Java内存模型要完整讲不是这里几句话能说清楚的，我简单总结一下Java内存模型的几部分内容： Java内存模型将内存分为了主内存和工作内存。类的状态，也就是类之间共享的变量，是存储在主内存中的，每次Java线程用到这些主内存中的变量的时候，会读一次主内存中的变量，并让这些内存在自己的工作内存中有一份拷贝，运行自己线程代码的时候，用到这些变量，操作的都是自己工作内存中的那一份。在线程代码执行完毕之后，会将最新的值更新到主内存中去 定义了几个原子操作，用于操作主内存和工作内存中的变量 定义了volatile变量的使用规则 happens-before，即先行发生原则，定义了操作A必然先行发生于操作B的一些规则，比如在同一个线程内控制流前面的代码一定先行发生于控制流后面的代码、一个释放锁unlock的动作一定先行发生于后面对于同一个锁进行锁定lock的动作等等，只要符合这些规则，则不需要额外做同步措施，如果某段代码不符合所有的happens-before规则，则这段代码一定是线程非安全的 32、什么是CASCAS，全称为Compare and Swap，即比较-替换。假设有三个操作数：内存值V、旧的预期值A、要修改的值B，当且仅当预期值A和内存值V相同时，才会将内存值修改为B并返回true，否则什么都不做并返回false。当然CAS一定要volatile变量配合，这样才能保证每次拿到的变量是主内存中最新的那个值，否则旧的预期值A对某条线程来说，永远是一个不会变的值A，只要某次CAS操作失败，永远都不可能成功。 33、什么是乐观锁和悲观锁（1）乐观锁：就像它的名字一样，对于并发间操作产生的线程安全问题持乐观状态，乐观锁认为竞争不总是会发生，因此它不需要持有锁，将比较-替换这两个动作作为一个原子操作尝试去修改内存中的变量，如果失败则表示发生冲突，那么就应该有相应的重试逻辑。 （2）悲观锁：还是像它的名字一样，对于并发间操作产生的线程安全问题持悲观状态，悲观锁认为竞争总是会发生，因此每次对某资源进行操作时，都会持有一个独占的锁，就像synchronized，不管三七二十一，直接上了锁就操作资源了。 34、什么是AQS简单说一下AQS，AQS全称为AbstractQueuedSychronizer，翻译过来应该是抽象队列同步器。 如果说java.util.concurrent的基础是CAS的话，那么AQS就是整个Java并发包的核心了，ReentrantLock、CountDownLatch、Semaphore等等都用到了它。AQS实际上以双向队列的形式连接所有的Entry，比方说ReentrantLock，所有等待的线程都被放在一个Entry中并连成双向队列，前面一个线程使用ReentrantLock好了，则双向队列实际上的第一个Entry开始运行。 AQS定义了对双向队列所有的操作，而只开放了tryLock和tryRelease方法给开发者使用，开发者可以根据自己的实现重写tryLock和tryRelease方法，以实现自己的并发功能。 35、单例模式的线程安全性老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下： （1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全 36、Semaphore有什么作用Semaphore就是一个信号量，它的作用是限制某段代码块的并发数。Semaphore有一个构造函数，可以传入一个int型整数n，表示某段代码最多只有n个线程可以访问，如果超出了n，那么请等待，等到某个线程执行完毕这段代码块，下一个线程再进入。由此可以看出如果Semaphore构造函数中传入的int型整数n=1，相当于变成了一个synchronized了。 37、Hashtable的size()方法中明明只有一条语句”return count”，为什么还要做同步？这是我之前的一个困惑，不知道大家有没有想过这个问题。某个方法中如果有多条语句，并且都在操作同一个类变量，那么在多线程环境下不加锁，势必会引发线程安全问题，这很好理解，但是size()方法明明只有一条语句，为什么还要加锁？ 关于这个问题，在慢慢地工作、学习中，有了理解，主要原因有两点： （1）同一时间只能有一条线程执行固定类的同步方法，但是对于类的非同步方法，可以多条线程同时访问。所以，这样就有问题了，可能线程A在执行Hashtable的put方法添加数据，线程B则可以正常调用size()方法读取Hashtable中当前元素的个数，那读取到的值可能不是最新的，可能线程A添加了完了数据，但是没有对size++，线程B就已经读取size了，那么对于线程B来说读取到的size一定是不准确的。而给size()方法加了同步之后，意味着线程B调用size()方法只有在线程A调用put方法完毕之后才可以调用，这样就保证了线程安全性。 （2）CPU执行代码，执行的不是Java代码，这点很关键，一定得记住。Java代码最终是被翻译成汇编代码执行的，汇编代码才是真正可以和硬件电路交互的代码。即使你看到Java代码只有一行，甚至你看到Java代码编译之后生成的字节码也只有一行，也不意味着对于底层来说这句语句的操作只有一个。一句”return count”假设被翻译成了三句汇编语句执行，完全可能执行完第一句，线程就切换了。 38、线程类的构造方法、静态块是被哪个线程调用的这是一个非常刁钻和狡猾的问题。请记住：线程类的构造方法、静态块是被new这个线程类所在的线程所调用的，而run方法里面的代码才是被线程自身所调用的。 如果说上面的说法让你感到困惑，那么我举个例子，假设Thread2中new了Thread1，main函数中new了Thread2，那么： （1）Thread2的构造方法、静态块是main线程调用的，Thread2的run()方法是Thread2自己调用的 （2）Thread1的构造方法、静态块是Thread2调用的，Thread1的run()方法是Thread1自己调用的 39、同步方法和同步块，哪个是更好的选择同步块，这意味着同步块之外的代码是异步执行的，这比同步整个方法更提升代码的效率。请知道一条原则：同步的范围越小越好。 借着这一条，我额外提一点，虽说同步的范围越少越好，但是在Java虚拟机中还是存在着一种叫做锁粗化的优化方法， 锁粗化的优化 这种方法就是把同步范围变大。这是有用的，比方说StringBuffer，它是一个线程安全的类，自然最常用的append()方法是一个同步方法，我们写代码的时候会反复append字符串，这意味着要进行反复的加锁-&gt;解锁，这对性能不利，因为这意味着Java虚拟机在这条线程上要反复地在内核态和用户态之间进行切换，因此Java虚拟机会将多次append方法调用的代码进行一个锁粗化的操作，将多次的append的操作扩展到append方法的头尾，变成一个大的同步块，这样就减少了加锁–&gt;解锁的次数，有效地提升了代码执行的效率。 40、高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？这是我在并发编程网上看到的一个问题，把这个问题放在最后一个，希望每个人都能看到并且思考一下，因为这个问题非常好、非常实际、非常专业。关于这个问题，个人看法是： （1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换； （2）并发不高、任务执行时间长的业务要区分开看： a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以加大线程池中的线程数目，让CPU处理更多的业务 b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 （3）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程常用方法]]></title>
    <url>%2F2015%2F03%2F03%2F5-Multithreaded%2F2-%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[多线程常用方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* * Thread的常用方法： * 1.start() :启动线程并执行相应的run()方法 * 2.run() :子线程要执行的代码放入run()方法中 * 3.currentThread():静态方法: 调取当前的线程 * 4.getName() :获取此线程的名字 * 5.setName() :设置此线程的名字，主线程main也可以设置。 * 6.yield() :调用此方法的线程释放当前CPU的执行权 * 7.join() :在A线程中调用B线程的join()方法，表示：当执行到此方法，A线程停止执行，直至B线程执行完毕， * A线程再接着join()之后的代码执行 * 8.isAlive() :判断当前线程是否还存活 * 9.sleep(long l) :显式的让当前线程睡眠 l 毫秒 * 10.线程通信 : wait() 等待 notify() notifyAll() 通知,唤醒 * * 设置线程的优先级 * getPriority() ：返回线程优先值 setPriority(int newPriority) ：改变线程的优先级&lt;!-- more --&gt; */class SubThread1 extends Thread &#123; public void run() &#123; for ( int i = 1; i &lt;= 100; i++) &#123; // try &#123; // Thread.currentThread().sleep(1000); // &#125; catch (InterruptedException e) &#123; // // TODO Auto-generated catch block // e.printStackTrace(); // &#125; System. out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); &#125; &#125;&#125;public class TestThread1 &#123; public static void main(String[] args) &#123; SubThread1 st1 = new SubThread1(); st1.setName( "子线程1"); st1.setPriority(Thread. MAX_PRIORITY); st1.start(); Thread. currentThread().setName("========主线程"); for ( int i = 1; i &lt;= 100; i++) &#123; System. out.println(Thread.currentThread().getName() + ":" + Thread.currentThread().getPriority() + ":" + i); // if(i % 10 == 0)&#123; // Thread.currentThread().yield(); // &#125; // if(i == 20)&#123; // try &#123; // st1.join(); // &#125; catch (InterruptedException e) &#123; // // TODO Auto-generated catch block // e.printStackTrace(); // &#125; // &#125; &#125; System. out.println(st1.isAlive()); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO 流]]></title>
    <url>%2F2015%2F03%2F03%2F4-IO-Stream%2FIO%2F</url>
    <content type="text"><![CDATA[总览字节流：一次读入或读出是8位二进制。字符流：一次读入或读出是16位二进制。 字节流和字符流的原理是相同的，只不过处理的单位不同而已。后缀是Stream是字节流，而后缀是Reader，Writer是字符流。 节点流：直接与数据源相连，读入或读出。 直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。 处理流：与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。 1、java.io包下的File类 File类：java程序中的此类的一个对象，就对应着硬盘中的一个文件或网络中的一个资源。 1234File file1 = new File("d:\\io\\helloworld.txt");File file2 = new File("d:\\io\\io1"); //或者 File file3 = new File("d:/io/io1"); File的静态属性String separator存储了当前系统的路径分隔符。在UNIX中，此字段为‘/’，在Windows中，为‘\’ File既可以表示一个文件（.doc .xls .mp3 .avi .jpg .dat），也可以表示一个文件目录！ File类的对象是与平台无关的。 File类针对于文件或文件目录，只能进行新建、删除、重命名、上层目录等等的操作。如果涉及到访问文件的内容，File是无能为力的，只能使用IO流下 提供的相应的输入输出流来实现。 常把File类的对象作为形参传递给相应的输入输出流的构造器中！ File类的常见构造方法：12345public File(String pathname) 以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储。 public File(String parent,String child) 以parent为父路径，child为子路径创建File对象。 2、IO 流的结构 分类 字节输入流 字节输出流 字符输入流 字符输出流 抽象基类 InputStream OutputStream Reader Writer 访问文件 FileInputStream FileOutputStream FileReader FileWriter 访问数组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 访问管道 PipedInputStream PipedOutputStream PipedReader PipedWriter 访问字符串 StringReader StringWriter 缓冲流 BufferedInputStream BufferedOutputStream BufferedReader BufferedWriter 转换流 InputStreamReader OutputStreamWriter 对象流 ObjectInputStream ObjectOutputStream FilterInputStream FilterOutputStream FilterReader FilterWriter 打印流 PrintStream PrintWriter 推回输入流 PushbackInputStream PushbackReader 特殊流 DataInputStream DataOutputStream 3、IO流的划分 按照流的流向的不同：输入流 输出流 (站位于程序的角度) 按照流中的数据单位的不同：字节流 字符流 （纯文本文件使用字符流 ，除此之外使用字节流） 按照流的角色的不同：节点流 处理流（流直接作用于文件上是节点流（4个），除此之外都是处理流） 4、重点掌握 抽象基类 节点流(文件流) 缓冲流（处理流的一种,可以提升文件操作的效率） InputStream FileInputStream （int read(byte[] b)） BufferedInputStream (int read(byte[] b)) OutputStream FileOutputStream (void write(b,0,len)) BufferedOutputStream (flush()) (void write(b,0,len)) Reader FileReader (int read(char[] c)) BufferedReader (readLine()) (int read(char[] c))或String readLine() Writer FileWriter (void write(c,0,len)) BufferedWriter (flush()) (void write(c,0,len)或void write(String str)) 注： 从硬盘中读入一个文件，要求此文件一定得存在。若不存在，报FileNotFoundException的异常； 从程序中输出一个文件到硬盘，此文件可以不存在。若不存在，就创建一个实现输出。若存在，则将已存在的文件覆盖； 真正开发时，就使用缓冲流来代替节点流； 主要最后要关闭相应的流。先关闭输出流，再关闭输入流。将此操作放入finally。 5、其它的流1、转换流：实现字节流与字符流之间的转换12345InputStreamReader: 输入时，实现字节流到字符流的转换，提高操作的效率（前提是，数据是文本文件） ===&gt;解码：字节数组---&gt;字符串 OutputStreamWriter：输出时，实现字符流到字节流的转换。 ===&gt;编码： 字符串----&gt;字节数组 2、标准的输入输出流12System.in: The "standard" input stream: 从键盘输入数据 System.out: The "standard" output stream： 从显示器输出数据 3、打印流 (都是输出流) PrintStream(处理字节) PrintWriter(处理字符)4、数据流（处理基本数据类型、String类、字节数组）DataInputStream DataOutputStream 5、对象流(用来处理对象的)对象的序列化机制：允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 12345678910111213141516171819202122232425262728293031// ObjectInputStream（Object readObject();） // ObjectOutputStream (void writeObject(Object obj)) 如何创建流的对象：ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File("person.txt")));ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File("person.txt")));``` 实现序列化机制的对象对应的类的要求：1. 要求类要实现Serializable接口2. 同样要求类的所有属性也必须实现Serializable接口3. 要求给类提供一个序列版本号：private static final long serialVersionUID;4. 属性声明为static 或transient的，不可以实现序列化## 6、随机存取文件流:RandomAccessFile1. 既可以充当一个输入流，又可以充当一个输出流：`public RandomAccessFile(File file, String mode)`2. 支持从文件的开头读取、写入。若输出的文件不存在，直接创建。若存在，则是对原有文件内容的覆盖。3. 支持任意位置的“插入”。```java// 构造器public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) // 创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式：r: 以只读方式打开rw：打开以便读取和写入rwd:打开以便读取和写入；同步文件内容的更新rws:打开以便读取和写入；同步文件内容和元数据的更新]]></content>
      <tags>
        <tag>Java</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程概念]]></title>
    <url>%2F2015%2F03%2F03%2F5-Multithreaded%2F1-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[理解程序、进程、线程的概念程序：静态的代码；进程：执行中的程序，动态的过程；线程：进程的进一步细分，程序的一条执行路径。 如何创建java程序的线程（重点）123456789101112131415161718192021222324252627282930313233343536方式一：继承于Thread类/* * 创建一个子线程，完成1-100之间自然数的输出。同样地，主线程执行同样的操作 * 创建多线程的第一种方式：继承java.lang.Thread类 */// 1.创建一个继承于Thread的子类class SubThread extends Thread&#123;// 2.重写Thread类的run()方法.方法内实现此子线程要完成的功能 public void run()&#123; for( int i = 1;i &lt;= 100;i++)&#123; System. out.println(Thread. currentThread().getName() +":" + i); &#125; &#125;&#125;public class TestThread &#123; public static void main(String[] args) &#123; // 3.创建子类的对象 SubThread st1 = new SubThread(); SubThread st2 = new SubThread(); // 4.调用线程的start()：启动此线程；调用相应的run()方法 //一个线程只能够执行一次start() //不能通过Thread实现类对象的run()去启动一个线程 st1.start(); //st.start(); //st.run(); st2.start(); for( int i = 1;i &lt;= 100;i++)&#123; System. out.println(Thread. currentThread().getName() +":" + i); &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132方式二：实现Runnable接口 //1.创建一个实现了Runnable接口的类class PrintNum1 implements Runnable &#123; //2.实现接口的抽象方法 public void run() &#123; // 子线程执行的代码 for ( int i = 1; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; System. out.println(Thread. currentThread().getName() + ":" + i); &#125; &#125; &#125;&#125;public class TestThread1 &#123; public static void main(String[] args) &#123; //3.创建一个Runnable接口实现类的对象 PrintNum1 p = new PrintNum1();// p.start();// p.run(); //要想启动一个多线程，必须调用start() //4.将此对象作为形参传递给Thread类的构造器中，创建Thread类的对象，此对象即为一个线程 Thread t1 = new Thread(p); //5.调用start()方法：启动线程并执行run() t1.start(); //启动线程；执行Thread对象生成时构造器形参的对象的run()方法。 //再创建一个线程 Thread t2 = new Thread(p); t2.start(); &#125;&#125; 两种方式的对比联系：class Thread implements Runnable 比较哪个好？实现的方式较好。 解决了单继承的局限性； 如果多个线程有共享数据的话，建议使用实现方式，同时，共享数据所在的类可以作为Runnable接口的实现类； 线程的生命周期 线程的同步机制（重点、难点）前提： 如果我们创建的多个线程，存在着共享数据，那么就有可能出现线程的安全问题：当其中一个线程操作共享数据时，还未操作完成，另外的线程就参与进来，导致对共享数据的操作出现问题。 解决方式：要求一个线程操作共享数据时，只有当其完成操作完成共享数据，其它线程才有机会执行共享数据。 建议使用方式(非静态方法) 同步代码块(this) (静态方法) 同步代码块(clazz) : Class clazz = Singleton.class 方式一：同步代码块123synchronized(同步监视器)&#123; //操作共享数据的代码&#125; 注： 同步监视器：俗称锁，任何一个类的对象都可以充当锁.。要想保证线程的安全，必须要求所有的线程共用同一把锁！ 使用实现Runnable接口的方式创建多线程的话，同步代码块中的锁，可以考虑是this。如果使用继承Thread类的方式，慎用this! 共享数据：多个线程需要共同操作的变量。明确哪部分是操作共享数据的代码。 对于非静态的方法而言，使用同步的话，默认锁为：this； 对于静态的方法，如果使用同步，默认的锁为：当前类本身。以单例的懒汉式为例，Class clazz = Singleton.class。 方式二：同步方法1234//方法声明为synchronizedpublic synchronized void show( )&#123; 操作共享数据额代码&#125; 同步方法的锁默认为 this 如果使用在继承的方式实现多线程，同步方法中默认锁不可用this！ 同步会导致程序的执行效率降低，但是即使这样也不能不用！！！ 总结：释放锁: notify()/notifyAll(): notify()和notifyAll()都是Object对象用于通知处在等待该对象的线程的方法。 两者的最大区别在于： notifyAll()：使所有原来在该对象上等待被notify的线程统统退出wait的状态，变成等待该对象上的锁，一旦该对象被解锁，他们就会去竞争。 notify()：则文明得多，他只是选择一个wait状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象notify的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用notify语句，则即便该对象已经空闲，其他wait状态等待的线程由于没有得到该对象的通知，继续处在wait状态，直到这个对象发出一个notify或notifyAll，它们等待的是被notify或notifyAll，而不是锁。 不释放锁: sleep() , yield() , suspend() (过时，可能导致死锁) 死锁：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁，死锁是我们在使用同步时，需要避免的问题！ 5、线程的通信：重要： 如下的三个方法必须使用在同步代码块或同步方法中！ wait()当在同步中，执行到此方法，则此线程“等待”，直至其他线程执行notify()的方法，将其唤醒，唤醒后继续其wait()后的代码 notify()/notifyAll() notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行 释放自身对象锁，唤醒下一个\全部 等待线程，在同步中，执行到此方法，则唤醒其他的某一个或所有的被wait的线程。 例题：1.两个线程交替打印1-100自然数 2.生产者、消费者的例子]]></content>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2F2015%2F02%2F12%2F3-Exception%2F1-%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常体系结构 12345java.lang.Throwable |-----Error:错误，程序中不进行处理 |-----Exception:异常，要求在编写程序时，就要考虑到对这些异常的处理 |-----编译时异常：在编译期间会出现的异常（执行javac.exe命令时，出现异常） |-----运行时异常：在运行期间出现的异常 (执行java.exe命令时，出现异常) 因为java程序分为javac.exe和java.exe两个过程，在每个过程中，都有可能出现异常。故分为编译时异常、运行时异常 对于运行时异常比较常见，可以不显式的来处理。 对于编译时异常，必须要显式的处理 编译时异常，不是说有异常才处理，而是存在异常的隐患，必须在编译前，提示程序，万一出现异常，如何处理！ Throwable（可抛出）在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。 Throwable： 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。 Error :是程序无法处理的错误，表示运行应用程序中较严重问题。 大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java虚拟机运行错误Virtual MachineError，当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java虚拟机（JVM）一般会选择线程终止。 Exception :是程序本身可以处理的异常。 Exception 类有一个重要的子类 RuntimeException。RuntimeException 类及其子类表示“JVM 常用操作”引发的错误。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常NullPointerException、ArithmeticException和 ArrayIndexOutOfBoundException。 通常，Java的异常(包括Exception 和 Error)分为可查的异常checked exceptions和不可查的异常unchecked exceptions。 可查异常（编译器要求必须处置的异常）：可查异常虽是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常状况，就必须采取某种方式进行处理。 除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。 不可查异常（编译器不要求强制处置的异常）:包括运行时异常（RuntimeException与其子类）和错误（Error）。 Exception 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。 注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。 如何处理异常Java 中的“抓抛模型” “抛”：当我们执行代码时，一旦出现异常，就会在异常的代码处生成一个对应的异常类型的对象，并将此对象抛出。(自动抛出 / 手动抛出) 一旦抛出此异常类的对象，那么程序就终止执行 此异常类的对象抛给方法的调用者 “抓”：抓住上一步抛出来的异常类的对象。如何抓？即为异常处理的方式 java 提供了两种方式用来处理一个异常类的对象。 12345678910//处理的方式一：try&#123; //可能出现异常的代码&#125;catch(Exception1 e1)&#123; //处理的方式1&#125;catch(Exception2 e2)&#123; //处理的方式2&#125;finally&#123; //一定要执行的代码&#125; 注： try内声明的变量，类似于局部变量，出了try{ }语句，就不能被调用； finally是可选的； catch语句内部是对异常对象的处理：getMessage(); printStackTrace()； 可以有多个catch语句，try中抛出的异常类对象从上往下去匹配catch中的异常类的类型，一旦满足就执行catch中的代码。执行完，就跳出其后的多条catch语句； 如果异常被处理了，那么其后的代码继续执行。（这就是异常处理的好处）； 若catch中多个异常类型是”并列”关系，孰上孰下都可以。若catch中多个异常类型是”包含”关系，须将子类放在父类的上面，进行处理。否则报错； finally中存放的是一定会被执行的代码，不管try中、catch中是否仍有异常未被处理，以及是否有return语句； try-catch是可以嵌套的。 1234567891011121314151617181920212223处理方式二：在方法的声明处，显式的使用throws + 异常类型public void method1() throws Exception1 e1,Exception2 e2&#123; //可能出现异常（尤其是编译时异常，一定要处理）&#125; public void method2() throws Exception1 e1,Exception2 e2&#123; method1();&#125;public void method3()&#123; try&#123; method2(); &#125;catch(Exception1 e1)&#123; System.out.println(e1.getMessage()); &#125;catch(Exception2 e2)&#123; System.out.println(e2.getMessage()); &#125;&#125;public static void main(String[] args)&#123; 对象1.method3();//不会再出现上述的Exception1和Exception2的异常！&#125; 如何手动的抛出一个异常？在方法的内部，可以使用 throw + new 异常类对象，来手动的抛出一个异常！ 123456789101112131415161718192021//比较两个圆的半径的大小。public int compareTo(Object obj) throws Exception&#123; if(this == obj) &#123; return 0; &#125;else if(obj instanceof Circle) &#123; Circle c = (Circle)obj; if(this.radius &gt; c.radius) &#123; return 1; &#125;else if(this.radius == c.radius) &#123; return 0; &#125;else&#123; return -1; &#125; &#125;else&#123; //return -2; //手动的抛出一个异常 //throw new Exception("传入的类型有误！"); //throw new String("传入的类型有误！"); throw new MyException("传入的类型有误！"); &#125;&#125; 如何自定义一个异常类手动的抛出一个异常，除了抛出的是现成的异常类的对象之外，还可以抛出一个自定义的异常类的对象！ 自定义异常类 自定义的异常类继承现有的异常类 提供一个序列号，提供几个重载的构造器 12345678public class MyException extends Exception&#123; static final long serialVersionUID = -70348975766939L; public MyException()&#123; &#125; public MyException(String msg)&#123; super(msg); &#125;&#125; 五个关键字搞定异常处理！其中，要区分：throw与throws的区别？ 用户程序自定义的异常和应用程序特定的异常,必须借助于 throws 和 throw 语句来定义抛出异常。 throw是语句抛出一个异常。 throw e; throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常) 1public void doA(int a) throws Exception1,Exception3&#123;......&#125; throws E1,E2,E3只是告诉程序这个方法可能会抛出这些异常，方法的调用者可能要处理这些异常，而这些异常E1,E2,E3可能是该函数体产生的。throw 则是明确了这个地方要抛出这个异常。 1234567891011void doA(int a) throws IOException,&#123; try&#123; ...... &#125;catch(Exception1 e)&#123; throw e; &#125;catch(Exception2 e)&#123; System.out.println("出错了！"); &#125; if(a!=b) throw new Exception3("自定义异常");&#125; 代码块中可能会产生3个异常，(Exception1,Exception2,Exception3)。如果产生Exception1异常，则捕获之后再抛出，由该方法的调用者去处理；如果产生Exception2异常，则该方法自己处理了，所以该方法就不会再向外抛出Exception2异常了，void doA() throws Exception1,Exception3 里面的Exception2也就不用写了。而Exception3异常是该方法的某段逻辑出错，程序员自己做了处理，在该段逻辑错误的情况下抛出异常Exception3，则该方法的调用者也要处理此异常。 throw语句用在方法体内，表示抛出异常，由方法体内的语句处理。 throws语句用在方法声明后面，表示再抛出异常，由该方法的调用者来处理。 throws主要是声明这个方法会抛出这种类型的异常，使它的调用者知道要捕获这个异常。 throw是具体向外抛异常的动作，所以它是抛出一个异常实例。 throws说明你有那个可能，倾向。 throw的话，那就是你把那个倾向变成真实的了。 同时： throws出现在方法函数头；而throw出现在函数体。 throws表示出现异常的一种可能性，并不一定会发生这些异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 两者都是消极处理异常的方式（这里的消极并不是说这种方式不好），只是抛出或者可能抛出异常，但是不会由函数去处理异常，真正的处理异常由函数的上层调用处理。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>异常</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的5种方式]]></title>
    <url>%2F2015%2F02%2F09%2F2-Object-Oriented%2F7-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%845%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[作为Java开发者，我们每天都会创建大量的对象。但是，我们总是使用管理依赖系统（如Spring框架）来创建这些对象。其实还有其他方法可以创建对象，在接下来的文章中我会进行详细介绍。 1. 使用new关键字这是最常见的创建对象的方法，并且也非常简单。通过使用这种方法我们可以调用任何我们需要调用的构造函数。 1Employee emp1 = new Employee(); 2. 使用class类的newInstance方法我们也可以使用class类的newInstance()方法来创建对象。此newInstance()方法调用无参构造函数以创建对象。我们可以通过newInstance()用以下方式创建对象： 12Employee emp2 = (Employee) Class.forName("org.programming.mitra.exercises.Employee").newInstance();Employee emp2 = Employee.class.newInstance(); 3. 使用构造函数类的 newInstance方法与使用class类的newInstance()方法相似，java.lang.reflect.Constructor类中有一个可以用来创建对象的newInstance()函数方法。通过使用这个newInstance()方法我们也可以调用参数化构造函数和私有构造函数。 12Constructor&lt;employee&gt; constructor = Employee.class.getConstructor();Employee emp3 = constructor.newInstance(); 这些 newInstance()方法被认为是创建对象的反射手段。实际上，内部类的newInstance()方法使用构造函数类的 newInstance()方法。这就是为什么后者是首选并且使用不同的框架如Spring, Hibernate, Struts等。 4. 使用clone方法实际上无论何时我们调用clone()方法，Java 虚拟机都为我们创建了一个新的对象并且复制了之前对象的内容到这个新的对象中。使用 clone()方法创建对象不会调用任何构造函数。为了在对象中使用clone()方法，我们需要在其中实现可克隆类型并定义clone()方法。 1Employee emp4 = (Employee) emp3.clone(); 5. 使用反序列化无论何时我们对一个对象进行序列化和反序列化，JAVA虚拟机都会为我们创建一个单独的对象。在反序列化中，JAVA虚拟机不会使用任何构造函数来创建对象。对一个对象进行序列化需要我们在类中实现可序列化的接口。 12ObjectInputStream in = new ObjectInputStream(new FileInputStream("data.obj"));Employee emp5 = (Employee) in.readObject(); 正如我们在以上的字节代码片段中所看到的，除第一种被转换为一个新的函数和一个 invokespecial 指令以外，其它4种方法都被调用并转换为invokevirtual。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 注解]]></title>
    <url>%2F2015%2F02%2F09%2F2-Object-Oriented%2F9-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[注解带着问题去读！为什么写注解可以替代大量配置文件呢？ 什么是注解？在IDE中，我们可以链接SpringMVC中的@RequestMapping注解，发现以下源码 123456789101112@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(value = RetentionPolicy.RUNTIME) @Documented @Mappingpublic @interface RequestMapping &#123; public String[] value() default &#123;&#125;; public RequestMethod[] method() default &#123;&#125;; public String[] params() default &#123;&#125;; public String[] headers() default &#123;&#125;; public String[] consumes() default &#123;&#125;; public String[] produces() default &#123;&#125;; &#125; 这其实就是注解的写法。从这里我们可以发现，注解的写法比较简单，只要在interface前面加上@，就可以定义一个注解。但有几个其他的注解我们还不是很明白，同样spring是怎么通过这个注解进行运转的呢？ 注解的作用是什么？ 生成文档，比如我们用的ide里面会自动加上比如@param，@return，@author等注解。 编译时格式检查。这个最常见的是@override，@SuppressWarnings等等。 跟踪代码依赖性，实现替代配置文件功能。上面的源码例子其实就是这个作用。 元注解在包 Java.lang.annotation 中包含所有定义【自定义注解】所需用到的原注解和接口。如接口 java.lang.annotation.Annotation 是所有注解继承的接口,并且是自动继承，不需要定义时指定，类似于所有类都自动继承Object。查看Documented.class，可以看到这是个借口。它有三个注解（@Documented，@Retention，@Target），除此外，还有@Inherited，构成4个元注解。 1、@Documented将此注解包含在 javadoc 中 ，它代表着此注解会被javadoc工具提取成文档。在doc文档中的内容会因为此注解的信息内容不同而不同。相当与@see,@param 等。 2、@Retention表示在什么级别保存该注解信息。可选的参数值在枚举类型 RetentionPolicy 中，包括： RetentionPolicy.SOURCE 注解将被编译器丢弃 RetentionPolicy.CLASS 注解在class文件中可用，但会被VM丢弃 RetentionPolicy.RUNTIME VM将在运行期也保留注释，因此可以通过反射机制读取注解的信息。 3、@Target表示该注解用于什么地方，可能的值在枚举类 ElemenetType 中，包括： ElemenetType.CONSTRUCTOR 构造器声明 ElemenetType.FIELD 域声明（包括 enum 实例） ElemenetType.LOCAL_VARIABLE 局部变量声明 ElemenetType.ANNOTATION_TYPE 作用于注解量声明 ElemenetType.METHOD 方法声明 ElemenetType.PACKAGE 包声明 ElemenetType.PARAMETER 参数声明 ElemenetType.TYPE 类，接口（包括注解类型）或enum声明@Inherited 允许子类继承父类中的注解。 自定义注解12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package me.cuijing.test.anotation;/** * 自定义注解 * @author CuiJing * @date 2017/5/13 */@Documented@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface AnnotationTest &#123; public String name() default ""; public String sex() default "男";&#125;/** * 注解测试 * @author Cui */@AnnotationTest(sex = "男", name = "张飞")public class AnnotationTest &#123; @AnnotationTest(sex = "男", name = "Fly") public void setFly() &#123; &#125; @AnnotationTest(sex = "女", name = "李明") public void setLiMing() &#123; &#125; public static void main(String[] args) &#123; //检查类MyAnnotationTest是否含有@AnnotationTest注解 if (MyAnnotationTest.class.isAnnotationPresent(AnnotationTest.class)) &#123; //若存在就获取注解 AnnotationTest annotation = (AnnotationTest) MyAnnotationTest.class.getAnnotation(AnnotationTest.class); System.out.println(annotation); //获取注解属性 System.out.println(annotation.sex()); System.out.println(annotation.name()); System.out.println("///////////////////////////////////////////"); Method[] _methods = MyAnnotationTest.class.getDeclaredMethods(); for (Method method : _methods) &#123; System.out.println(method); if (method.isAnnotationPresent(AnnotationTest.class)) &#123; AnnotationTest test = method.getAnnotation(AnnotationTest.class); System.out.println("AnnotationTest(method=" + method.getName() + ",name=" + test.name() + ",sex=" + test.sex() + ")"); &#125; &#125; &#125; &#125;&#125; 测试结果如下： 123456789@test.AnnotationTest(sex=男, name=张飞)男张飞///////////////////////////////////////////public static void test.MyAnnotationTest.main(java.lang.String[])public void test.MyAnnotationTest.setLiMing()AnnotationTest(method=setLiMing,name=李明,sex=女)public void test.MyAnnotationTest.setFly()AnnotationTest(method=setFly,name=Fly,sex=男) 到这里，我们对注解的基本有点了解了，注解的运用其实与反射式分不开的。我们可以利用代码中的注解间接控制程序代码的运行，它们通过Java反射机制读取注解的信息，并根据这些信息更改目标程序的逻辑。但是我们怎么使用注解呢？怎么让注解发挥作用，例如spring等框架时如何应用注解的呢？ 注解理解的深入我们结合spring的控制反转和依赖注入来继续说明这个问题。 看下面的代码，首先是一个IUser接口，包含一个login方法。然后又一个中文登录方法和英文登录方法都实现了Iuser接口。 1234567891011121314151617public interface IUser &#123; public void login(); &#125; public class ChineseUserImpl implements IUser &#123; @Override public void login() &#123; System.err.println("用户登录！"); &#125; &#125; public class EnglishUserImpl implements IUser &#123; @Override public void login() &#123; System.err.println("User Login！"); &#125; &#125; 然后有一个Test类，要注入IUser接口 1234567891011121314151617@AnnotationTest public class Test &#123; private IUser userdao; public IUser getUserdao() &#123; return userdao; &#125; @AnnotationTest(nation = "ChineseUserImpl") public void setUserdao(IUser userdao) &#123; this.userdao = userdao; &#125; public void loginTest() &#123; userdao.login(); &#125; &#125; 我们实现的是setter注入方式。为了配合这个例子，我把@AnnotationTest也稍作修改。 123456@Documented @Target(&#123;ElementType.METHOD, ElementType.TYPE, ElementType.FIELD&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface AnnotationTest &#123; public String nation() default ""; &#125; 然后再引入一个类Container，类似spring容器的作用 1234567891011121314151617181920212223242526public class Container &#123; public static Test getBean() &#123; Test test = new Test(); if (Test.class.isAnnotationPresent(AnnotationTest.class)) &#123; Method[] methods = Test.class.getDeclaredMethods(); for (Method method : methods) &#123; System.out.println(method); if (method.isAnnotationPresent(AnnotationTest.class)) &#123; AnnotationTest annotest = method.getAnnotation(AnnotationTest.class); System.out.println("AnnotationTest(field=" + method.getName() + ",nation=" + annotest.nation() + ")"); IUser userdao; try &#123; userdao = (IUser) Class.forName("test." + annotest.nation()).newInstance(); test.setUserdao(userdao); &#125; catch (Exception ex) &#123; Logger.getLogger(Container.class.getName()).log(Level.SEVERE, null, ex); &#125; &#125; &#125; &#125; else &#123; System.out.println("没有注解标记！"); &#125; return test; &#125; &#125; 在容器里面我使用反射获取注解属性nation所标注的内容，然后对Test类中的接口进行具体实现。这里的Container就是所谓的外部容器，可以对我们的注解或者是xml配置文件进行解析，以降低耦合性。最后我们再进行测试，代码如下 1234567891011 /** * 注解测试 * * @author Fly */ public class MyAnnotationTest &#123; public static void main(String[] args) &#123; Test test = Container.getBean(); test.loginTest(); &#125; &#125; 测试结果如下： 12345public void test.Test.loginTest() public void test.Test.setUserdao(test.IUser) AnnotationTest(field=setUserdao,nation=ChineseUserDaoImpl) public test.IUser test.Test.getUserdao() 用户登录！ 如果我把Test类中的 1@AnnotationTest(nation = "ChineseUserImpl") 修改成 1@AnnotationTest(nation = "EnglishUserImpl") 结构就变成 12345public void test.Test.loginTest() public test.IUser test.Test.getUserdao() public void test.Test.setUserdao(test.IUser) AnnotationTest(field=setUserdao,nation=EnglishUserImpl) User Login！ 总结 所有的注解类都隐式继承于 java.lang.annotation.Annotation，注解不允许显式继承于其他的接口。 注解不能直接干扰程序代码的运行，无论增加或删除注解，代码都能够正常运行。Java语言解释器会忽略这些注解，而由第三方工具负责对注解进行处理。 一个注解可以拥有多个成员，成员声明和接口方法声明类似，这里，我们仅定义了一个成员，成员的声明有以下几点限制： 成员以无入参无抛出异常的方式声明，如boolean value(String str)、boolean value() throws Exception等方式是非法的； 可以通过default为成员指定一个默认值，如String level() default “LOW_LEVEL”、int high() default 2是合法的，当然也可以不指定默认值； 成员类型是受限的，合法的类型包括原始类型及其封装类、String、Class、enums、注解类型，以及上述类型的数组类型。如ForumService value()、List foo()是非法的。 如果注解只有一个成员，则成员名必须取名为value()，在使用时可以忽略成员名和赋值号（=），如@Description(“使用注解的实例”)。注解类拥有多个成员时，如果仅对value成员进行赋值则也可不使用赋值号，如果同时对多个成员进行赋值，则必须使用赋值号，如@DeclareParents (value = “NaiveWaiter”, defaultImpl = SmartSeller.class)。 注解类可以没有成员，没有成员的注解称为标识注解，解释程序以标识注解存在与否进行相应的处理；]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>注解</tag>
        <tag>annotation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 方法]]></title>
    <url>%2F2015%2F02%2F09%2F2-Object-Oriented%2F8-%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[枚举类基础1、如何自定义枚举类。是 JDK 1.5 中引入的新特性，存放在 java.lang 包中。 枚举类：类的对象是有限个的，确定的。 私有化类的构造器，保证不能在类的外部创建其对象 在类的内部创建枚举类的实例。声明为：public static final 若类有属性，那么属性声明为：private final 。此属性在构造器中赋值。 2、使用enum关键字定义枚举类 其中常用的方法：values() , valueOf(String name); 枚举类如何实现接口： 让类实现此接口，类的对象共享同一套接口的抽象方法的实现； 让类的每一个对象都去实现接口的抽象方法，进而通过类的对象调用被重写的抽象方法时，执行的效果不同。 3、枚举类和普通类的区别： 必须在枚举类的第一行声明枚举类对象,枚举列表必须写在最前面，否则编译出错； 使用 enum定义的枚举类默认继承了java.lang.Enum 类； 枚举类的构造器只能使用 private 访问控制符； 枚举类的所有实例必须在枚举类中显式列出( , 分隔 ; 结尾). 列出的实例系统会自动添加 public static final 修饰； JDK 1.5 中可以在 switch 表达式中使用Enum定义的枚举类的对象作为表达式, case 子句可以直接使用枚举值的。 4、实例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class TestSeason &#123; public static void main(String[] args) &#123; Season spring = Season SPRING; System.out.println(spring); spring.show(); System.out.println(spring.getSeasonName()); System.out.println(); //1.values() Season[] seasons = Season.values(); for(int i = 0;i &lt; seasons.length;i++)&#123; System.out.println(seasons[i]); &#125; //2.valueOf(String name):要求传入的形参name是枚举类对象的名字。 //否则，报java.lang.IllegalArgumentException异常 String str = "WINTER"; Season sea = Season.valueOf(str); System.out.println(sea); System.out.println(); Thread.State[] states = Thread.State.values(); for( int i = 0;i &lt; states.length;i++)&#123; System.out.println(states[i]); &#125; sea.show(); &#125;&#125;interface Info &#123; void show();&#125;//枚举类enum Season implements Info&#123; // 所有枚举值都是public static final的 SPRING("spring", "春暖花开")&#123; public void show()&#123; System.out.println( "春天在哪里？" ); &#125; &#125;, SUMMER("summer", "夏日炎炎")&#123; public void show()&#123; System.out.println( "生如夏花"); &#125; &#125;, AUTUMN("autumn", "秋高气爽")&#123; public void show()&#123; System.out.println( "秋天是用来分手的季节" ); &#125; &#125;, WINTER("winter", "白雪皑皑")&#123; public void show()&#123; System.out.println( "冬天里的一把火" ); &#125; &#125;; private final String seasonName; private final String seasonDesc; // 注意这里的构造函数是 private 私有的 private Season(String seasonName , String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; @Override public String toString() &#123; return "Season [seasonName=" + seasonName + ", seasonDesc=" + seasonDesc + "]"; &#125;// public void show()&#123;// System.out.println("这是一个季节");// &#125;&#125; 枚举类的使用1、原始的接口定义常量123456789public interface IConstants &#123; String MON = "Mon"; String TUE = "Tue"; String WED = "Wed"; String THU = "Thu"; String FRI = "Fri"; String SAT = "Sat"; String SUN = "Sun";&#125; 2、语法（定义）创建枚举类型要使用 enum 关键字，隐含了所创建的类型都是 java.lang.Enum 类的子类（java.lang.Enum 是一个抽象类）。枚举类型符合通用模式Class Enum&lt;E extends Enum&lt;E&gt;&gt;，而 E 表示枚举类型的名称。枚举类型的每一个值都将映射到protected Enum(String name, int ordinal) 构造函数中，在这里，每个值的名称都被转换成一个字符串，并且序数设置表示了此设置被创建的顺序。 123456789101112131415package com.hmw.test;/** * 枚举测试类 * @author */public enum EnumTest &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125;这段代码实际上调用了7次 Enum(String name, int ordinal)：new Enum&lt;EnumTest&gt;("MON",0);new Enum&lt;EnumTest&gt;("TUE",1);new Enum&lt;EnumTest&gt;("WED",2); ... ... 3、遍历、switch 等常用操作对enum进行遍历和switch的操作示例代码： 1234567891011121314151617181920212223public class Test &#123; public static void main(String[] args) &#123; for (EnumTest e : EnumTest.values()) &#123; System.out.println(e.toString()); &#125; System.out.println("-------我是分隔线---------"); EnumTest test = EnumTest.TUE; switch (test) &#123; case MON: System.out.println("今天是星期一"); break; case TUE: System.out.println("今天是星期二"); break; // ... ... default: System.out.println(test); break; &#125; &#125;&#125; 输出结果： 123456789MONTUEWEDTHUFRISATSUN----------------我是分隔线------------------今天是星期二 4、enum 对象的常用方法介绍1234567891011121314151617int compareTo(E o) 比较此枚举与指定对象的顺序。 Class&lt;E&gt; getDeclaringClass() 返回与此枚举常量的枚举类型相对应的 Class 对象。 String name() 返回此枚举常量的名称，在其枚举声明中对其进行声明。 int ordinal() 返回枚举常量的序数（它在枚举声明中的位置，其中初始常量序数为零）。 String toString() 返回枚举常量的名称，它包含在声明中。static &lt;T extends Enum&lt;T&gt;&gt; T valueOf(Class&lt;T&gt; enumType, String name) 返回带指定名称的指定枚举类型的枚举常量。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) &#123; EnumTest test = EnumTest.TUE; //compareTo(E o) int = (test-MON) switch (test.compareTo(EnumTest.MON)) &#123; case -1: System.out.println("TUE 在 MON 之前"); break; case 1: System.out.println("TUE 在 MON 之后"); break; default: System.out.println("TUE 与 MON 在同一位置"); break; &#125; //getDeclaringClass() : com.gplayo.eumn.EnumTest System.out.println("getDeclaringClass(): " + test.getDeclaringClass().getName()); //name() 和 toString() System.out.println("name(): " + test.name()); System.out.println("toString(): " + test.toString()); //ordinal()， 返回值是从 0 开始 System.out.println("ordinal(): " + test.ordinal()); &#125;&#125; 输出结果： 12345TUE 在 MON 之后getDeclaringClass(): com.gplayo.eumn.EnumTestname(): TUEtoString(): TUEordinal(): 1 5、给 enum 自定义属性和方法给 enum 对象加一下 value 的属性和 getValue() 的方法： 12345678910111213141516171819202122232425262728293031323334353637383940package com.hmw.test;/** * 枚举测试类 * * @author cui */public enum EnumTest &#123; MON(1), TUE(2), WED(3), THU(4), FRI(5), SAT(6) &#123; @Override public boolean isRest() &#123; return true; &#125; &#125;, SUN(0) &#123; @Override public boolean isRest() &#123; return true; &#125; &#125;; private int value; private EnumTest(int value) &#123; this.value = value; &#125; public int getValue() &#123; return value; &#125; public boolean isRest() &#123; return false; &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; System.out.println("EnumTest.FRI 的 value = " + EnumTest.FRI.getValue()); &#125;&#125; 输出结果： 1EnumTest.FRI 的 value = 5 6、EnumSet，EnumMap 的应用12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // EnumSet的使用 EnumSet&lt;EnumTest&gt; weekSet = EnumSet.allOf(EnumTest.class); for (EnumTest day : weekSet) &#123; System.out.println(day); &#125; // EnumMap的使用 EnumMap&lt;EnumTest, String&gt; weekMap = new EnumMap(EnumTest.class); weekMap.put(EnumTest.MON, "星期一"); weekMap.put(EnumTest.TUE, "星期二"); // ... ... for (Iterator&lt;Entry&lt;EnumTest, String&gt;&gt; iter = weekMap.entrySet().iterator(); iter.hasNext();) &#123; Entry&lt;EnumTest, String&gt; entry = iter.next(); System.out.println(entry.getKey().name() + ":" + entry.getValue()); &#125; &#125;&#125; 7、原理分析enum 的语法结构尽管和 class 的语法不一样，但是经过编译器编译之后产生的是一个class文件。该class文件经过反编译可以看到实际上是生成了一个类，该类继承了java.lang.Enum&lt;E&gt;。EnumTest 经过反编译(javap com.hmw.test.EnumTest 命令)之后得到的内容如下： 123456789101112131415public class com.hmw.test.EnumTest extends java.lang.Enum&#123; public static final com.hmw.test.EnumTest MON; public static final com.hmw.test.EnumTest TUE; public static final com.hmw.test.EnumTest WED; public static final com.hmw.test.EnumTest THU; public static final com.hmw.test.EnumTest FRI; public static final com.hmw.test.EnumTest SAT; public static final com.hmw.test.EnumTest SUN; static &#123;&#125;; public int getValue(); public boolean isRest(); public static com.hmw.test.EnumTest[] values(); public static com.hmw.test.EnumTest valueOf(java.lang.String); com.hmw.test.EnumTest(java.lang.String, int, int, com.hmw.test.EnumTest);&#125; 所以，实际上 enum 就是一个 class，只不过 Java 编译器帮我们做了语法的解析和编译而已。 8、小结可以把 enum 看成是一个普通的 class，它们都可以定义一些属性和方法，不同之处是：enum 不能使用 extends 关键字继承其他类，因为 enum 已经继承了 java.lang.Enum（java是单一继承）。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>枚举</tag>
        <tag>Enumeration</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 接口]]></title>
    <url>%2F2015%2F02%2F09%2F2-Object-Oriented%2F6-%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[接口（interface）是与类并行的一个概念 接口可以看做是一个特殊的抽象类。是常量与抽象方法的一个集合，不能包含变量、一般的方法； 接口是没有构造器的； 接口定义的就是一种功能。此功能可以被类所实现（implements）。比如：class CC extends DD implements AA,BB,CC； 实现接口的类，必须要重写其中的所有的抽象方法，方可实例化。若没有重写所有的抽象方法，则此类仍为一个抽象类； 类可以实现多个接口。—-java 中的类的继承是单继承的； 接口与接口之间也是继承的关系，而且可以实现多继承； 接口与具体的实现类之间也存在多态性； 面向接口编程的思想。 接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的， 另外，实现接口的一定要实现接口里定义的所有方法，而实现抽象类可以有选择地重写需要用到的方法，一般的应用里，最顶级的是接口，然后是抽象类实现接口，最后才到具体类实现。 还有，接口可以实现多重继承，而一个类只能继承一个超类，但可以通过继承多个接口实现多重继承，接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用. 接口的特点： 用interface来定义。 接口中的所有常量都默认是由public static final修饰的。 接口中的所有方法都默认是由public abstract修饰的。 接口没有构造器。 接口采用多继承机制。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.atguigu.java;//接口的应用：工厂方法的设计模式public class TestFactoryMethod &#123; public static void main(String[] args) &#123; IWorkFactory i = new StudentWorkFactory(); i.getWork().doWork(); IWorkFactory i1 = new TeacherWorkFactory(); i1.getWork().doWork(); &#125;&#125;interface IWorkFactory&#123; Work getWork();&#125;class StudentWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new StudentWork(); &#125; &#125;class TeacherWorkFactory implements IWorkFactory&#123; @Override public Work getWork() &#123; return new TeacherWork(); &#125;&#125;interface Work&#123; void doWork();&#125;class StudentWork implements Work&#123; @Override public void doWork() &#123; System.out.println( "学生写作业" ); &#125;&#125;class TeacherWork implements Work&#123; @Override public void doWork() &#123; System.out.println( "老师批改作业" ); &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>接口</tag>
        <tag>interface</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 类及对象]]></title>
    <url>%2F2015%2F02%2F08%2F2-Object-Oriented%2F1-%E7%B1%BB%E5%8F%8A%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象 vs 面向过程（了解） 123456789101112131415161718192021222324252627282930313233/* * 理解一：人开门 * 面向过程：人 打开 门 * 面向对象: * 人&#123; * 打开(门)&#123; * 门.开开(); * &#125; * &#125; * * 门&#123; * 开开()&#123; * &#125; * &#125; * * 理解二：人把大象装进冰箱 * 面向过程：1）打开冰箱2）把大象放进去 3)关闭冰箱门 * 面向对象： * 人&#123; * 打开(冰箱)&#123;冰箱.开开()&#125; * 操作(大象)&#123;大象.进入(冰箱)&#125; * 关闭(冰箱)&#123;冰箱.合上()&#125; * &#125; * * 大象&#123; * 进入(冰箱)&#123;&#125; * &#125; * 冰箱&#123; * 开开()&#123;&#125; * 合上()&#123;&#125; * &#125; * */ 面向对象的特点面向对象的特点答：面向对象有三大特点：封装、继承、多态。(如果要回答四个，可加上 抽象性 这一特点) 封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 多态性：多态性是指允许不同类的对象对同一消息作出不同地响应。多态性包括参数化多态性和子类多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 抽象：(了解)抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 类的设计 一个项目或工程，不管多庞大，一定是有一个一个类构成的。 类是抽象的，好比是制造汽车的图纸。 而具体的一辆一辆的车，是根据图纸制造的，实际上就是类的实例化 完成一个项目（或功能）的思路1）所要完成的功能对应的类的对象是否存在。2）若存在，则通过对象直接调用对应的类中的属性或方法即可3）若不存在，需要创建类的对象。甚至说，类都不存在，就需要设计类。 面向对象编程的三条主线：1）类及类的构成成分：属性 方法 构造器 代码块 内部类2）面向对象编程的特征：封装性 继承性 多态性 （抽象性）3）其它的关键字：this super package import static final abstract interface ... 类的组成成分：12345678910111213141516171819202122232425262728public class Person &#123; // 属性或成员变量 String name; boolean isMarried; // 构造器 public Person()&#123;&#125; public Person(String n , boolean im)&#123; name = n; isMarryed = im; &#125; // 方法或函数 public void walk()&#123; System.out.println("人走路..."); &#125; public String display()&#123; return "名字是：" +name+",Married："+isMarried; &#125; // 代码块 &#123; name = "Cui Jing"; age = "25"; isMarried = false; &#125; // 内部类 class pet()&#123; String name; int Weight; &#125; Java 类有五部分组成 属性（成员变量，Field） 构造方法（构造器，Constructor） 方法（成员方法，函数，Method） 代码块 内部类 属性:(成员变量，Field)成员变量 vs 局部变量 相同点： 遵循变量声明的格式： 数据类型 变量名 = 初始化值 都有作用域 不同点： 成员变量 局部变量 声明位置 类里，方法外 方法内，方法形参上，代码块内 权限修饰符 public private protected 缺省 没有显示修饰符 初始化值 不显式赋值会有默认值 必须有初始化值 内存位置 堆空间 栈空间 总结：关于变量的分类： 按照数据类型的不同：基本数据类型（8种） &amp; 引用数据类型 按照声明的位置的不同：成员变量 &amp; 局部变量 方法:(成员方法，Method)提供某种功能的实现 1234567891011格式：权限修饰符 返回值类型（void:无返回值/具体的返回值） 方法名 (形参) &#123; &#125;public void eat() &#123; //方法体&#125;public String getName()&#123; return null;&#125;public void setName(String n)&#123;&#125; 注意： 关于返回值类型：void：表明此方法不需要返回值 有返回值的方法：在方法的最后一定有return + 返回值类型对应的变量 方法内可以调用本类的其他方法或属性，但是不能在方法内再定义方法！ 构造器: (构造方法，constructor) 设计类时，若不显式声明类的构造器的话， 程序会默认提供一个空参的构造器. 一旦显式的定义类的构造器，那么默认的构造器就不再提供。 如何声明类的构造器。 格式：权限修饰符 类名(形参){ } 类的多个构造器之间构成重载。 构造器的特征： 它具有与类相同的名称 它不声明返回值类型。（与声明为void不同） 不能被static、final、synchronized、abstract、native修饰，不能有return语句返回值 构造器的作用： 创建对象 给创建的对象的属性赋值 类对象的属性赋值的先后顺序： 属性的默认初始化 属性的显式初始化 通过构造器给属性初始化 通过”对象.方法”的方式给属性赋值 代码块代码块：是类的第4个成员，用来初始化类的属性，如果有修饰符的话，只能用static来修饰。 用static修饰的-静态代码块： 里面可以有输出语句 随着类的加载而加载，而且只被加载一次 一个类中可以有多个静态的代码块 多个静态代码块之间按照顺序结构执行 静态代码块的执行要早于非静态代码块的执行。 静态的代码块中只能执行静态的结构(类属性，类方法) 没用static修饰-非静态代码块： 可以对类的属性(静态的 &amp; 非静态的)进行初始化操作，同时也可以调用本类声明的方法(静态的 &amp; 非静态的) 里面可以有输出语句 一个类中可以有多个非静态的代码块，多个代码块之间按照顺序结构执行 每创建一个类的对象，非静态代码块就加载一次。 非静态代码块的执行要早于构造器 关于属性赋值的操作的顺序 （越来越晚）①默认的初始化②显式的初始化或代码块初始化(此处两个结构按照顺序执行)③构造器初始化；——————以上是对象的属性初始化的过————————④通过方法对对象的相应属性进行修改 内部类]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 面向对象的特性]]></title>
    <url>%2F2015%2F02%2F08%2F2-Object-Oriented%2F3-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%A3%85%E6%80%A7%2F</url>
    <content type="text"><![CDATA[一、封装性1、面向对象的特征一：封装与隐藏 问题：当创建了类的对象以后，如果直接通过”对象.属性”的方式对相应的对象属性赋值的话，可能会出现不满足实际情况的意外，我们考虑不让对象来直接作用属性，而是通过”对象.方法”的形式，来控制对象对属性的访问。实际情况中，对属性的要求就可以通过方法来体现。 2、面向对象思想的落地法则二：（封装性的思想）①将类的属性私有化，②提供公共的方法（setter &amp; getter）来实现调用。 3、四种权限修饰符 权限从大到小为：public protected 缺省 private 四种权限都可以用来修饰 属性、方法、构造器 修饰类的话：public &amp; 缺省 二、继承性1、为什么要有继承性：多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。此处的多个类称为子类，单独的这个类称为父类（基类或超类）。可以理解为:“子类is a 父类” 继承的出现提高了代码的复用性 继承的出现让类与类之间产生了关系，提供了多态的前提 不要仅为了获取其他类中某个功能而去继承 2、声明格式通过 class A extends B 类实现类的继承。子类：A父类或基类SuperClass：B 3、继承父类中声明的属性、方法，子类就可以获取到。子类除了通过继承，获取父类的结构之外，还可以定义自己的特有的成分。 extends：子类是对父类功能的“扩展”，明确子类不是父类的子集。关于继承的规则：子类不能直接访问父类中私有的(private)的成员变量和方法。Java中类的单继承：一个类只能继承一个父类。反之，一个父类可以有多个子类。子类和父类：是相对的概念。 问题：修改了父类后，父类会重新编译，子类也会重新编译吗？答案：是。 三、多态性什么是多态 ？： 面向对象的三大特性：封装、继承、多态。从一定角度来看，封装和继承几乎都是为多态而准备的。这是我们最后一个概念，也是最重要的知识点。 多态的定义：指允许不同类的对象对同一消息做出响应。即同一消息可以根据发送对象的不同而采用多种不同的行为方式。（发送消息就是函数调用） 实现多态的技术称为：动态绑定（dynamic binding），是指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。 多态的作用：消除类型之间的耦合关系。 现实中，关于多态的例子不胜枚举。比方说按下 F1 键这个动作，如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；如果当前在 Word 下弹出的就是 Word 帮助；在 Windows 下弹出的就是 Windows 帮助和支持。同一个事件发生在不同的对象上会产生不同的结果。 多态存在的三个必要条件 （重要）： 要有继承； 要有重写； 父类引用指向子类对象。 格式：123456Person p = new Man();//向上转型// 虚拟方法调用：通过父类的引用指向子类的对象实体，// 当调用方法时，实际执行的是子类重写父类的方法p1.eat();p1.walk();// p1.entertainment(); 动态绑定：编译时，认为p是Person类型的，故只能执行Person里才有的结构，即Man里特有的结构不能够调用。 对于多态性来说，编译时，”看左边”，将此引用变量理解为父类的类型；运行时，”看右边”，关注于真正对象的实体，子类的对象，那么执行的方法就是子类重写的。 子类对象的多态性，并不适用于属性。 关于向下转型： 向下转型,使用强转符：() 为了保证不报ClassCastException，最好在向下转型前，进行 instanceof 判断。 12345678910// 若a是A类的实例，那么a也一定是A类的父类的实例。if (p1 instanceof Woman) &#123; Woman w1 = (Woman) p1; w1.shopping();&#125;if (p1 instanceof Man) &#123; Man m1 = (Man) p1; m1.entertainment();&#125; 若出现父类的引用指向子类的对象实体 1Person p = new Man(); // 向上转型 当调用方法时，先查看父类是否也有这个方法，有的话，实际执行的是子类重写父类的方法。 1Person p = new Person(); // 一般情况 一般情况继承类的情况 ， 若子类没有这个方法，而父类有此方法，则执行父类中的方法。 多态的好处： 可替换性（substitutability）。多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。 可扩充性（extensibility）。多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。 接口性（interface-ability）。多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。如图8.3 所示。图中超类Shape规定了两个实现多态的接口方法，computeArea()以及computeVolume()。子类，如Circle和Sphere为了实现多态，完善或者覆盖这两个接口方法。 灵活性（flexibility）。它在应用中体现了灵活多样的操作，提高了使用效率。 简化性（simplicity）。多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。 测试题：题 112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 学习完 Java 面向对象的特性后你会做这一题吗？package test;class A &#123; public String show(D obj)&#123; return ( "A and D"); &#125; public String show(A obj)&#123; return ( "A and A"); &#125;&#125;class B extends A&#123; public String show(B obj)&#123; return ( "B and B"); &#125; public String show(A obj)&#123; return ( "B and A"); &#125;&#125;class C extends B &#123;&#125;class D extends B &#123;&#125;public class TestA &#123; public static void main(String[] args) &#123; A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System. out.println(a1.show(b)); //1 System. out.println(a1.show(c)); //2 System. out.println(a1.show(d)); //3 System. out.println(a2.show(b)); //4 System. out.println(a2.show(c)); //5 System. out.println(a2.show(d)); //6 System. out.println(b.show(b)); //7 System. out.println(b.show(c)); //8 System. out.println(b.show(d)); //9 &#125;&#125; 答案① A and A② A and A③ A and D④ B and A⑤ B and A⑥ A and D⑦ B and B⑧ B and B⑨ A and D1.实例对象为A，参数为对象B，B为A的子类。执行A.class中show(A obj)2.同上3.实例对象为A，参数为对象D，执行A.class中show(D obj)4.实例对象依然为A，参数为B，本应执行A.class中show(A obj)，但是，B.class重写了show(A obj),所以执行B.class show(A obj)5.同上6.执行A.class show(D obj) B中并没有重写。7，8.实例对象为B，参数为B或者B的子类，执行show(B obj)9.实例对象为B，参数为D，因为B继承自A，优先可以执行A中的show(D obj) 题 21234567891011121314151617181920212223package me.cuijing.test.inherit;/** * @author CuiJing * @date 2017/5/9 */public class PolymorphismTest2 &#123; public static void main(String[] args) &#123; Person p = new Student(); System.out.println(p.age); System.out.println(p.name); &#125;&#125;class Person &#123; String name = "人类"; int age = 12;&#125;class Student extends Person &#123; String name = "学生";&#125; 输出： 1212人类 因为 Person p = new Son(); 就是把子类转型为父类 子类转型为父类的规则： 只能调用父类的属性 只能调用父类未被复重写的方法 只能调用被子类复写的方法 属性（变量）是静态绑定方法（函数）是动态绑定 静态绑定就是变量本身什么类型，就用哪个里面的。例如，你的p.name的p是Person类型，那么name就是Person类中的name。 如果是动态绑定，那么会从本身类型开始向超类型查找。如果name是方法，那么用于p是Son类的一个对象，所以会从Son开始找name方法，如果找不到再到父类中找。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 关键字]]></title>
    <url>%2F2015%2F02%2F08%2F2-Object-Oriented%2F4-%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[package: 声明源文件所在的包，写在程序的第一行。 每.一次，表示一层文件目录。 包名都要小写。 import: 显式导入指定包下的类或接口 写在包的声明和源文件之间 如果需要引入多个类或接口，那么就并列写出 如果导入的类是java.lang包下的，如：System String Math等，就不需要显式的声明 理解 .* 的概念。比如java.util.* 如何处理同名类的导入。如：在util包和sql包下同时存在Date类 import static 静态导入: 表示导入指定类的static的属性或方法 导入java.lang.*只能导入lang包下的所有类或接口，不能导入lang的子包下的类或接口 123456789101112131415161718192021//import java.util.Scanner;//import java.util.Date;//import java.util.List;//import java.util.ArrayList;import java.lang.reflect.Field;import java.util.*;import static java.lang.System.*;public class TestPackageImport &#123; public static void main(String[] args) &#123; out.println("helloworld"); Scanner s = new Scanner(System.in); s.next(); Date d = new Date(); List list = new ArrayList(); java.sql.Date d1 = new java.sql.Date(522535114234L); Field f = null; &#125;&#125; this : 使用在类中，可以用来修饰属性、方法、构造器 表示当前对象或者是当前正在创建的对象 当形参与成员变量重名时，如果在方法内部需要使用成员变量，必须添加this来表明该变量时类成员 在任意方法内，如果使用当前类的成员变量或成员方法可以在其前面添加this，增强程序的阅读性 在构造器中使用this(形参列表)显式的调用本类中重载的其它的构造器 注意： 要求“this(形参列表)”要声明在构造器的首行！ 类中若存在n个构造器，那么最多有n-1构造器中使用了this。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class TestPerson &#123; public static void main(String[] args) &#123; Person p1 = new Person(); System.out.println(p1.getName() + ":" + p1.getAge()); Person p2 = new Person("BB",23); int temp = p2.compare(p1); System.out.println(temp); &#125;&#125;class Person&#123; private String name; private int age; public Person()&#123; this.name = "AA"; this.age = 1; &#125; public Person(String name)&#123; this(); this.name = name; &#125; public Person(String name,int age)&#123; this(name); this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public void eat()&#123; System.out.println("eating"); &#125; public void sleep()&#123; System.out.println("sleeping"); this.eat(); &#125; //比较当前对象与形参的对象的age谁大。 public int compare(Person p)&#123; if(this.age &gt; p.age) return 1; else if(this.age &lt; p.age) return -1; else return 0; &#125;&#125; super :相较于关键字 this，可以修饰属性、方法、构造器在Java类中使用super来调用父类中的指定操作： super 可用于访问父类中定义的属性， super 可用于调用父类中定义的成员方法 super 可用于在子类构造方法中调用父类的构造器 super 修饰属性、方法：在子类的方法、构造器中，通过super.属性或者super.方法的形式，显式的调用父类的指定属性或方法。尤其是，当子类与父类有同名的属性、或方法时，调用父类中的结构的话，一定要用super.。 super 调用父类构造器通过 super(形参列表) 显式的在子类的构造器中，调用父类指定的构造器！ 任何一个类（除Object类）的构造器的首行，要么显式的调用本类中重载的其它的构造器 this(形参列表) 或显式的调用父类中，指定的构造器 super(形参列表) ，要么默认的调用父类空参的构造器 super() 。 建议在设计类时，提供一个空参的构造器！ 子类中所有的构造器默认都会访问父类中空参数的构造器 当父类中没有空参数的构造器时，子类的构造器必须通过 this(参数列表) 或者 super(参数列表) 语句，指定调用本类或者父类中相应的构造器，且必须放在构造器的第一行 如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有无参的构造器，则编译出错 this 和 super 的区别 static :static: 静态的，可以用来修饰属性、方法、代码块、内部类。 修饰属性（类变量）: 由类创建的所有的对象，都共用这一个属性； 当其中一个对象对此属性进行修改，会导致其他对象对此属性的一个调用； 类变量随着类的加载而加载的，而且独一份； 静态的变量可以直接通过类.类变量的形式来调用； 类变量的加载是要早于对象。所以当有对象以后，可以对象.类变量使用。但是类.实例变量是不行的； 类变量存在于静态域中。 修饰方法（类方法）: 随着类的加载而加载，在内存中也是独一份; 可以直接通过 类.类方法 的方式调用 内部可以调用静态的属性或静态的方法，而不能调用非静态的属性或方法。反之，非静态的方法是可以调用静态的属性或静态的方法 静态的方法内是不可以有this或super关键字的！ 注：静态的结构(static的属性、方法、代码块、内部类)的生命周期要早于非静态的结构，同时被回收（与当前类同时被回收）也要晚于非静态的结构。 final :final: 最终的、绝育的，可以用来修饰类、属性、方法。 修饰类：这个类就不能被继承。如：String类、StringBuffer类、System类 修饰方法：不能被重写。如：Object类的getClass() 修饰属性：此属性就是一个常量，一旦初始化后，不可再被赋值。习惯上，常量用大写字符表示。 此常量在哪里赋值：①此常量不能使用默认初始化 ，必须至少显示初始化②可以显式的赋值、在代码块里赋值、在构造器里赋值。 变量用static final修饰：全局常量。比如：Math 类的PI 与finally 、finalize()区分开 abstractabstract：抽象的，可以用来修饰类、方法；不能用来修饰属性、构造器、private、final、static。 修饰类：抽象类 类不可被实例化； 抽象类有构造器 (凡是类都有构造器)； 抽象方法所在的类，一定是抽象类； 抽象类中可以没有抽象方法。 当我们设计一个类，不需要创建此类的实例时候，就可以考虑将其设置为抽象的，由其子类实现这个类的抽象方法以后，就可以实例化。 修饰方法：抽象方法 格式：没有方法体，包括{}.如：public abstract void eat(); 抽象方法只保留方法的功能，而具体的执行，交给继承抽象类的子类，由子类重写此抽象方法。 若子类继承抽象类，并重写了所有的抽象方法，则此类是一个”实体类”,即可以实例化 若子类继承抽象类，没有重写所有的抽象方法，意味着此类中仍有抽象方法，则此类必须声明为抽象的！ 注意 抽象类可以有非抽象方法吗？可以； 抽象类可以有静态方法吗？当然可以； 抽象类可以有属性，有构造器；]]></content>
      <tags>
        <tag>Java</tag>
        <tag>关键字</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本数据类型包装类]]></title>
    <url>%2F2015%2F02%2F08%2F2-Object-Oriented%2F5-%E5%8C%85%E8%A3%85%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[基本数据类型由于不是类，不能够使用java类库里提供的大量的方法。所有在设计上，我们让每一个基本数据类型都对应一个类，同时数据存储的范围还不变。此时相当于基本数据类型就具有了类的特点。 这些类即为包装类（wrapper 或封装类）。 基本数据类型 相应包装类型 boolean Boolean byte Byte short Short int Integer long Long char Char float Float double Double 基本类型、包装类、String之间的转换1、基本数据类型与对应的包装类有自动装箱、自动拆箱如： 123int i = 10;Integer i1 = i; //自动装箱int j = i1; //自动拆箱 2、基本数据类型、包装类 &lt;==&gt; String类：基本类型 –&gt; String 调用 String类的重载的 valueOf(Xxx xx); String –&gt; 基本类型、包装类：调用相应的包装的parseXxx(String str) 注意: 12String str = "123";int i = (int)str;是错误的转法。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>包装类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 方法]]></title>
    <url>%2F2015%2F02%2F08%2F2-Object-Oriented%2F2-%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[方法的重载（overload） 要求： 同一个类 方法名必须相同 必须具有不同的参数列表； 可以有不同的返回类型，只要参数列表不同就可以了； 可以有不同的访问修饰符； 可以抛出不同的异常； 12345678910111213141516171819202122232425262728293031323334353637 public class TestOverload &#123; &#125; class OverLoad&#123; //定义两个int型变量的和 public int getSum( int i, int j)&#123; return i + j; &#125; //定义三个int型变量的和 public int getSum( int i, int j, int k)&#123; return i + j + k; &#125; //不能与其它几个方法构成重载 // public int getSum1( int i, int j,int k)&#123;// return i + j + k; // &#125; // public void getSum( int i, int j,int k)&#123;// System.out.println(i + j + k); // &#125; //定义两个double型数据的和 public double getSum( double d1, double d2)&#123; return d1 + d2; &#125; //定义三个double型数组的和 public void getSum( double d1, double d2, double d3)&#123; System.out.println(d1 + d2 + d3); &#125; //以下的两个方法构成重载。 public void method1( int i,String str)&#123; &#125; public void method1(String str1, int j)&#123; &#125; &#125; 方法的重写（override overwrite）定义：在子类中可以根据需要对从父类中继承来的方法进行改造，也称方法的重置、覆盖。在程序执行时，子类的方法将覆盖父类的方法。 要求： 重写方法必须和被重写方法具有相同的方法名称、参数列表和返回值类型。 重写方法不能使用比被重写方法更严格的访问权限 重写和被重写的方法须同时为static的，或同时为非static的 子类方法抛出的异常不能大于父类被重写方法的异常 方法的重载与重写的区别？重载：“两同一不同”： 同一个类 同一个方法名 不同的参数列表 注：方法的重载与返回值无关 构造器是可以重载的 重写:（前提：在继承的基础之上，子类在获取了父类的结构以后，可以对父类中的方法进行“重构”） 方法的返回值，方法名，形参列表形同； 权限修饰符不小于父类的同名方法； 子类方法的异常类型不大于父类的； 两个方法要同为static或同为非static。 可变个数形参的方法： 格式：对于方法的形参： 数据类型 … 形参名 可变个数的形参的方法与同名的方法之间构成重载 可变个数的形参在调用时，个数从0开始，到无穷多个都可以。 使用可变多个形参的方法与方法的形参使用数组是一致的。 若方法中存在可变个数的形参，那么一定要声明在方法形参的最后。 在一个方法中，最多声明一个可变个数的形参。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class TestArgs &#123; public static void main(String[] args) &#123; TestArgs t = new TestArgs(); t.sayHello(); //t.sayHello(new String[]&#123;"hello China","hello BeiJing"&#125;); t.sayHello( "hello China","hello BeiJing" ); &#125; //如下四个方法构成重载//在类中一旦定义了重载的可变个数的形参的方法以后，如下的两个方法可以省略// public void sayHello()&#123;// System.out.println("hello world!");// &#125;// public void sayHello(String str1)&#123;// System.out.println("hello " + str1);// &#125; //可变个数的形参的方法 public void sayHello(String ... args)&#123; for( int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i] + "$"); &#125; //System.out.println("====="); &#125; public void sayHello(int i,String ... args)&#123; //public void sayHello(String ... args, int i)&#123; System.out.println(i); for( int j = 0;j &lt; args.length;j++)&#123; System.out.println(args[j] + "$"); &#125; &#125; public void sayHello1(String[] args)&#123; for( int i = 0;i &lt; args.length;i++)&#123; System.out.println(args[i]); &#125; &#125; //可变个数形参的使用的例子// public int getSum(int i, int j)&#123;// return i + j;// &#125;// public int getSum(int i, int j,int k)&#123;// return i + j + k;// &#125; public int getSum(int ... args)&#123; int sum = 0; for( int i = 0;i &lt; args.length;i++)&#123; sum += args[i]; &#125; return sum; &#125; &#125; 方法的参数传递（重点、难点）1、形参与实参 形参：方法声明时，方法小括号内的参数 实参：调用方法时，实际传入的参数的值 2、Java中的参数传递机制：值传递机制 形参是基本数据类型的：将实参的值传递给形参的基本数据类型的变量 形参是引用数据类型的：将实参的引用类型变量的值（对应的堆空间的对象实体的首地址值）传递给形参的引用类型变量。 从程序运行的角度来看，参数传递，只有传值，从不传递其它的东西。只不过值的内容有可能是数据，也有可能是一个内存地址 Java中的数据类型有两大类，即基本类型(primitive types), 共有8种，包括int, short, long, byte, float, double, boolean, char， 存在于栈（Stack）中。另一种暂称为对象类型，包括Integer, String, Double等相应基本数据类型的包装类，以及其他所有 Java 自带和用户自定义的类,这些类数据全部存在于堆中（Heap）。 Heap( 堆) Stack( 栈) JVM 中的功能 存储数据 内存指令区 存储 对象实例 基本数据类型 , 指令代码, 常量 , 对象引用地址 123456789101112@Testpublic void Test5() &#123; int i = 1; System.out.println( "Before test: i = " + i); changeValue(i); System.out.println( "After test: i = " + i);&#125;public static void changeValue(int i) &#123; i = 2; System.out.println( "during test: i = " + i);&#125; 运行结果： 123Before test: i = 1during test: i = 2After test: i = 1 不难看出，虽然在 changeValue(int i) 方法中改变了传进来的参数的值，但对这个参数源变量本身并没有影响。其内部原理是，main 方法里的变量和 changeValue() 方法的参数是两个不同的变量，以参数形式传递简单类型的变量时，实际上是将参数的值作了一个拷贝传进方法的，那么在方法里再怎么改变其值，其结果都是只改变了拷贝的值，而不是源值。 12345678910@Testpublic void test6() &#123; StringBuffer string = new StringBuffer("Hello"); test6(string); System.out.println(string);&#125;public void test6(StringBuffer str) &#123; str.append(", World!");&#125; 运行结果： 1Hello, World! 在这个例子里，似乎变量string被“改变”了。但其实改变的并不是string变量本身，也就是说string保存的内存地址并没有被改变，改变的是它所指向的对象实例。内部原理是这样的，在main方法里定义了一个对象引用string，并且把它和一个对象实例关联new StringBuffer。方法调用的时候，string所保存的对象实例的内存地址传递给了test方法的对象引用参数str，这时就有两个对象引用变量指向同一个对象实例。这两个对象引用都可以对该对象实例进行操作，操作结果都有效，因此在test方法执行完之后，对象实例的内容已经被改变了，这个时候再通过main方法里的string引用去查看对象实例的内容，看到的就是改变之后的内容。 1234567891011@Testpublic void test7() &#123; String string = "Hello"; test7(string); System. out.println(string);&#125;public void test7(String str) &#123; str = "World"; //将str 原先的地址改为 world 字符的地址,对原地址没有任何影响&#125; 运行结果： 1Hello 这个结果和上面结果矛盾吗？一点也不矛盾。在这个例子中，参数传递过程和上个例子完全一样，但是在test()方法里并不是对原来指向的对象实例进行操作，而是把str指向了另外一个对象实例，当然对原来的对象实例毫无影响。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 关键字与标识符]]></title>
    <url>%2F2015%2F02%2F06%2F1-Java-Base%2F1-Java-keyword-and-identifier%2F</url>
    <content type="text"><![CDATA[关键字关键字：被Java语言赋予了特殊含义，用做专门用途的字符串（单词）1234567891011关键字列表abstract boolean break byte case catch char class continue default do double else extends enum false final finally float forif implements import instanceof intinterface long native new nullpackage private protected public returnshort static super switch synchronizedthis throw throws transient truetry void volatile while Java 中 true false不是关键字，而是 boolean 类型的字面量。但也不能当作变量用。所有的关键字都是小写，friendly sizeof 不是 java 的关键字 。 保留字保留字：指在高级语言中已经定义过的字，使用者不能再将这些字作为变量名或过程名使用。保留字：const goto 这两个已经削去意义，但同样不能用作变量名。 标识符标识符：用来给一个类、变量或方法命名的符号（凡是自己可以起名字的地方都叫标识符） 标识符的命名规则：（一定要遵守，不遵守就会报编译的错误） 由26个英文字母大小写，0-9 , 或者下划线”_“和”$”开头，数字不可以开头。 Java中严格区分大小写， 不可以使用关键字和保留字，但能包含关键字和保留字。 Java中长度无限制。 标识符不能包含空格。 Java中的名称命名规范：（不遵守，也不会出现编译的错误） 包名： 多单词组成时所有字母都小写：xxxyyyzzz 类名、接口名： 多单词组成时，所有单词的首字母大写：XxxYyyZzz 变量名、方法名： 多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz 常量名： 所有字母都大写。多单词时下划线连接：XXX_YYY_ZZZ 建议使用JavaBeans规则命名，并根据方法的目的，以 set、get、is、add 或 remove 开头。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>关键字</tag>
        <tag>标识符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常注意事项]]></title>
    <url>%2F2015%2F02%2F06%2F3-Exception%2F2-%E5%BC%82%E5%B8%B8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[Java中如何处理异常在Java中进行异常处理的话，对于可能会发生异常的代码，可以选择三种方法来进行异常处理： 对代码块用try..catch进行异常捕获处理； 在该代码的方法体外用throws进行抛出声明，告知此方法的调用者这段代码可能会出现这些异常，你需要谨慎处理。此时有两种情况：如果声明抛出的异常是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。如果声明抛出的异常是运行时异常，此方法的调用者可以选择地进行异常捕获处理。 在代码块用throw手动抛出一个异常对象，此时也有两种情况，跟 2 中的类似：如果抛出的异常对象是非运行时异常，此方法的调用者必须显示地用try..catch块进行捕获或者继续向上层抛出异常。如果抛出的异常对象是运行时异常，此方法的调用者可以选择地进行异常捕获处理。 如果最终将异常抛给main方法，则相当于交给JVM自动处理，此时JVM会简单地打印异常信息 深刻理解try,catch,finallytry关键字用来包围可能会出现异常的逻辑代码，它单独无法使用，必须配合catch或者finally使用。Java编译器允许的组合使用形式只有以下三种形式： try…catch…; try….finally……; try….catch…finally… 当然catch块可以有多个，注意try块只能有一个,finally块是可选的（但是最多只能有一个finally块）。 三个块执行的顺序为try—&gt;catch—&gt;finally。 当然如果没有发生异常，则catch块不会执行。但是finally块无论在什么情况下都是会执行的（这点要非常注意，因此部分情况下，都会将释放资源的操作放在finally块中进行）。在有多个catch块的时候，是按照catch块的先后顺序进行匹配的，一旦异常类型被一个catch块匹配，则不会与后面的catch块进行匹配。 在使用try..catch..finally块的时候，注意千万不要在finally块中使用return，因为finally中的return会覆盖已有的返回值。下面看一个例子： 12345678910111213141516171819202122232425262728import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.IOException;public class TestFinally1 &#123; public static void main(String[] args) &#123; String str = new TestFinally1().openFile(); System. out.println(str); &#125; public String openFile() &#123; try &#123; FileInputStream inputStream = new FileInputStream(&quot;d:/a.txt&quot; ); int ch = inputStream.read(); System.out.println( &quot;aaa&quot;); return &quot;step1&quot;; &#125;catch (FileNotFoundException e) &#123; System.out.println( &quot;file not found&quot;); return &quot;step2&quot;; &#125;catch (IOException e) &#123; System.out.println( &quot;io exception&quot;); return &quot;step3&quot;; &#125;finally&#123; System.out.println(&quot;finally block&quot; ); //return &quot;finally&quot;; &#125; &#125;&#125; 这段程序的输出结果为： 123file not foundfinally blockstep2 可以看出，在try块中发生FileNotFoundException之后，就跳到第一个catch块，打印”file not found”信息，并将”step2”赋值给返回值，然后执行finally块，最后将返回值返回。从这个例子说明，无论try块或者catch块中是否包含return语句，都会执行finally块。如果将这个程序稍微修改一下，将finally块中的return语句注释去掉，运行结果是： 123file not foundfinally blockfinally 最后打印出的是”finally”，返回值被重新覆盖了。因此如果方法有返回值，切忌不要再finally中使用return，这样会使得程序结构变得混乱。 异常处理和设计的几个建议以下是根据前人总结的一些异常处理的建议 1、只在必要使用异常的地方才使用异常只在必要使用异常的地方才使用异常，不要用异常去控制程序的流程。谨慎地使用异常，异常捕获的代价非常高昂，异常使用过多会严重影响程序的性能。如果在程序中能够用if语句和Boolean变量来进行逻辑判断，那么尽量减少异常的使用，从而避免不必要的异常捕获和处理。 比如下面这段经典的程序： 123456789101112131415public void useExceptionsForFlowControl() &#123; try &#123; while (true) &#123; increaseCount(); &#125; &#125; catch (MaximumCountReachedException ex) &#123; &#125; //Continue execution &#125; public void increaseCount() throws MaximumCountReachedException &#123; if (count &gt;= 5000) throw new MaximumCountReachedException(); &#125; 上边的useExceptionsForFlowControl()用一个无限循环来增加count直到抛出异常，这种做法并没有说让代码不易读，而是使得程序执行效率降低。 2、切忌使用空catch块在捕获了异常之后什么都不做，相当于忽略了这个异常。千万不要使用空的catch块，空的catch块意味着你在程序中隐藏了错误和异常，并且很可能导致程序出现不可控的执行结果。如果你非常肯定捕获到的异常不会以任何方式对程序造成影响，最好用Log日志将该异常进行记录，以便日后方便更新和维护。 3、检查异常和非检查异常的选择一旦你决定抛出异常，你就要决定抛出什么异常。这里面的主要问题就是抛出检查异常还是非检查异常。 检查异常导致了太多的try…catch代码，可能有很多检查异常对开发人员来说是无法合理地进行处理的，比如SQLException，而开发人员却不得不去进行try…catch，这样就会导致经常出现这样一种情况：逻辑代码只有很少的几行，而进行异常捕获和处理的代码却有很多行。这样不仅导致逻辑代码阅读起来晦涩难懂，而且降低了程序的性能。 建议尽量避免检查异常的使用，如果确实该异常情况的出现很普遍，需要提醒调用者注意处理的话，就使用检查异常；否则使用非检查异常。 因此，在一般情况下，我觉得尽量将检查异常转变为非检查异常交给上层处理。 4、注意catch块的顺序不要把上层类的异常放在最前面的catch块。比如下面这段代码： 123456789101112131415try &#123; FileInputStream inputStream = new FileInputStream( &quot;d:/a.txt&quot;); int ch = inputStream.read(); System.out.println(&quot;aaa&quot;); return &quot;step1&quot;;&#125; catch (IOException e ) &#123; System.out.println(&quot;io exception&quot;); return &quot;step2&quot;;&#125;catch (FileNotFoundException e) &#123; System.out.println(&quot;file not found&quot;); return &quot;step3&quot;;&#125;finally&#123; System.out.println(&quot;finally block&quot;); //return &quot;finally&quot;;&#125; 第二个catch的FileNotFoundException将永远不会被捕获到，因为FileNotFoundException是IOException的子类。 5、不要将提供给用户看的信息放在异常信息里比如下面这段代码： 123456789101112131415try &#123; FileInputStream inputStream = new FileInputStream( &quot;d:/a.txt&quot;); int ch = inputStream.read(); System.out.println(&quot;aaa&quot;); return &quot;step1&quot;;&#125; catch (IOException e ) &#123; System.out.println(&quot;io exception&quot;); return &quot;step2&quot;; &#125;catch (FileNotFoundException e) &#123; System.out.println(&quot;file not found&quot;); return &quot;step3&quot;;&#125;finally&#123; System.out.println(&quot;finally block&quot;); //return &quot;finally&quot;;&#125; 展示给用户错误提示信息最好不要跟程序混淆一起，比较好的方式是将所有错误提示信息放在一个配置文件中统一管理。 6、避免多次在日志信息中记录同一个异常只在异常最开始发生的地方进行日志信息记录。很多情况下异常都是层层向上跑出的，如果在每次向上抛出的时候，都Log到日志系统中，则会导致无从查找异常发生的根源。 7、异常处理尽量放在高层进行尽量将异常统一抛给上层调用者，由上层调用者统一之时如何进行处理。如果在每个出现异常的地方都直接进行处理，会导致程序异常处理流程混乱，不利于后期维护和异常错误排查。由上层统一进行处理会使得整个程序的流程清晰易懂。 8、在finally中释放资源如果有使用文件读取、网络操作以及数据库操作等，记得在finally中释放资源。这样不仅会使得程序占用更少的资源，也会避免不必要的由于资源未释放而发生的异常情况。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>异常</tag>
        <tag>Exception</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 变量]]></title>
    <url>%2F2015%2F02%2F06%2F1-Java-Base%2F5-Java-Array%2F</url>
    <content type="text"><![CDATA[数组：相同数据类型的数据的组合。如： 123int score1 = 72;int score2 = 90;int score3 = 59; 数组一旦初始化，其长度是不可变的。 一维数组1、数组的初始化12345678910111213141516171819//静态初始化：在声明并初始化数组与给数组相应的元素赋值操作同时进行。int[] scores1 = new int[]&#123;72,90,59&#125;; //动态初始化：在声明并初始化数组与给数组相应的元素赋值操作分开进行。// int[] scores2 = new int[3]; 也对int scores2[] = new int[3]; scores2[0] = 72;scores2[1] = 90;scores2[2] = 59;//声明数组的错误写法：// 1、静态初始化就不要声明数组长度了String[] names = new String[5]&#123;"AA","BB","CC"&#125;; //2、数组不可以用基本数据类型的方式初始化int i[10]; //3、少了[]int i = new int[]; 注：不管是动态还是静态初始化数组，一定在创建的时候，就指明了数组的长度！ 2、如何引用数组元素：通过数组的下角标的方式。下角标从0开始，到n-1结束。其中n为数组的长度。 123System.out.println(scores2[0]); // 72System.out.println(scores2[1]); // 90System.out.println(scores2[2]); // 59 3、数组的长度：通过数组的属性length来调用。 1System.out.println(scores2.length);//3 4、如何遍历数组123456789// 手动System.out.println(scores2[0]);System.out.println(scores2[1]);System.out.println(scores2[2]);// 循环打印for(int i = 0;i &lt; scores2;i++)&#123; System.out.println(scores2[i]);&#125; 5、关于数组元素的默认初始化值 byte short int long 而言：0 float double 而言：0.0 char而言：空格 boolean而言：false 引用类型变量而言String :null 6、数组的内存结构 二维数组1、声明并初始化123456789101112131415//二维数组的初始化scores2 = new int [][]&#123;&#123;1,2,3&#125;,&#123;3,4,5&#125;,&#123;6&#125;&#125;;//静态初始化 names = new String[6][5];//动态初始化的方式一names = new String[6][]; //动态初始化的方式二names[0] = new String[5];names[1] = new String[4];names[2] = new String[7];names[3] = new String[5];names[4] = new String[8];names[5] = new String[5]; //错误的初始化方式//names = new String[][];//names = new String[][5]; 2、如何引用二维数组的元素：1234567int[][] i = new int[3][2]; //int [] i[] = new int[3][2];i[0][0] = 60;i[0][1] = 50;i[1][0] = 40;i[1][1] = 90;i[2][0] = 99;i[2][1] = 100; 3、二维数组的长度：12345678//二维数组的长度：length属性System.out.println(i.length );//3//二维数组中元素的长度System.out.println(i[0].length );//2System.out.println(names.length );//6System.out.println(names[4].length );//8System.out.println(); 4、遍历二维数组123456for(int i = 0;i &lt; arr.length;i++)&#123; for(int j = 0;j &lt; arr[i].length;j++)&#123; System.out.print(arr[i][j] + "\t"); &#125; System.out.println();&#125; 5、二维数组的结构： 数组常见异常1、下标越界: java.lang.ArrayIndexOutOfBoundsException1234567int[] i = new int[10];i[0] = 90;i[10] = 99;for(int m = 0;m &lt;= i.length;m++)&#123; System.out.println(i[m]);&#125; 2、空指针：NullPointerException123456789101112//第一种：boolean[] b = new boolean[3];b = null;System.out.println(b[0]); //第二种：String[] str = new String[4];System.out.println( str[3].toString());// null的对象来调方法也会出现此异常 //第三种：int[][] j = new int[3][];j[2][0] = 12; // j[2][] 是空数组,出现此异常]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 变量]]></title>
    <url>%2F2015%2F02%2F06%2F1-Java-Base%2F4-Java-Flow-control%2F</url>
    <content type="text"><![CDATA[分支结构： 条件判断:1234567891011121314151617181920// ①if(条件表达式)&#123; &#125;// ②if(条件表达式)&#123; //执行的语句1；&#125;else&#123; //执行的语句2；&#125;// ③if(条件表达式1)&#123; //执行的语句1；&#125;else if(条件表达式2)&#123; //执行的语句2；&#125;else if( 条件表达式3)&#123; //执行的语句3；&#125;else&#123; //执行的语句4；&#125; 一旦满足某个条件表达式，则进入其执行语句块执行，执行完毕，跳出当前的条件判断结构，不会执行其以下的条件结构语句。 如果诸多个条件表达式之间为“互斥”关系，多个结构可以上下调换顺序，如果诸多个条件表达式之间为“包含”关系，要求条件表达式范围小的写在范围大的上面。 说明：如果if-else if-else条件的执行语句块{}只有一条语句的话，那么这一对{}可以省略。建议：不要省略{} 选择结构123456switch(变量)&#123; case 值1: //break; case 值2: //break; ... default: break;&#125; 变量可以为如下的数据类型：byte short int char 枚举 (Java1.7及以后支持字符串)String case后只能填写变量的值，不能写范围。 default是可以省略的。若，没有以上case ，则默认执行此行代码，并且其位置也是灵活的，但是通常将其放在case语句之后。 一旦满足某个case语句，则进入执行其操作。直至遇到break或者程序终止。 若要判断的语句的条件满足switch变量的数据类型，且值不多的情况下，建议选择switch-case，除此之外，选择if-else。 代码示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import java.util.Scanner;/*对学生成绩大于60分的，输出“合格”。低于60分的，输出“不合格”。说明：1.当多个case语句处理的语句块一致时，可以统一来书写2.一定情况下switch-case与if-else之间可以相互转换。*/class TestSwitch2 &#123; public static void main(String[] args)&#123; System. out.println("请输入一个学生的成绩：" ); Scanner s = new Scanner(System.in); int score = s.nextInt(); if(score &gt;= 60)&#123; System. out.println("及格" ); &#125; else&#123; System. out.println("不及格" ); &#125; /* switch(score)&#123; case 100: ... case 0: default: &#125; */ switch(score / 10)&#123; case 10: case 9: case 8: case 7: case 6: System. out.println("及格" ); break; case 5: case 4: case 3: case 2: case 1: case 0: System. out.println("不及格" ); break; default: System. out.println("输入有误" ); break; &#125; &#125;&#125;//从键盘分别输入年、月、日，判断这一天是当年的第几天import java.util.Scanner;class TestYearMonthDay&#123; public static void main(String[] args) &#123; Scanner s = new Scanner(System.in); System.out.println("请输入年份：" ); int year = s.nextInt(); System.out.println("请输入月份：" ); int month = s.nextInt(); System.out.println("请输入日期：" ); int day = s.nextInt(); int sum = 0;//用来记录year年month月day日是year年第几天 //使用switch-case switch(month)&#123; case 12: sum += 30; //30:十一月份的总天数 case 11: sum += 31; case 10: sum += 30; case 9: sum += 31; case 8: sum += 31; case 7: sum += 30; case 6: sum += 31; case 5: sum += 30; case 4: sum += 31; case 3: if((year % 4 == 0 &amp;&amp; year % 100 != 0) || year % 400 == 0)&#123; sum += 29; &#125; else&#123; sum += 28; &#125; case 2: sum += 31; //31:是一月份的天数 case 1: sum += day; &#125; System. out.println(sum); &#125;&#125; 循环结构循环控制格式： 1234567891011121314151617181920212223242526272829303132//①初始化条件//②循环条件//③迭代部分//④循环体//执行顺序 1243 243 243 243 ...for(①;②;③)&#123;④&#125;//执行顺序 1243 243 243 243 ...①while(②)&#123;④③&#125;//执行顺序 1432 432 432 432 ...①do&#123;④③&#125;while(②);/**注：1. 不同的循环结构之间可以相互转换2. while和do-while的区别：do-while程序至少会执行一次3. 嵌套循环：循环结构还可以声明循环。让内层循环结构整体充当外层循环的循环体。若外层循环执行m次，内层循环执行n次，整个程序执行m*n次。*/ 无限循环控制123456789101112131415for( ;; )&#123; ... if( )&#123; break; &#125; ...&#125;//或者while(true)&#123; ... if( )&#123; break; &#125; ...&#125; 往往我们在无限循环结构内部提供循环的终止条件，使用break关键字。否则，此循环将无限制的执行下去，形成死循环！死循环是我们要避免的。 break 与 continuebreak: 使用switch-case结构或者循环结构中在循环结构中，一旦执行到break，就跳出当前循环。 continue:使用在循环结构中 一旦执行到continue，就跳出当次循环。 12345678910111213141516171819202122for(int i = 1;i &lt;= 10;i++)&#123; if(i % 4 == 0)&#123; //break; //123 continue; //123567910 &#125; System.out.print(i);&#125;//在嵌套循环中，使用带标签的break和continue。label:for( int i = 1;i &lt; 5;i++)&#123; for(int j = 1;j &lt;= 10;j++)&#123; if(j % 4 == 0)&#123; //break; //continue; //break label; 意思是跳出i循环，所有的循环结束 continue label; //意思是跳出j循环，开始i循环 &#125; System.out.print(j); &#125; System.out.println();&#125; 练习123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121/**1、打印以下三行******************说明：外层循环控制行数，内层循环控制列数for(int i = 0;i &lt; 3;i++)&#123; for(int j = 0;j &lt; 6;j++)&#123; System.out.print("*"); &#125; System.out.println();&#125;*/class TestJiuJiu&#123; public static void main(String[] args) &#123; for(int i = 1;i &lt;= 9;i++)&#123;//一共有9行 for(int j = 1;j &lt;= i;j++)&#123;//每行有i个等式 System. out.print(i + "*" + j + "=" + i*j + "\t"); &#125; System. out.println(); &#125; &#125;&#125;/**2、九九乘法表 3、输出100内的质数。（两种）/*1 * 1 = 12 * 1 = 2 2 * 2 = 4...9 * 1 = 9 .... 9 * 9 = 81*/public class TestPrintNumber2 &#123; public static void main(String[] args)&#123; //boolean flag = false; long start = System.currentTimeMillis(); //获取系统当前的毫秒数 l: for(int i = 2;i &lt;= 100;i++)&#123;//实现100以内的自然数的遍历 //如何判断i是否为一个质数 for(int j = 2;j &lt;= Math.sqrt (i);j++)&#123; if(i % j == 0)&#123; //flag = true; //break; continue l; &#125; &#125; //if(!flag)&#123;//if(flag == false)&#123; System. out.println(i); //&#125; //flag = false; &#125; long end = System.currentTimeMillis(); System. out.println("所花费的时间为：" + (end - start)); //35535--加上break：10059--使用Math.sqrt(): System. out.println(Big.isPrime(88)); &#125;&#125;/*问题一：从键盘读入个数为10个的整数，并判断读入的正数和负数的个数。问题二：从键盘读入个数不确定的整数，并判断读入的正数和负数的个数，输入为0时结束程序。*/import java.util.Scanner;class TestExer&#123; public static void main(String[] args)&#123; Scanner s = new Scanner(System.in); int a = 0;//记录正数的个数 int b = 0;//记录负数的个数 //for(;;)&#123; while(true )&#123; System. out.println("请输入一个整数：" ); int num = s.nextInt(); if(num &gt; 0) a++; else if (num &lt; 0) b++; else break; &#125; /* 问题一： for( int i = 0;i &lt; 10;i++)&#123; System.out.println("请输入第" + (i + 1) + "个整数"); int num = s.nextInt(); if( num &gt; 0) a++; else if( num &lt; 0) b++; &#125; */ System. out.println("正数的个数为：" + a); System. out.println("负数的个数为：" + b); &#125;&#125;//求调和级数中从第多少项开始值大于10，调和级数的第n项形式为：1+1/2+1/3+…+1/n@Testpublic void test3()&#123; double sum = 0; for ( int i = 1 ;;i++)&#123; sum += 1.0 / i; if (sum &gt; 10)&#123; System.out.println( "调和级数中从第" + i +"项开始值大于10" ); break; &#125; &#125;&#125;/**若sum是int型,i是int型，在做1/i的时候会做整数除法得到0（1除以大于1的数都得0）并且得到的结果加到sum后还是取整，完全得不到小数位。因此sum要声明为double型sum = sum+1/i;要改为sum = sum+1.0/i;if 后面到break; 要用大括号括起来*/]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>流程控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 运算符]]></title>
    <url>%2F2015%2F02%2F06%2F1-Java-Base%2F3-Java-operator%2F</url>
    <content type="text"><![CDATA[运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等。 算术运算符：+ - + - * / % ++ -- +注意： / : int i = 12; i = i / 5; %：最后的符号只跟被模数相同 前++：先+1，后参与运算 后++：先参与运算，后+1 +：String字符串与其他数据类型只能做连接运算，且结果为String类型。 1234567891011121314151617181920212223242526// + 在 String 字符串只能拼接字符 ， 但在 char : ' ' 请看下例System.out.println('*' + '\t' + '*'); // 93System.out.println("*" + '\t' + '*'); // * * //取模：%：取余数. 结果的符号取决于被模数int i1 = 12 % 5;int i2 = -12 % 5;int i3 = 12 % (-5);int i4 = -12 % (-5);System.out.println(i1); //2System.out.println(i2); //-2System.out.println(i3); //2System.out.println(i4); //-2 // 后++：先以此时的值参加运算，即i++还是原来的值，但是i的值加了1// ++前：先以此时的值自增1，即i的值加了1，再参加运算int myInt1 = 10;int myInt2 = myInt1++; //后++System.out.println(myInt1); //11System.out.println(myInt2); //10int myInt3 = 10;int myInt4 = ++myInt3; //前++System.out.println(myInt3); //11System.out.println(myInt4); //11 赋值运算符： = += -= *= /= %=1234567891011121314151617181920212223242526272829int i= 12；i = i * 5;i *= 5; //与上一行代码同样的意思// 特别地int i1 = 10;i1 += 3; //i1 = i1 + 3;short s = 10;//s = s + 3;编译不通过s = ( short )(s + 1);//不建议如此实现s += 1; //既可以实现运算，又不会更改s的数据类型。int i2 = 12;i2 %= 5; //i2 = i2 % 5; System.out.println(i1);System.out.println(s);System.out.println(i2); //2boolean b1 = false ;// 区分好 == 和 = 的区别。if( b1 = true ) System.out.println("结果为真" );else System.out.println("结果为假" );int i = 1;i *= 0.1;System.out.println(i); //0 比较运算符 == &gt; &lt; &gt;= &lt;= instanceof区分 == 与 = 区别。进行比较运算操作以后，返回一个boolean类型的值，即结果要么是true，要么是false。 123456789101112// 表达的是4 &gt; 3或者 4 = 3 结果是trueif(4 &gt;= 3)&#123; System.out.println("true"); &#125; // 不能写为：if(1 &lt; i &lt; 10)&#123; &#125;if(i &gt; 1 &amp;&amp; i &lt; 10)&#123; &#125; // instanceof if("Hello" instanceof String )&#123; System.out.println("字符串 Hello 是 String 对象"); &#125; 逻辑运算符 &amp; &amp;&amp; | || ^ !运算符的两端是boolean值区分 &amp; 与 &amp;&amp; 的区别，以及 | 与 || 的区别我们使用的时候，强烈建议选择&amp;&amp; ， || 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class TestLogic&#123; public static void main(String[] args)&#123; boolean a = true ; boolean b = false ; System.out.println(a &amp; b); // 逻辑与 false System.out.println(a &amp;&amp; b); // 短路或 false System.out.println(a | b); // 逻辑或 true System.out.println(a || b); // 短路或 true System.out.println(a &amp; !b); // 逻辑非 true System.out.println(a ^ b); // 逻辑异或 (同 false 异 true) //&amp; 与 &amp;&amp; 的区别：&amp;:不管左边是true还是false，右端都会进行运算。 //&amp;&amp;:当左端为false时，右端不再进行运算 //以后使用时，建议使用 &amp;&amp; int i1 = 10; if(b &amp; (i1++) &gt; 0)&#123; System.out.println("今天天气很晴朗" ); &#125; else&#123; System.out.println("难得没有雾霾" ); &#125; System.out.println(i1);//11 int i2 = 10; if(b &amp;&amp; (i2++) &gt; 0)&#123; System.out.println("今天天气很晴朗" ); &#125; else&#123; System.out.println("难得没有雾霾" ); &#125; System.out.println(i2);//10 // | 与 || 的区别：|：当左端为true时，右端照样做运算。 // ||:当左端为true时，右端不再进行运算。 //我们在使用时，选择：|| int i3 = 10; if(a | i3++ &gt; 0)&#123; System. out.println("今天天气很晴朗" ); &#125; else&#123; System. out.println("难得没有雾霾" ); &#125; System. out.println(i3);//11 int i4 = 10; if(a || i4++ &gt; 0)&#123; System. out.println("今天天气很晴朗" ); &#125; else&#123; System. out.println("难得没有雾霾" ); &#125; System. out.println(i4);//10 &#125;&#125; 位运算符 &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ~在进行位运算时，Java 会将数值转换为二进制，然后进行运算。 1234int a = 13;int b = 12;a &lt;&lt; 2 // a * 4 1101变成 110100 b &gt;&gt; 2 // a / 4 1101变成 11 三元运算符 条件 ? 表达式1 : 表达式2; 既然是运算符，一定会返回一个结果，并且结果的数据类型与表达式1，2的类型一致 表达式1与表达式2 的数据类型一致。 使用三元运算符的，一定可以转换为if-else。反之不一定成立。 例子：获取两个数的较大值；获取三个数的最大值。​123456789101112131415161718int i = 21;int j = 23;// max记录了i与j的较大值int max = (i &gt; j)? i : j;// String str = (i &gt; j)? "i大" : "j大";String str = (i &gt; j)? "i大" : (i == j)? "相等" : "j大";// String str1 = (i &gt; j)? i : "j大";System. out.println(max);System. out.println(str);// 互换if(i &gt;= j)&#123; System. out.println("较大值为：" + i);&#125; else&#123; System. out.println("较大值为：" + j);&#125; 运算符的优先级运算符有不同的优先级，所谓优先级就是表达式运算中的运算顺序。如下表，上一行运算符总优先于下一行。只有单目运算符、三元运算符、赋值运算符是从右向左运算的。 习题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// 1、写出输出的结果.// 考查运算符的优先级class Demo&#123; public static void main(String[] args)&#123; int x=0,y=1; if(++x == y-- &amp; x++ == 1||--y==0) System.out.println("x=" +x+",y="+y); //x = 2,y = 0; else System.out.println("y=" +y+",x="+x); &#125;&#125;// ----------------------------------------------------// 2、交换两个数// int n = 5,m = 13;// 插入代码，实现n和m值的交换System.out.println("n="+n+ ",m="+m);int n = 5,m = 13;//int temp = n;//n = m;//m = temp;System.out.println("n="+n+ ",m="+m);//n = n + m;//m = n - m;//n = n - m;System.out.println("n="+n+ ",m="+m);n = n ^ m;m = n ^ m ;n = n ^ m;System.out.println("n="+n+ ",m="+m);// ----------------------------------------------------// 3、手动实现整型数值60的二进制到十六进制的转换String str1 = Integer.toBinaryString(60);String str2 = Integer.toHexString(60);int i1 = 60;int i2 = i1&amp;15;String j = (i2 &gt; 9)? ( char)(i2 -10 + 'A')+"" : i2+ "";int temp = i1 &gt;&gt;&gt; 4;i2 = temp &amp; 15;String k = (i2 &gt; 9)? ( char)(i2 -10 + 'A')+"" : i2+ "";System.out.println(k+""+j);// ----------------------------------------------------// 4、写出输出结果。class Demo&#123; public static void main(String[ ] args) &#123; int a=3,b=8; int c=(a&gt;b)?a++:b++; System.out.println( "a="+a+"\tb=" +b+"\tc="+c); // int d=(a&gt;b)?++a:++b; System.out.println( "a="+a+"\tb=" +b+"\td="+d); // int e=(a&lt;b)?a++:b++; System.out.println( "a="+a+"\tb=" +b+"\te="+e); // int f=(a&lt;b)?++a:++b; System.out.println( "a="+a+"\tb=" +b+"\tf="+f); // &#125;&#125; short s1 = 1; s1 = s1 + 1; 有什么错?short s1 = 1; s1 += 1;有什么错 答：short s1 = 1; s1 = s1 + 1;（s1+1运算结果是int型，需要强制转换类型）short s1 = 1; s1 += 1;（可以正确编译） Java有没有goto 答：java中的保留字，现在没有在java中使用 用最有效率的方法算出2乘以8等於几 答：2 &lt;&lt; 3 char型变量中能不能存贮一个中文汉字?为什么? 答：是能够定义成为一个中文的，因为java中以unicode编码，一个char占16个字节，所以放一个中文是没问题的 float型float f=3.4是否正确? 答:不正确。精度不准确,应该用强制类型转换，如下所示：float f=(float)3.4 String是最基本的数据类型吗 答：基本数据类型包括byte、int、char、long、float、double、boolean和short。java.lang.String类是final类型的，因此不可以继承这个类、不能修改这个类。为了提高效率节省空间，我们应该用StringBuffer类]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>运算符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 变量]]></title>
    <url>%2F2015%2F02%2F06%2F1-Java-Base%2F2-Java-variable%2F</url>
    <content type="text"><![CDATA[变量的概述通常，根据内存地址可以找到这块内存空间的位置，也就找到了存储的数据。但是内存地址非常不好记，因此，我们给这块空间起一个别名，通过使用别名找到对应空间存储的数据。变量是一个数据存储空间的表示。通过变量名可以简单快速地找到它存储的数据。变量是存储数据的一个基本单元，不同的变量相互独立。按照用法 可分为 基本数据类型 和 引用数据类型。 基本数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的内存栈上的，数据本身的值就是存储在栈空间里面，而Java语言里面八种数据类型是这种存储模型； 引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java内存堆和内存栈来进行这种类型的数据存储，简单地讲，“引用”是存储在有序的内存栈上的，而对象本身的值存储在内存堆上的； 区别:基本数据类型和引用类型的区别主要在于基本数据类型是分配在栈上的，而引用类型是分配在堆上的（需要理解java中的栈、堆概念）。 - 基本数据类型（8种） 类型 占用空间 表值范围 说明 默认值 bolean 1字节=8bit false；true 不能取null false char 2字节 0 ~ 2^16 - 1 2^16 = 65536 为空 byte 1字节 - 2^7~ 2^7 - 1 两byte相加，变 int 0 short 2字节 - 2^15 ~ 2^15 - 1 2^15 = 32768 0 int 4字节 - 2^31 ~ 2^31 - 1 约20亿,10位有效数字 0 long 8字节 - 2^63 ~ 2^63 - 1 约900亿亿,20位有效数字 0 float 4字节 9位有效数字 小数算，正负号不算 0.0 double 8字节 18位有效数字 同 float 0.0 12345678910注：1、java中所有的数据类所占据的字节数量与平台无关，java也没有任何无符号类型2、float 和 double 的小数部分不可能精确，只能近似。比较小数时，用 double i=0.01; if ( i - 0.01 &lt; 1E-6) ... // 不能直接 if (i==0.01)... 3、float 与 double 的区别在于float类型有效小数点只有6~7位 ， double 有15~16位。 补充：按照在类中存在的位置的不同：成员变量 vs 局部变量 - 引用数据类型（类、接口、数组）Java 中除去基本数据类型以外的数据类型都是引用数据类型，包括我们自己创建的类。 Java中什么叫做引用数据类型？引用：就是按内存地址查询比如：Object o = new Object(); 这个其实是在栈内存里分配一块内存空间为o，在堆内存里 new 了一个Object 类型的空间，在运行时是栈内存里的 o 指向堆内存里的那一块存储空间。 引用类型变量是以间接方式去获取数据。引用类型变量都属于对象类型，如：数组、类、字符串等都属于引用类型变量。所以，引用类型变量里面存放的是数据的地址。说白了基本数据类型变量就像是直接放在柜子里的东西，而引用数据类型变量就是这个柜子对应编码的钥匙。钥匙号和柜子对应。 进制（了解） 进制 缩写 英文 说明 十进制 D Decimal 0-9 ；满10进1 二进制 B binaries 0,1 ；满2进1，以0b或0B开头 八进制 O octal 0-7 ，满8进1， 以数字0开头 十六进制 H Hexagon 0-9及A-F(a-f)，满16进1,以0x或0X开头。 二进制：计算机底层都是用二进制来存储、运算。 二进制 与十进制之间的转换。二进制在底层存储：正数、负数都是以补码的形式存储的。四种进制间的转换 ？？？ 变量的数据类型转换自动类型转换：容量小的类型自动转换为容量大的类型。 12short s = 12;int i = s + 2; 注意：byte short char之间做运算，结果为int型！ 强制类型转换：是自动类型转换的逆过程，使用 “( )” 实现强转，会丢失精度或者出现异常。 123456int a = 32767;int b = 32768;short s1 = (short) a; short s2 = (short) b; System.out.println(s1); // 32767System.out.println(s2); // -32768 实例测试类1234567891011121314151617181920212223242526272829303132333435363738394041424344class TestVeriable &#123; public static void main(String[] args) &#123; // 1.变量得先定义后使用 int myInt1 = 10; double d = 12.3; System.out.println(myInt1); System.out.println(myInt1 + d); // i1 超出了其作用的范围，不可使用。 // System.out.println(i1); // 2.整型：byte(-128~+127) short int（默认类型） long byte b1 = 12; //byte b2 = 128; short s1 = 128; int i1 = 12; // 定义long型变量，值的末尾加“L”或“l” long l1 = 2134123351345325L; System.out.println(l1); // 3.浮点型（带小数点的数值）：double 是默认类型 float double d1 = 12.3; //声明float类型的浮点型数据，末尾要加“F”或者“f” float f1 = 12.3F; System.out.println(f1); // 4.字符型（两个字节）： // char 只能表示一个字符(英文、中文、标点符号、日文、。。。) char c1 = 'a'; //char c2 = ' ab'; String str = "ab"; char c3 = '中'; String str1 = "中国"; // 可以表示转义字符 char c4 = '\t'; char c5 = '\n' ; System.out.println("abc" + c5 + "def"); // 了解 char c6 = '\u1234' ; //unicode值 == ？ System.out.println(c6); //char 类型是可以运算的，因为它都对应有Unicode值 // 5.布尔类型：boolean 只能够取值为true 或 false 。不能取值null boolean bool1 = true; if(bool1) System.out.println("哈哈！周末不上班 ); &#125;&#125; 变量间的运算两个数相运算时，默认是 int 类型如果有更高级的，就按高级的那个类型 if(其中一个是double型)double型； else if(其中一个是float型)float型； else if(其中一个是long型)long型； else int 型。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*变量之间的运算：(不考虑boolean ：char byte short int long float double)1.自动类型转换2.强制类型转换*/class TestVeriable&#123; public static void main(String[] args)&#123; // 1.自动类型转换:当容量小的数据类型与容量大的数据类型做运算时， // 容量小的会自动转换为容量大的数据类型: // char,byte,short ===&gt; int ===&gt;long ===&gt;float===double int i1 = 12; short s1 = 2; int i2 = i1 + s1; float f1 = 12.3F; float f2 = f1 + i2; //float d1 = f2 + 12.3; long l = 12L; float f3 = l; System.out.println(i2); System.out.println(f2); char c1 = 'a' ;//97 c1 = 'A';//65 int i3 = c1 + 1; System.out.println(i3); //需要注意的：当char\byte\short之间做运算时，默认的结果为 int类型 short ss1 = 12; byte bb1 = 1; char cc1 = 'a' ; //short ss2 = ss1 + bb1; int ii1 = ss1 + bb1; //char cc2 = cc1 + bb1; int ii2 = cc1 + bb1; short ss2 = 11; //short ss3 = ss1 + ss2; //2.强制类型转换：容量大转换为容量小的.要使用强制类型转换符：() //强制类型转换的问题：导致精度的损失 long l1 = 12345L; int m1 = (int)l1; System.out.println(m1); byte by1 = (byte)m1; System.out.println(by1); //平时常用的字符串,也是一种数据类型：String String nation = "我是一个中国人" ; System.out.println(nation); //字符串与基本数据类型之间的运算:只能是连接运算：+。得到的结果仍为一个字符串 String str = "abc"; String str1 = str + m1; //abc12345 System.out.println(str1); //题目： String st1 = "hello"; int myInt1 = 12; char ch1 = 'a' ;//97 System.out.println(str1 + myInt1 + ch1); // hello12a System.out.println(myInt1 + ch1 + str1); // 109hello System.out.println(ch1 + str1 + myInt1); // ahello12 String st2 = "12"; st2 = 12 + ""; &#125;&#125;]]></content>
      <tags>
        <tag>Java</tag>
        <tag>基础</tag>
        <tag>变量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 内部类]]></title>
    <url>%2F2015%2F02%2F06%2F2-Object-Oriented%2F10-%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[内部类类的第5个成员：内部类 定义 相当于说，我们可以在类的内部再定义类。外面的类：外部类。里面定义的类：内部类； 内部类的分类：成员内部类（声明在类内部且方法外的）；局部内部类（声明在类的方法里）。 Java内部类总结1、在方法间定义的非静态内部类： 外围类和内部类可互相访问自己的私有成员； 内部类中不能定义静态成员变量； 在外部类作用范围之外向要创建内部类对象必须先创建其外部类对象； 非静态内部类对象有着指向其外部类对象的引用。 2、在方法间定义的静态内部类： 只能访问外部类的静态成员； 静态内部类没有指向外部的引用。 3、在方法中定义的局部内部类： 该内部类没有任何的访问控制权限； 可以有构造函数； 外围类看不见方法中的局部内部类的，但是局部内部类可以访问外围类的任何成员； 方法体中可以访问局部内部类，但是访问语句必须在定义局部内部类之后； 只能访问方法体中的常量，即用final修饰的成员。 4、在方法中定义的匿名内部类： 没有构造器，取而代之的是将构造器参数传递给超类构造器； 当你只需要创建一个类的对象而且用不上它的名字时，使用匿名内部类可以使代码看上去简洁清楚； 只能访问方法体中的常量，即用final修饰的成员。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package me.cuijing.test;public class TestInnerClass &#123; public static void main(String[] args) &#123; //创建静态内部类的对象：可以直接通过外部类调用静态内部类的构造器 Person.Dog d = new Person.Dog();//Person.new Dog(); //Person.Bird b = new Person.Bird(); //创建非静态的内部类的对象：必须先创建外部类的对象，通过外部类的对象调用内部类的构造器 Person p = new Person(); Person.Bird b = p. new Bird(); //new p.Bird(); b.info(); b.setName( "DuJuan"); &#125;&#125; class Person&#123; String name = "CuiJing"; int age; //成员内部类(非static的) class Bird&#123; String name = "XiQue"; int id; public Bird()&#123; &#125; public void setName(String name)&#123; System.out.println(name); System.out.println(this.name); System.out.println(Person.this.name); &#125; public void info()&#123; show(); &#125; &#125; //成员内部类(静态内部类) static class Dog&#123; &#125; public void show()&#123; System.out.println( "我是show()方法" ); &#125; public void method1()&#123; class A&#123; &#125; &#125;&#125; 例子1、实现隐藏平时我们对类的访问权限，都是通过类前面的访问修饰符来限制的，一般的非内部类，是不允许有 private 与protected权限的，但内部类可以，所以我们能通过内部类来隐藏我们的信息。可以看下面的例子 123456789101112131415161718192021222324252627282930313233// 接口package insidecategory;public interface Incrementable&#123; void increment();&#125;//具体类package insidecategory;public class Example &#123; private class InsideClass implements InterfaceTest &#123; public void test() &#123; System.out.println("这是一个测试"); &#125; &#125; public InterfaceTest getIn() &#123; return new InsideClass(); &#125;&#125;// 客户端程序package insidecategory;public class TestExample &#123; public static void main(String args[]) &#123; Example a = new Example(); InterfaceTest a1= a.getIn(); a1.test(); &#125;&#125; 从这段代码里面我只知道Example的getIn()方法能返回一个InterfaceTest 实例但我并不知道这个实例是这么实现的。而且由于InsideClass 是private的，所以我们如果不看代码的话根本看不到这个具体类的名字，所以说它可以很好的实现隐藏。 2、可以无条件地访问外围类的所有元素123456789101112131415161718package insidecategory;public class TagBean &#123; private String name="CuiJing"; private class InTest &#123; public InTest() &#123; System.out.println(name); &#125; &#125; public void test() &#123; new InTest(); &#125; public static void main(String args[]) &#123; TagBean bb = new TagBean(); bb.test(); &#125;&#125; name这个变量是在TagBean里面定义的私有变量。这个变量在内部类中可以无条件地访问System.out.println(name); 3、可以实现多重继承这个特点非常重要，个人认为它是内部类存在的最大理由之一。正是由于他的存在使得Java的继承机制更加完善。大家都知道Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。大家看下面的例子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344类一package insidecategory; public class Example1 &#123; public String name() &#123; return "CuiJing"; &#125;&#125;类二package insidecategory; public class Example2 &#123; public int age() &#123; return 25; &#125;&#125;类三package insidecategory;public class MainExample &#123; private class test1 extends Example1 &#123; public String name() &#123; return super.name(); &#125; &#125; private class test2 extends Example2 &#123; public int age() &#123; return super.age(); &#125; &#125; public String name() &#123; return new test1().name(); &#125; public int age() &#123; return new test2().age(); &#125; public static void main(String args[]) &#123; MainExample mi = new MainExample(); System.out.println("姓名:" + mi.name()); System.out.println("年龄:" + mi.age()); &#125;&#125; 大家注意看类三，里面分别实现了两个内部类 test1,和test2 ，test1类又继承了Example1，test2继承了Example2，这样我们的类三MainExample就拥有了Example1和Example2的方法和属性，也就间接地实现了多继承。 4、避免修改接口而实现同一个类中两种同名方法的调用。 大家假想一下如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？这就需要我们的内部类了。看下面的代码 12345678910111213141516// 接口package insidecategory;public interface Incrementable &#123; void increment();&#125;// 类 MyIncrementpackage insidecategory;public class MyIncrement &#123; public void increment() &#123; System.out.println("Other increment()"); &#125; static void f(MyIncrement f) &#123; f.increment(); &#125;&#125; 大家看上面的increment()方法，两个方法都是一样的。在看下面这个类要继承这两个类，如果不用内部类 123456package insidecategory;public class Callee2 extends MyIncrement implements Incrementable &#123; public void increment() &#123; //代码 &#125;&#125; 想问一下大家 increment() 这个方法是属于覆盖MyIncrement这里的方法呢？还是Incrementable这里的方法。我怎么能调到MyIncrement这里的方法？显然这是不好区分的。而我们如果用内部类就很好解决这一问题了。 看下面代码 1234567891011121314151617package insidecategory;public class Callee2 extends MyIncrement &#123; private int i=0; private void incr() &#123; i++; System.out.println(i); &#125; private class Closure implements Incrementable &#123; public void increment() &#123; incr(); &#125; &#125; Incrementable getCallbackReference() &#123; return new Closure(); &#125;&#125; 我们可以用内部类来实现接口，这样就不会与外围类的方法冲突了。]]></content>
      <tags>
        <tag>Java</tag>
        <tag>面向对象</tag>
        <tag>内部类</tag>
        <tag>inner class</tag>
      </tags>
  </entry>
</search>
